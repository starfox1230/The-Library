<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Matilda Lesson Hopper</title>
  <style>
    :root{
      --bg:#070812;
      --panel:rgba(255,255,255,.08);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --shadow: 0 16px 40px rgba(0,0,0,.45);
    }
    html,body{height:100%; margin:0; background:
      radial-gradient(1200px 700px at 20% 10%, rgba(139,92,246,.35), transparent 60%),
      radial-gradient(900px 600px at 80% 15%, rgba(34,211,238,.25), transparent 55%),
      radial-gradient(900px 700px at 40% 80%, rgba(251,113,133,.18), transparent 60%),
      var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }
    #app{position:fixed; inset:0; display:flex; flex-direction:column;}
    #topbar{
      display:flex; gap:10px; align-items:center; padding:12px; z-index:5;
    }
    .chip{
      background:var(--panel);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:flex; align-items:center; gap:10px;
      user-select:none;
    }
    .title{font-weight:800; letter-spacing:.2px}
    .sub{font-size:12px; color:var(--muted)}
    #progressWrap{flex:1; min-width:0;}
    .bar{
      height:12px; border-radius:999px;
      background:rgba(255,255,255,.10);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      margin-top:8px;
    }
    .bar > i{
      display:block; height:100%; width:0%;
      background:linear-gradient(90deg, rgba(34,211,238,.95), rgba(139,92,246,.95), rgba(251,113,133,.95));
      border-radius:999px;
      transition: width 420ms cubic-bezier(.2,.8,.2,1);
    }
    .seg{display:flex; gap:6px; padding:6px;}
    .seg button{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:999px;
      font-weight:800;
      cursor:pointer;
    }
    .seg button.active{
      background:linear-gradient(135deg, rgba(34,211,238,.22), rgba(139,92,246,.25));
      border-color:rgba(34,211,238,.35);
    }

    #canvasWrap{position:relative; flex:1; min-height:0;}
    canvas{display:block; width:100%; height:100%;}

    #dock{
      display:flex; gap:10px; padding:12px; justify-content:space-between; align-items:center; z-index:5;
    }
    .btn{
      border:none; cursor:pointer; color:var(--text);
      padding:14px 16px; border-radius:16px;
      background:linear-gradient(135deg, rgba(34,211,238,.25), rgba(139,92,246,.30));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      font-weight:900;
      min-width: 180px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.secondary{min-width:auto; background:rgba(255,255,255,.07);}
    .btn:active{transform: translateY(1px);}

    .overlay{position:fixed; inset:0; display:none; place-items:center; z-index:20;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .overlay.show{display:grid;}
    .modal{
      width:min(560px, calc(100vw - 28px));
      border-radius:24px;
      background:rgba(10,10,18,.78);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 26px 70px rgba(0,0,0,.6);
      padding:16px;
    }
    .modal h2{margin:4px 6px 6px; font-size:18px}
    .modal p{margin:0 6px 12px; color:var(--muted); font-size:13px; line-height:1.35}
    .actions{display:flex; gap:10px; justify-content:flex-end; padding:10px 6px 6px;}
    .mini{min-width:auto; padding:12px 14px; border-radius:14px;}
    .row{display:flex; gap:10px; padding:10px 6px; align-items:center; flex-wrap:wrap;}
    label{font-size:13px; color:var(--muted); font-weight:800}
    input[type="number"]{
      width:92px; padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.07);
      color:var(--text);
      font-weight:900;
      outline:none;
    }

    #toast{
      position:fixed; left:50%; bottom:90px; transform:translateX(-50%);
      padding:12px 14px; border-radius:999px;
      background:rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      font-weight:900;
      display:none;
      z-index:30;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      max-width: calc(100vw - 28px);
      text-align:center;
      user-select:none;
    }
    #toast.show{display:block;}

    /* Simple debug banner for script errors / missing WebGL */
    #debug{
      position:fixed; top:12px; left:12px; right:12px;
      background:rgba(0,0,0,.65);
      border:1px solid rgba(255,255,255,.18);
      border-radius:14px;
      padding:10px 12px;
      font-size:12px;
      color:rgba(255,255,255,.85);
      display:none;
      z-index:999;
      white-space:pre-wrap;
    }
    #debug.show{display:block;}
  </style>
</head>
<body>
  <div id="debug"></div>

  <div id="app">
    <div id="topbar">
      <div class="chip">
        <div>
          <div class="title" id="seriesTitle">Easy Lessons</div>
          <div class="sub" id="seriesSub">Lesson <span id="currentLessonText">1</span> / 100</div>
        </div>
      </div>

      <div class="chip" id="progressWrap">
        <div style="width:100%">
          <div style="display:flex; justify-content:space-between; align-items:baseline; gap:10px;">
            <div class="title">Overall</div>
            <div class="sub" id="overallText">0 / 200</div>
          </div>
          <div class="bar"><i id="overallBar"></i></div>
        </div>
      </div>

      <div class="chip seg">
        <button id="btnEasy" class="active" type="button">Easy</button>
        <button id="btnTCR" type="button">Teacher</button>
      </div>
    </div>

    <div id="canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div id="dock">
      <button class="btn" id="completeBtn" type="button">‚úÖ Complete Lesson</button>
      <button class="btn secondary" id="settingsBtn" type="button">‚öôÔ∏è</button>
    </div>
  </div>

  <div class="overlay" id="confirmOverlay">
    <div class="modal">
      <h2 id="confirmTitle">Complete lesson?</h2>
      <p id="confirmText">Did we finish Lesson 1?</p>
      <div class="actions">
        <button class="btn mini" id="confirmNo" type="button">Not yet</button>
        <button class="btn mini" id="confirmYes" type="button">Yes!</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="settingsOverlay">
    <div class="modal">
      <h2>Settings</h2>
      <p>Hold the gear for ~1 second to open (parent-only).</p>

      <div class="row">
        <label for="easyCurrent">Easy current</label>
        <input id="easyCurrent" type="number" min="1" max="100" />
        <label for="easyCompleted">Easy completed up to</label>
        <input id="easyCompleted" type="number" min="0" max="100" />
      </div>

      <div class="row">
        <label for="tcrCurrent">Teacher current</label>
        <input id="tcrCurrent" type="number" min="1" max="100" />
        <label for="tcrCompleted">Teacher completed up to</label>
        <input id="tcrCompleted" type="number" min="0" max="100" />
      </div>

      <div class="actions">
        <button class="btn mini" id="settingsClose" type="button">Close</button>
        <button class="btn mini" id="settingsSave" type="button">Save</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <!-- Use non-module Three.js (more reliable across iOS Safari / content blockers) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    /**************
     * Debug helpers
     **************/
    const debug = document.getElementById("debug");
    function showDebug(msg){
      debug.textContent = msg;
      debug.classList.add("show");
    }
    window.addEventListener("error", (e)=>{
      showDebug("JavaScript error:\n" + (e.message || e.error || "Unknown error"));
    });

    // WebGL check
    (function(){
      try{
        const c = document.createElement("canvas");
        const gl = c.getContext("webgl") || c.getContext("experimental-webgl");
        if(!gl) showDebug("WebGL is not available on this device/browser. Try a different browser or disable Low Power Mode/content blockers.");
      }catch(err){
        showDebug("WebGL check failed:\n" + err);
      }
    })();

    /**************
     * State
     **************/
    const STORAGE_KEY = "matildaLessonHopper_v2";
    function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

    function defaultState(){
      return {
        easy: { current: 1, completedUpTo: 0 },
        teacher: { current: 1, completedUpTo: 0 },
        activeSeries: "easy"
      };
    }
    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return defaultState();
        const s = JSON.parse(raw);
        for(const k of ["easy","teacher"]){
          s[k] = s[k] || {};
          s[k].current = clamp(Number(s[k].current || 1), 1, 100);
          s[k].completedUpTo = clamp(Number(s[k].completedUpTo || 0), 0, 100);
        }
        s.activeSeries = (s.activeSeries === "teacher") ? "teacher" : "easy";
        return s;
      }catch{
        return defaultState();
      }
    }
    function saveState(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }
    let state = loadState();

    function seriesKey(){ return state.activeSeries; }
    function seriesLabel(){ return seriesKey()==="easy" ? "Easy Lessons" : "Teacher-Child Read"; }
    function seriesShort(){ return seriesKey()==="easy" ? "Easy" : "Teacher"; }
    function currentLesson(){ return state[seriesKey()].current; }
    function completedUpTo(){ return state[seriesKey()].completedUpTo; }
    function overallCompleted(){ return state.easy.completedUpTo + state.teacher.completedUpTo; }
    function unlocked(){ return state.easy.completedUpTo>=100 && state.teacher.completedUpTo>=100; }

    /**************
     * UI
     **************/
    const $ = (id)=>document.getElementById(id);
    const seriesTitleEl = $("seriesTitle");
    const currentLessonTextEl = $("currentLessonText");
    const overallTextEl = $("overallText");
    const overallBarEl = $("overallBar");
    const btnEasy = $("btnEasy");
    const btnTCR = $("btnTCR");
    const completeBtn = $("completeBtn");

    const confirmOverlay = $("confirmOverlay");
    const confirmTitle = $("confirmTitle");
    const confirmText = $("confirmText");
    const confirmNo = $("confirmNo");
    const confirmYes = $("confirmYes");

    const settingsBtn = $("settingsBtn");
    const settingsOverlay = $("settingsOverlay");
    const settingsClose = $("settingsClose");
    const settingsSave = $("settingsSave");
    const easyCurrent = $("easyCurrent");
    const easyCompleted = $("easyCompleted");
    const tcrCurrent = $("tcrCurrent");
    const tcrCompleted = $("tcrCompleted");

    const toast = $("toast");
    let toastTimer=null;
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer=setTimeout(()=>toast.classList.remove("show"), 1100);
    }

    function updateUI(){
      seriesTitleEl.textContent = seriesLabel();
      currentLessonTextEl.textContent = String(currentLesson());
      const oc = overallCompleted();
      overallTextEl.textContent = `${oc} / 200`;
      overallBarEl.style.width = `${(oc/200)*100}%`;
      btnEasy.classList.toggle("active", seriesKey()==="easy");
      btnTCR.classList.toggle("active", seriesKey()==="teacher");
      completeBtn.textContent = unlocked() ? "üéâ Trampoline Unlocked!" : "‚úÖ Complete Lesson";
    }

    btnEasy.onclick = ()=>{ state.activeSeries="easy"; saveState(); updateUI(); refreshNodeStyles(); hopToLesson(currentLesson(), false); };
    btnTCR.onclick = ()=>{ state.activeSeries="teacher"; saveState(); updateUI(); refreshNodeStyles(); hopToLesson(currentLesson(), false); };

    completeBtn.onclick = ()=>{
      const cur = currentLesson();
      confirmTitle.textContent = unlocked() ? "All done!" : "Complete lesson?";
      confirmText.textContent = `Did we finish Lesson ${cur} (${seriesShort()})?`;
      confirmOverlay.classList.add("show");
    };
    confirmNo.onclick = ()=>confirmOverlay.classList.remove("show");
    confirmYes.onclick = ()=>{
      confirmOverlay.classList.remove("show");
      completeCurrentLesson();
    };

    function completeCurrentLesson(){
      const key = seriesKey();
      const cur = state[key].current;
      state[key].completedUpTo = Math.max(state[key].completedUpTo, cur);
      state[key].current = clamp(cur+1, 1, 100);
      saveState();
      updateUI();
      refreshNodeStyles();
      hopToLesson(state[key].current, true);
      if(unlocked()) showToast("Trampoline Time unlocked!");
      else showToast("Nice work!");
    }

    // Parent-only settings: hold gear ~1s
    let holdTimer=null;
    function startHold(){
      holdTimer=setTimeout(()=>{
        easyCurrent.value = state.easy.current;
        easyCompleted.value = state.easy.completedUpTo;
        tcrCurrent.value = state.teacher.current;
        tcrCompleted.value = state.teacher.completedUpTo;
        settingsOverlay.classList.add("show");
        showToast("Parent settings");
      }, 900);
    }
    function endHold(){
      if(holdTimer){
        clearTimeout(holdTimer);
        holdTimer=null;
        showToast("Hold to open settings");
      }
    }
    settingsBtn.addEventListener("touchstart",(e)=>{e.preventDefault(); startHold();},{passive:false});
    settingsBtn.addEventListener("touchend",(e)=>{e.preventDefault(); endHold();},{passive:false});
    settingsBtn.addEventListener("mousedown",(e)=>{e.preventDefault(); startHold();});
    settingsBtn.addEventListener("mouseup",(e)=>{e.preventDefault(); endHold();});
    settingsBtn.addEventListener("mouseleave",()=>{ if(holdTimer){clearTimeout(holdTimer); holdTimer=null;} });

    settingsClose.onclick = ()=>settingsOverlay.classList.remove("show");
    settingsOverlay.onclick = (e)=>{ if(e.target===settingsOverlay) settingsOverlay.classList.remove("show"); };
    settingsSave.onclick = ()=>{
      state.easy.current = clamp(Number(easyCurrent.value||1), 1, 100);
      state.easy.completedUpTo = clamp(Number(easyCompleted.value||0), 0, 100);
      state.teacher.current = clamp(Number(tcrCurrent.value||1), 1, 100);
      state.teacher.completedUpTo = clamp(Number(tcrCompleted.value||0), 0, 100);
      saveState();
      updateUI();
      settingsOverlay.classList.remove("show");
      refreshNodeStyles();
      hopToLesson(currentLesson(), false);
      showToast("Saved");
    };

    /**************
     * Three.js
     **************/
    const canvas = $("c");
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 300);

    const ambient = new THREE.AmbientLight(0xffffff, 0.55);
    scene.add(ambient);

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.25);
    keyLight.position.set(8, 12, 6);
    scene.add(keyLight);

    const rim = new THREE.DirectionalLight(0x88ccff, 0.6);
    rim.position.set(-10, 7, -8);
    scene.add(rim);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(220,220),
      new THREE.MeshStandardMaterial({color:0x0b0c18, roughness:0.95, metalness:0.0, emissive:0x0b0c18, emissiveIntensity:0.8})
    );
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -1.2;
    scene.add(floor);

    // Sparkles
    const sparkleGeo = new THREE.BufferGeometry();
    const sparkleCount = 700;
    const sparklePos = new Float32Array(sparkleCount*3);
    for(let i=0;i<sparkleCount;i++){
      const r = 28*Math.random();
      const a = Math.random()*Math.PI*2;
      sparklePos[i*3+0] = Math.cos(a)*r + (Math.random()-0.5)*6;
      sparklePos[i*3+1] = Math.random()*10 + 0.5;
      sparklePos[i*3+2] = Math.sin(a)*r + (Math.random()-0.5)*6;
    }
    sparkleGeo.setAttribute("position", new THREE.BufferAttribute(sparklePos,3));
    const sparkles = new THREE.Points(sparkleGeo, new THREE.PointsMaterial({color:0xffffff, size:0.06, transparent:true, opacity:0.5}));
    scene.add(sparkles);

    // Path
    const pathGroup = new THREE.Group();
    scene.add(pathGroup);

    const nodes = [];     // {idx, disc, ring, pos}
    const pickables = []; // discs only

    const nodeBaseMat = new THREE.MeshStandardMaterial({color:0x1b1f3a, roughness:0.35, metalness:0.25});
    const nodeDoneMat = new THREE.MeshStandardMaterial({color:0x2ee6b6, roughness:0.25, metalness:0.2, emissive:0x133d35, emissiveIntensity:0.8});
    const nodeNextMat = new THREE.MeshStandardMaterial({color:0x7c3aed, roughness:0.22, metalness:0.3, emissive:0x2a0f6a, emissiveIntensity:1.1});
    const ringGeo = new THREE.TorusGeometry(0.78, 0.08, 12, 48);

    function nodePosition(i){
      const t = (i-1)/99;                 // 0..1
      const ang = t * Math.PI * 1.85;
      const radius = 10.5;
      const w = Math.sin(t*Math.PI*6)*0.55;
      return new THREE.Vector3(Math.cos(ang)*radius + w, 0, Math.sin(ang)*radius);
    }

    function rebuildPath(){
      while(pathGroup.children.length) pathGroup.remove(pathGroup.children[0]);
      nodes.length = 0;
      pickables.length = 0;

      for(let i=1;i<=100;i++){
        const pos = nodePosition(i);

        const disc = new THREE.Mesh(new THREE.CylinderGeometry(0.82,0.82,0.22,32), nodeBaseMat);
        disc.position.copy(pos);
        disc.position.y = -0.05;
        disc.userData.idx = i;
        pathGroup.add(disc);
        pickables.push(disc);

        const ring = new THREE.Mesh(ringGeo, nodeBaseMat);
        ring.position.copy(pos);
        ring.position.y = 0.10;
        ring.rotation.x = Math.PI/2;
        pathGroup.add(ring);

        nodes.push({idx:i, disc, ring, pos});
      }
      refreshNodeStyles();
    }

    // Ball
    const ball = new THREE.Mesh(
      new THREE.SphereGeometry(0.6, 40, 40),
      new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.18, metalness:0.25, emissive:0x22104a, emissiveIntensity:0.45})
    );
    scene.add(ball);

    const ballRing = new THREE.Mesh(
      new THREE.TorusGeometry(0.75,0.06,12,48),
      new THREE.MeshStandardMaterial({color:0x22d3ee, emissive:0x22d3ee, emissiveIntensity:1.4, roughness:0.35, metalness:0.0})
    );
    ballRing.rotation.x = Math.PI/2;
    scene.add(ballRing);

    // Confetti burst (simple points)
    const burstCount = 220;
    const burstGeo = new THREE.BufferGeometry();
    const burstPos = new Float32Array(burstCount*3);
    const burstVel = new Float32Array(burstCount*3);
    for(let i=0;i<burstCount;i++){
      burstPos[i*3+1] = -999;
      burstVel[i*3+0] = (Math.random()-0.5)*8;
      burstVel[i*3+1] = Math.random()*10 + 6;
      burstVel[i*3+2] = (Math.random()-0.5)*8;
    }
    burstGeo.setAttribute("position", new THREE.BufferAttribute(burstPos,3));
    const burstMat = new THREE.PointsMaterial({color:0xffffff, size:0.12, transparent:true, opacity:0.9});
    const burst = new THREE.Points(burstGeo, burstMat);
    scene.add(burst);
    let burstActive=false, burstT=0;
    function triggerBurst(at){
      burstActive=true; burstT=0;
      const posAttr = burst.geometry.getAttribute("position");
      for(let i=0;i<burstCount;i++){
        posAttr.array[i*3+0] = at.x;
        posAttr.array[i*3+1] = at.y + 0.2;
        posAttr.array[i*3+2] = at.z;
        burstVel[i*3+0] = (Math.random()-0.5)*8;
        burstVel[i*3+1] = Math.random()*10 + 6;
        burstVel[i*3+2] = (Math.random()-0.5)*8;
      }
      posAttr.needsUpdate = true;
      burstMat.opacity = 0.95;
    }

    function refreshNodeStyles(){
      const cur = currentLesson();
      const done = completedUpTo();
      const next = clamp(done+1, 1, 100);

      const lo = cur - 10;
      const hi = cur + 14;

      for(const n of nodes){
        const i = n.idx;
        let mat = nodeBaseMat;
        if(i <= done) mat = nodeDoneMat;
        else if(i === next) mat = nodeNextMat;

        n.disc.material = mat;
        n.ring.material = mat;

        const far = (i < lo || i > hi);
        const s = far ? 0.6 : 1.0;
        n.disc.scale.setScalar(s);
        n.ring.scale.setScalar(s);

        const tooFar = (i < cur - 24 || i > cur + 28);
        n.disc.visible = !tooFar;
        n.ring.visible = !tooFar;
      }
    }

    function setBallAtLesson(idx){
      const p = nodes[idx-1]?.pos;
      if(!p) return;
      ball.position.set(p.x, 0.9, p.z);
      ballRing.position.copy(ball.position);
      ballRing.position.y = 0.9;
    }

    // Camera follow
    function focusCameraOnLesson(idx, snap){
      const p = nodes[idx-1]?.pos;
      if(!p) return;

      const prev = nodes[Math.max(0, idx-2)]?.pos || p;
      const dir = p.clone().sub(prev).normalize();
      const side = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();

      const target = p.clone();
      const camPos = p.clone().add(new THREE.Vector3(0, 9.5, 16)).add(side.multiplyScalar(6));

      camera.userData.target = target;
      camera.userData.camPos = camPos;

      if(snap){
        camera.position.copy(camPos);
        camera.lookAt(target);
      }
    }

    // Hop animation
    let hopAnim = null; // {from,to,t,duration,burst}
    function hopToLesson(idx, withBurst){
      const p = nodes[idx-1]?.pos;
      if(!p) return;
      const from = ball.position.clone();
      const to = new THREE.Vector3(p.x, 0.9, p.z);
      const dist = from.distanceTo(to);
      const duration = clamp(0.45 + dist*0.03, 0.45, 0.9);
      hopAnim = {from, to, t:0, duration, burst:withBurst};
      focusCameraOnLesson(idx, false);
    }

    /**************
     * Picking (click/tap nodes)
     **************/
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function pick(ev){
      const rect = canvas.getBoundingClientRect();
      const cx = (ev.touches ? ev.touches[0].clientX : ev.clientX);
      const cy = (ev.touches ? ev.touches[0].clientY : ev.clientY);
      const x = cx - rect.left;
      const y = cy - rect.top;

      pointer.x = (x / rect.width) * 2 - 1;
      pointer.y = -(y / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);

      const candidates = pickables.filter(o=>o.visible);
      const hits = raycaster.intersectObjects(candidates, false);
      if(!hits.length) return;

      const idx = hits[0].object.userData.idx;
      if(!idx) return;

      const done = completedUpTo();
      const next = clamp(done+1, 1, 100);

      if(idx === next || idx <= done){
        state[seriesKey()].current = idx;
        saveState();
        updateUI();
        refreshNodeStyles();
        hopToLesson(idx, false);
        showToast(idx === next ? `Go to Lesson ${idx}` : `Review Lesson ${idx}`);
      }else{
        showToast("Finish the next one first");
      }
    }

    canvas.addEventListener("mousedown", pick);
    canvas.addEventListener("touchstart", (e)=>{ e.preventDefault(); pick(e); }, {passive:false});

    /**************
     * Resize + init
     **************/
    function resize(){
      const w = canvas.clientWidth || window.innerWidth;
      const h = canvas.clientHeight || window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);

    // Build scene after layout has happened (fixes ‚Äúnothing renders / nothing clickable‚Äù issues)
    function init(){
      resize();
      camera.position.set(0, 9.5, 16);

      rebuildPath();
      updateUI();

      // snap camera + ball
      setBallAtLesson(currentLesson());
      focusCameraOnLesson(currentLesson(), true);

      // if Three didn't load for any reason, show debug
      if(typeof THREE === "undefined"){
        showDebug("Three.js failed to load. If you have a content blocker, disable it for this file.");
      }
      requestAnimationFrame(tick);
    }
    setTimeout(init, 0);

    /**************
     * Render loop
     **************/
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      sparkles.rotation.y += dt*0.08;

      // camera smooth
      if(camera.userData.camPos){
        camera.position.lerp(camera.userData.camPos, 1 - Math.pow(0.001, dt));
      }
      if(camera.userData.target){
        camera.lookAt(camera.userData.target);
      }

      // hop
      if(hopAnim){
        hopAnim.t += dt;
        const u = clamp(hopAnim.t / hopAnim.duration, 0, 1);
        const e = u < 0.5 ? 4*u*u*u : 1 - Math.pow(-2*u + 2, 3)/2; // ease in-out
        const arc = Math.sin(u*Math.PI) * 2.1;

        const p = hopAnim.from.clone().lerp(hopAnim.to, e);
        p.y += arc;

        const squash = 1 - Math.sin(u*Math.PI) * 0.22;
        const stretch = 1 + Math.sin(u*Math.PI) * 0.28;
        ball.scale.set(stretch, squash, stretch);

        ball.position.copy(p);
        ballRing.position.set(p.x, 0.9, p.z);
        ballRing.rotation.z = now*0.001;

        if(u >= 1){
          ball.scale.set(1,1,1);
          ball.position.copy(hopAnim.to);
          ballRing.position.set(hopAnim.to.x, 0.9, hopAnim.to.z);
          if(hopAnim.burst) triggerBurst(ball.position);
          hopAnim = null;
        }
      }else{
        // idle bounce
        const t = now*0.001;
        ball.position.y = 0.9 + Math.sin(t*2.2)*0.10;
        ballRing.position.set(ball.position.x, 0.9, ball.position.z);
        ballRing.rotation.z = t*0.9;
      }

      // confetti
      if(burstActive){
        burstT += dt;
        const posAttr = burst.geometry.getAttribute("position");
        const g = -16.0;
        for(let i=0;i<burstCount;i++){
          posAttr.array[i*3+0] += burstVel[i*3+0]*dt;
          posAttr.array[i*3+1] += burstVel[i*3+1]*dt;
          posAttr.array[i*3+2] += burstVel[i*3+2]*dt;
          burstVel[i*3+1] += g*dt;
        }
        posAttr.needsUpdate = true;
        burstMat.opacity = Math.max(0, 0.95 - burstT*0.55);
        if(burstT > 1.6){
          burstActive=false;
          for(let i=0;i<burstCount;i++) posAttr.array[i*3+1] = -999;
          posAttr.needsUpdate = true;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
  </script>
</body>
</html>