<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Phrase Library - Sentence Mode (Blocks & Merge/Unmerge)</title>
  <style>
    body { font-family: sans-serif; margin: 1rem; background: #fafafa; }
    h1 { margin-bottom: .5rem; }
    #controls { margin-bottom: 1rem; border-bottom: 1px solid #ccc; padding-bottom: 1rem;}
    textarea { width: 100%; height: 150px; font-family: monospace; box-sizing: border-box; }
    details { margin-top: 0.5rem; border-top: 1px solid #eee; padding-top: 0.5rem; }
    details summary { font-weight: 600; cursor: pointer; }
    ul { margin: .5rem 0 1rem 1.2rem; list-style-type: disc; padding-left: 1.5em; } /* Reverted list style */
    li { position: relative; margin-bottom: 0.1em; line-height: 1.4; padding-right: 3.5em; } /* Keep padding for buttons */
    li.highlight-group { background-color: #e0f0ff; } /* Added back highlight style */

    .btn-action { /* Renamed from .merge-handle/.unmerge-handle for consistency */
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      font-size: .9rem;
      background: white;
      border: 1px solid #ccc;
      border-radius: 3px;
      padding: 0 4px;
      line-height: 1;
      cursor: pointer;
      visibility: hidden;
      margin-left: 2px;
    }
    .merge-handle { right: 1.8em; color: blue; }
    .unmerge-handle { right: 0; color: orange; }

    li:hover .btn-action { visibility: visible; }
    ul > li:last-child .merge-handle { display: none; } /* Hide merge on the absolute last item in the list */

    button, input[type="file"] { margin-right: .5rem; padding: .3rem .6rem; margin-top: .5rem; }
    input[type="file"] { border: 1px solid #ccc; border-radius: 3px; }
    #btn-reset-cache { background-color: #fdd; border-color: #d88; color: #800;}
    label.button-like { display: inline-block; padding: .3rem .6rem; border: 1px solid #ccc; border-radius: 3px; background-color: #eee; cursor: pointer; }
    #json-upload { display: none; }
  </style>
</head>
<body>
  <h1>Phrase Library - Sentence Mode (Blocks & Merge/Unmerge)</h1>
  <div id="controls">
    <label for="blob">Paste all cases here:</label><br>
    <textarea id="blob" placeholder="Case 1 Attending Report: ... Case 2 Attending Report: ..."></textarea><br>
    <button id="btn-parse">Parse Cases & Store Unique Blocks</button> <!-- Changed button text -->
    <label for="json-upload" class="button-like">Upload JSON</label>
    <input type="file" id="json-upload" accept=".json">
    <button id="btn-download">Download JSON</button>
    <hr style="margin: 0.75rem 0; border: none; border-top: 1px dashed #ccc;">
    <button id="btn-reset-cache">Clear Saved Library</button>
  </div>

  <input
    type="text"
    id="txt-filter"
    placeholder="Filter sentences…"
    style="width:100%; box-sizing: border-box; padding: .4rem; margin-bottom:1rem;"
  >

  <div id="ui"></div>

  <script>
  // 1a) Canonical Section headers (Unchanged)
  const SECTIONS = [
    "LOWER NECK", "LUNGS / AIRWAYS / PLEURA", "HEART / VESSELS", "MEDIASTINUM / ESOPHAGUS", "DIAPHRAGM",
    "LYMPH NODES", "CHEST WALL", "LIVER", "BILIARY TRACT", "GALLBLADDER", "PANCREAS", "SPLEEN", "ADRENALS",
    "KIDNEYS", "STOMACH / SMALL BOWEL", "COLON / APPENDIX", "PERITONEUM / MESENTERY", "RETROPERITONEUM",
    "VESSELS", "URINARY BLADDER", "REPRODUCTIVE ORGANS", "BODY WALL", "MUSCULOSKELETAL", "CONCLUSION"
  ];

  // 1b) Mapping for Variations (Unchanged)
  const SECTION_MAP = {
    "LOWER NECK": "LOWER NECK",
    "LUNGS / AIRWAYS / PLEURA": "LUNGS / AIRWAYS / PLEURA",
    "LUNG BASES / PLEURA": "LUNGS / AIRWAYS / PLEURA",
    "HEART / VESSELS": "HEART / VESSELS",
    "MEDIASTINUM / ESOPHAGUS": "MEDIASTINUM / ESOPHAGUS",
    "DISTAL ESOPHAGUS": "MEDIASTINUM / ESOPHAGUS",
    "DIAPHRAGM": "DIAPHRAGM",
    "LYMPH NODES": "LYMPH NODES",
    "CHEST WALL": "CHEST WALL",
    "LIVER": "LIVER",
    "LIVER/BILIARY TRACT": "LIVER",
    "BILIARY TRACT": "BILIARY TRACT",
    "GALLBLADDER": "GALLBLADDER",
    "PANCREAS": "PANCREAS",
    "SPLEEN": "SPLEEN",
    "ADRENALS": "ADRENALS",
    "KIDNEYS": "KIDNEYS",
    "STOMACH / SMALL BOWEL": "STOMACH / SMALL BOWEL",
    "COLON / APPENDIX": "COLON / APPENDIX",
    "COLON": "COLON / APPENDIX",
    "PERITONEUM / MESENTERY": "PERITONEUM / MESENTERY",
    "PERITONEUM": "PERITONEUM / MESENTERY",
    "RETROPERITONEUM": "RETROPERITONEUM",
    "VESSELS": "VESSELS",
    "OTHER VESSELS": "VESSELS",
    "ABDOMINAL AORTA": "VESSELS",
    "CELIAC AXIS": "VESSELS",
    "SMA": "VESSELS",
    "RIGHT RENAL": "VESSELS",
    "LEFT RENAL": "VESSELS",
    "IMA": "VESSELS",
    "RIGHT ILIAC / PROXIMAL FEMORAL ARTERIES": "VESSELS",
    "LEFT ILIAC / PROXIMAL FEMORAL ARTERIES": "VESSELS",
    "LOWER ABDOMINAL AORTA": "VESSELS",
    "RIGHT COMMON / INTERNAL ILIAC ARTERIES": "VESSELS",
    "RIGHT EXTERNAL ILIAC ARTERY": "VESSELS",
    "LEFT COMMON / INTERNAL ILIAC ARTERIES": "VESSELS",
    "LEFT EXTERNAL ILIAC ARTERY": "VESSELS",
    "URINARY BLADDER": "URINARY BLADDER",
    "REPRODUCTIVE ORGANS": "REPRODUCTIVE ORGANS",
    "BODY WALL": "BODY WALL",
    "MUSCULOSKELETAL": "MUSCULOSKELETAL",
    "CONCLUSION": "CONCLUSION",
    "ABDOMEN AND PELVIS": null, "ABDOMEN": null, "PELVIS": null,
    "LOWER CHEST": null, "LOWER ABDOMEN": null, "UPPER ABDOMEN": null,
    "VASCULATURE": null, "FINDINGS": null, "STRUCTURED REPORT": null,
    "OTHER": null, "PERIANAL TISSUES": null,
    "PERIRECTAL / PERIANAL REGION": null,
    "IMAGE QUALITY": null, "OVERALL DIAGNOSTIC QUALITY": null,
    "LIVER LESIONS": "LIVER", "LIVER VASCULATURE AND COLLATERALS": null,
    "LIVER RELATED FINDINGS": null, "OTHER FINDINGS": null, "BOWEL": null
  };

  // 2) Data - Nested Array Structure (Blocks of Sentences)
  const LOCAL_STORAGE_KEY = 'phraseLibSentenceMode_v3_blocks'; // New key for block structure
  let library = {};
  function resetLibrary() {
    library = {};
    SECTIONS.forEach(s => library[s] = []); // Initialize with empty arrays (for blocks)
  }

  // Sentence split regex (Unchanged)
  const sentenceSplitRegex = /\S.+?[.!?](?=\s+[A-ZÀ-ÖØ-Þ0-9]|$)|S.+?[.!?]$|\S.+/g;
  const potentialMultiSentenceRegex = /.+?[.!?]\s+[A-ZÀ-ÖØ-Þ0-9]/;


  // 3) Parse blob - Modified for unique blocks
  function parseBlob(text) {
    if (!text.trim()) { alert("Cannot parse empty text."); return; }

    // Load existing library to add to it and check for duplicates
    loadState(); // Load existing blocks into `library`

    const uniqueBlockKeysInSection = {};
    SECTIONS.forEach(sec => {
      // Create a set of existing block keys (JSON stringified) for quick lookup
      uniqueBlockKeysInSection[sec] = new Set((library[sec] || []).map(block => JSON.stringify(block)));
    });

    let newBlocksAddedCount = 0;
    const caseChunks = text.split(/(?=^Case\s*\d+)/m).filter(Boolean);

    caseChunks.forEach(chunk => {
      const m = chunk.match(/Attending Report:\s*([\s\S]*?)(?=Resident Report:|Case\s*\d+|$)/i);
      if (!m?.[1]?.trim()) return;
      const attendingBlock = m[1].trim();

      const tempSectionTexts = {}; // Collect text per section *for this case*
      SECTIONS.forEach(s => tempSectionTexts[s] = "");
      let currentCanonicalSectionKey = null;

      // --- (Parsing logic within a case chunk - mostly unchanged) ---
       attendingBlock.split(/\r?\n/).forEach(line => {
        const t = line.trim();
        if (!t) return;
        const headerMatch = t.match(/^([A-Z0-9 \-\/]+):\s*(.*)/);
        if (headerMatch) {
          const hdr = headerMatch[1].toUpperCase();
          const rest = headerMatch[2].trim();
          if (hdr in SECTION_MAP) {
            const mapped = SECTION_MAP[hdr];
            currentCanonicalSectionKey = mapped;
            if (mapped && rest) {
                 let prefix = tempSectionTexts[mapped].length > 0 && !tempSectionTexts[mapped].endsWith(' ') ? ' ' : '';
                 if (tempSectionTexts[mapped].length > 0 && !/[.!?]$/.test(tempSectionTexts[mapped].trim())) {
                    prefix = '. ' + prefix;
                 }
                 tempSectionTexts[mapped] += prefix + rest;
            }
          } else {
            currentCanonicalSectionKey = null;
          }
        } else if (currentCanonicalSectionKey) {
            let prefix = tempSectionTexts[currentCanonicalSectionKey].length > 0 && !tempSectionTexts[currentCanonicalSectionKey].endsWith(' ') ? ' ' : '';
            if (tempSectionTexts[currentCanonicalSectionKey].length > 0 && !/[.!?]$/.test(tempSectionTexts[currentCanonicalSectionKey].trim())) {
               prefix = '. ' + prefix;
            }
            tempSectionTexts[currentCanonicalSectionKey] += prefix + t;
        }
      });
      // --- (End Parsing logic within a case chunk) ---

      // Process collected text into blocks and check uniqueness
      SECTIONS.forEach(sec => {
          let txt = (tempSectionTexts[sec] || "").replace(/\s+/g, ' ').replace(/ \./g, '.').trim();
          if (txt && !txt.endsWith('.') && !txt.endsWith('?') && !txt.endsWith('!')) txt += '.';
          if (!txt) return;

          const sentences = txt.match(sentenceSplitRegex)?.map(s => s.trim()).filter(Boolean) || [];
          if (sentences.length === 0) return; // Don't add empty blocks

          // Check if this exact block (sentences in this order) already exists
          const blockKey = JSON.stringify(sentences);
          if (!uniqueBlockKeysInSection[sec].has(blockKey)) {
              library[sec].push(sentences); // Add the new unique block (as an array of sentences)
              uniqueBlockKeysInSection[sec].add(blockKey); // Mark this block key as seen
              newBlocksAddedCount++;
          }
      });
    });

    saveState();
    renderAllSections();
    document.getElementById('blob').value = ''; // Clear textarea
    alert(`Parsed ${caseChunks.length} case blocks. Added ${newBlocksAddedCount} new unique blocks to the library.`);
  }

  // 4) Render - Adapted for block structure and highlighting
  function renderAllSections() {
    const ui = document.getElementById('ui');
    ui.innerHTML = '';
    let hasContent = false;
    SECTIONS.forEach(sec => {
      if (renderSection(sec, ui)) {
        hasContent = true;
      }
    });
    if (!hasContent) {
      ui.innerHTML = '<p style="color: grey; text-align: center; margin-top: 2rem;">Library is empty. Paste cases or upload JSON.</p>';
    }
    applyFilter(); // Re-apply filter after rendering
  }

 function renderSection(sec, container) {
    const blocks = library[sec] || [];
    let det = container.querySelector(`details[data-section="${sec}"]`);
    const totalSentences = blocks.reduce((count, block) => count + block.length, 0);

    if (totalSentences === 0) {
      det?.remove();
      return false; // No content
    }

    let ul;
    let isNew = false;
    if (!det) {
      isNew = true;
      det = document.createElement('details');
      det.dataset.section = sec;
      const sum = document.createElement('summary');
      det.appendChild(sum);
      ul = document.createElement('ul');
      det.appendChild(ul);

      // Insert in correct order (same logic as before)
       const sectionIndex = SECTIONS.indexOf(sec);
       let inserted = false;
       for (let i = sectionIndex + 1; i < SECTIONS.length; i++) {
           const nextSectionKey = SECTIONS[i];
           const nextSectionElement = container.querySelector(`details[data-section="${nextSectionKey}"]`);
           if (nextSectionElement) {
               container.insertBefore(det, nextSectionElement);
               inserted = true;
               break;
           }
       }
       if (!inserted) {
           container.appendChild(det);
       }

    } else {
      ul = det.querySelector('ul');
      ul.innerHTML = ''; // Clear previous list items
    }

    // Update summary
    det.querySelector('summary').textContent = `${sec} (${totalSentences} sentences / ${blocks.length} unique blocks)`;

    // Render list items, adding block and sentence indices
    blocks.forEach((block, bIdx) => {
      block.forEach((sentence, sIdx) => {
        const li = document.createElement('li');
        li.dataset.sec = sec;
        li.dataset.blockIdx = bIdx; // Identify the block
        li.dataset.sentIdx = sIdx; // Identify the sentence within the block
        li.textContent = sentence;

        // Add Merge Button (logic relies on absolute next sibling, handled by CSS :last-child)
        li.innerHTML += ` <span class="btn-action merge-handle" title="Merge with next">⇆</span>`;

        // Add Unmerge Button
        li.innerHTML += ` <span class="btn-action unmerge-handle" title="Split this sentence">⨷</span>`;

        ul.appendChild(li);
      });
    });

     // Hide merge button on the very last li of the ul
     if (ul.lastElementChild) {
         const lastMergeHandle = ul.lastElementChild.querySelector('.merge-handle');
         if(lastMergeHandle) lastMergeHandle.style.display = 'none';
     }


    return true; // Section has content
  }

  // 5a) Highlight - Added back
  const uiContainer = document.getElementById('ui');
  uiContainer.addEventListener('mouseover', e => {
    const li = e.target.closest('li');
    // Check for necessary data attributes before proceeding
    if (!li || !li.dataset.sec || li.dataset.blockIdx === undefined) return;
    const sec = li.dataset.sec;
    const bIdx = li.dataset.blockIdx;
    // Find the parent UL
    const ul = li.closest('ul');
    if (!ul) return;
    // Query within the UL for siblings from the same block
    ul.querySelectorAll(`li[data-sec="${sec}"][data-block-idx="${bIdx}"]`)
      .forEach(item => item.classList.add('highlight-group'));
  });
  uiContainer.addEventListener('mouseout', e => {
    const li = e.target.closest('li');
     // Check for necessary data attributes before proceeding
    if (!li || !li.dataset.sec || li.dataset.blockIdx === undefined) return;
    const sec = li.dataset.sec;
    const bIdx = li.dataset.blockIdx;
     // Find the parent UL
     const ul = li.closest('ul');
     if (!ul) return;
    // Query within the UL to remove class
    ul.querySelectorAll(`li[data-sec="${sec}"][data-block-idx="${bIdx}"]`)
      .forEach(item => item.classList.remove('highlight-group'));
  });


  // 5b) Actions (Merge/Unmerge) - Adapted for block structure
  uiContainer.addEventListener('click', e => {
    const target = e.target;

    // --- Handle Merge ---
    if (target.classList.contains('merge-handle')) {
      const li1 = target.closest('li');
      const li2 = li1.nextElementSibling; // Merge with the immediately following sentence visually

      // Ensure both li exist and belong to the same section
      if (!li1 || !li2 || !li1.dataset.sec || !li2.dataset.sec || li1.dataset.sec !== li2.dataset.sec) {
          console.warn("Merge target invalid or cross-section.", li1, li2);
          return;
      }

      const sec = li1.dataset.sec;
      // Get indices from data attributes
      const b1 = +li1.dataset.blockIdx;
      const s1 = +li1.dataset.sentIdx;
      const b2 = +li2.dataset.blockIdx;
      const s2 = +li2.dataset.sentIdx;

      // Get text from the library using indices
      if (!library[sec] || !library[sec][b1] || !library[sec][b2]) {
          console.error("Library data missing for merge indices:", sec, b1, s1, b2, s2);
          return;
      }
      const t1 = library[sec][b1][s1];
      const t2 = library[sec][b2][s2];

      if (t1 === undefined || t2 === undefined) {
         console.error("Sentence text undefined for merge indices:", sec, b1, s1, b2, s2);
         return;
      }

      const merged = (t1 + ' ' + t2).replace(/\s+/g, ' ').trim();

      // --- Update Library ---
      // 1. Replace the text of the first sentence
      library[sec][b1][s1] = merged;

      // 2. Remove the second sentence from its block
      library[sec][b2].splice(s2, 1);

      // 3. If the second sentence's block is now empty, remove the block
      if (library[sec][b2].length === 0) {
        library[sec].splice(b2, 1);
        // Note: Removing a block changes the block indices (bIdx) of subsequent blocks.
        // Re-rendering the entire section handles this automatically.
      }

      saveState();
      renderSection(sec, uiContainer); // Re-render the affected section
    }

    // --- Handle Unmerge ---
    else if (target.classList.contains('unmerge-handle')) {
      const li = target.closest('li');
      if (!li || !li.dataset.sec || li.dataset.blockIdx === undefined || li.dataset.sentIdx === undefined) return;

      const sec = li.dataset.sec;
      const bIdx = +li.dataset.blockIdx;
      const sIdx = +li.dataset.sentIdx;

      if (!library[sec] || !library[sec][bIdx] || library[sec][bIdx][sIdx] === undefined) {
          console.error("Library data missing for unmerge indices:", sec, bIdx, sIdx);
          return;
      }
      const text = library[sec][bIdx][sIdx];

      // Attempt to split the sentence
      const parts = text.match(sentenceSplitRegex)?.map(s => s.trim()).filter(Boolean) || [];

      if (parts.length > 1) {
        // Replace the original sentence with the split parts *within the same block*
        library[sec][bIdx].splice(sIdx, 1, ...parts);
        saveState();
        renderSection(sec, uiContainer); // Re-render the section
      } else {
        alert("Cannot split this sentence further based on punctuation (.!?) followed by a capital letter.");
      }
    }
  });


  // 6) Persistence - Adapted for nested array structure
  function saveState() {
    try {
      const libraryToSave = {};
      SECTIONS.forEach(sec => {
        // Only save sections that have blocks, and blocks that have sentences
        if (library[sec] && library[sec].length > 0) {
          const validBlocks = library[sec].filter(block => Array.isArray(block) && block.length > 0);
          if (validBlocks.length > 0) {
              libraryToSave[sec] = validBlocks;
          }
        }
      });
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(libraryToSave));
    } catch (e) {
      console.error("Error saving state to localStorage:", e);
      alert("Error saving state. LocalStorage might be full or unavailable.");
    }
  }

  function loadState() {
    const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
    resetLibrary(); // Start with empty sections
    if (saved) {
      try {
        const loadedLibrary = JSON.parse(saved);
        SECTIONS.forEach(sec => {
          // Validate: Ensure the loaded data is an array of arrays (of strings)
          if (loadedLibrary[sec] && Array.isArray(loadedLibrary[sec])) {
             library[sec] = loadedLibrary[sec].filter(block =>
                Array.isArray(block) && block.every(sentence => typeof sentence === 'string')
             );
          }
        });
      } catch (e) {
        console.error("Error loading state from localStorage:", e);
        localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear corrupted data
      }
    }
  }

  // 7) Event Listeners (Download/Upload adapted for block structure)
  document.getElementById('btn-parse').onclick = () =>
    parseBlob(document.getElementById('blob').value);

  document.getElementById('btn-download').onclick = () => {
     const sectionsWithContent = Object.keys(library).filter(sec => library[sec] && library[sec].length > 0 && library[sec].some(block => block.length > 0));
     if (sectionsWithContent.length === 0) {
        alert("Library is empty. Nothing to download.");
        return;
     }
     const libraryToDownload = {};
      sectionsWithContent.forEach(sec => {
          // Filter out any potentially empty blocks just before download
          const validBlocks = library[sec].filter(block => Array.isArray(block) && block.length > 0);
          if (validBlocks.length > 0) {
              libraryToDownload[sec] = validBlocks;
          }
      });

      if (Object.keys(libraryToDownload).length === 0) {
           alert("Library contains empty blocks only. Nothing to download.");
           return;
      }

     const str = JSON.stringify(libraryToDownload, null, 2);
     const blob = new Blob([str], { type: 'application/json' });
     const a = document.createElement('a');
     a.href = URL.createObjectURL(blob);
     const date = new Date();
     const timestamp = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
     a.download = `phraseLibBlocks_${timestamp}.json`; // Updated filename hint
     document.body.appendChild(a);
     a.click();
     document.body.removeChild(a);
     URL.revokeObjectURL(a.href);
  };

  document.getElementById('json-upload').addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const loadedLibrary = JSON.parse(event.target.result);
            resetLibrary(); // Clear current library
            SECTIONS.forEach(sec => {
               // Validate structure: array of arrays of strings
               if (loadedLibrary[sec] && Array.isArray(loadedLibrary[sec])) {
                  library[sec] = loadedLibrary[sec].filter(block =>
                      Array.isArray(block) &&
                      block.length > 0 && // Ensure block is not empty
                      block.every(sentence => typeof sentence === 'string' && sentence.trim().length > 0) // Ensure sentences are non-empty strings
                  );
               }
            });
            saveState();
            renderAllSections();
            alert('Library loaded successfully from JSON!');
        } catch (err) {
            alert(`Error loading or parsing JSON file: ${err.message}`);
            console.error("JSON Load Error:", err);
        } finally {
            e.target.value = '';
        }
    };
    reader.onerror = (event) => {
        alert("Error reading file.");
        console.error("File Reader Error:", event);
        e.target.value = '';
    };
    reader.readAsText(f);
  });

  document.getElementById('btn-reset-cache').onclick = () => {
    if (confirm("Are you sure you want to clear the entire saved library from your browser? This cannot be undone.")) {
      localStorage.removeItem(LOCAL_STORAGE_KEY);
      resetLibrary();
      renderAllSections();
      alert("Saved library cleared.");
    }
  };

  // 8) Live search filter (Unchanged conceptually, works with new structure)
  const filterInput = document.getElementById('txt-filter');
  filterInput.addEventListener('input', applyFilter);

 function applyFilter() {
      const term = filterInput.value.trim().toLowerCase();
      let anyVisibleSections = false;
      document.querySelectorAll('#ui details').forEach(det => {
          let sectionHasVisibleItems = false;
          det.querySelectorAll('li').forEach(li => {
              const sentenceText = li.textContent.toLowerCase();
              const isVisible = !term || sentenceText.includes(term);
              li.style.display = isVisible ? '' : 'none';
              if (isVisible) {
                  sectionHasVisibleItems = true;
              }
          });

          det.style.display = sectionHasVisibleItems ? '' : 'none';
          if (sectionHasVisibleItems && term) {
              det.open = true;
          } else if (!sectionHasVisibleItems && term) {
             det.open = false;
          } else if (!term) {
             // Optional: close all when filter is cleared
             // det.open = false;
          }

          if (sectionHasVisibleItems) {
            anyVisibleSections = true;
          }
      });

       const noResultsMessage = document.getElementById('no-filter-results');
       if (!anyVisibleSections && term && !noResultsMessage) {
           const p = document.createElement('p');
           p.id = 'no-filter-results';
           p.textContent = 'No sentences match your filter.';
           p.style.textAlign = 'center';
           p.style.color = 'grey';
           uiContainer.appendChild(p);
       } else if ((anyVisibleSections || !term) && noResultsMessage) { // Remove if results found or filter cleared
           noResultsMessage.remove();
       }
  }

  // 9) Initialize
  (()=>{
    loadState();
    renderAllSections();
  })();
  </script>
</body>
</html>