<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Phrase Library w/ Split & Merge</title>
  <style>
    body { font-family:sans-serif; margin:1rem; background:#fafafa }
    h1 { margin-bottom:.5rem }
    #controls { margin-bottom:1rem }
    textarea { width:100%; font-family:monospace }
    .section { margin-bottom:1.5rem }
    .section h2 { margin:0.5rem 0 }
    .block { position:relative; padding:0.2rem 0; }
    .split-handle, .merge-handle {
      position:absolute; top:0; font-size:1rem;
      background:white; border:1px solid #ccc; border-radius:3px;
      padding:0 4px; line-height:1; cursor:pointer;
      visibility:hidden;
    }
    .split-handle { color:green; }
    .merge-handle { color:blue; }
    .block:hover .split-handle { visibility:visible }
    .merge-handle { left:50%; transform:translateX(-50%); }
  </style>
</head>
<body>
  <h1>Phrase Library</h1>
  <div id="controls">
    <label>Paste Cases Here:</label><br>
    <textarea id="blob" rows="6" placeholder="Case 1 Attending Report: …"></textarea><br>
    <button id="btn-parse">Parse</button>
    <input type="file" id="json-upload" accept=".json">
    <button id="btn-download">Download JSON</button>
  </div>
  <div id="ui"></div>

  <script>
  // 1) SECTIONS
  const SECTIONS = [
    "LUNGS / AIRWAYS / PLEURA","HEART / VESSELS","MEDIASTINUM / ESOPHAGUS","DIAPHRAGM",
    "LYMPH NODES","CHEST WALL",
    "LIVER","KIDNEYS","PANCREAS","SPLEEN","ADRENALS","COLON / APPENDIX",
    "BODY WALL","MUSCULOSKELETAL","CONCLUSION"
  ];

  // 2) DATA MODEL: section → [ blockString, blockString, … ]
  let library = {};

  function reset() {
    library = {};
    SECTIONS.forEach(s => library[s] = []);
  }

  // 3) PARSING: build one big text block per section
  function parseBlob(text) {
    reset();
    const re = /Attending Report:(.+?)(?=(Case\s*\d+|$))/gis;
    let m;
    while((m = re.exec(text))) {
      const block = m[1];
      // for each expected section, grab its chunk of lines
      SECTIONS.forEach(sec => {
        const rx = new RegExp(sec + ':(.*?)((?=[A-Z0-9 \-/]+:)|$)', 'is');
        const gm = block.match(rx);
        if(gm) {
          const txt = gm[1].trim().replace(/\r?\n/g,' ');
          if(txt) library[sec] = [ txt.endsWith('.') ? txt : txt+'.' ];
        }
      });
    }
    saveAndRender();
  }

  // 4) RENDER UI
  function renderUI() {
    const ui = document.getElementById('ui');
    ui.innerHTML = '';
    SECTIONS.forEach(sec => {
      if(library[sec].length === 0) return;
      const container = document.createElement('div');
      container.className = 'section';
      container.innerHTML = `<h2>${sec}</h2>`;
      library[sec].forEach((block, bi) => {
        const p = document.createElement('p');
        p.className = 'block';
        p.dataset.sec = sec;
        p.dataset.bi = bi;
        // Split into sentences to inject split-handles
        const sents = block.split(/(\.\s+)/).reduce((acc,v,i,arr)=>{
          if(/\.\s+/.test(v)) acc[acc.length-1] += v;
          else acc.push(v);
          return acc;
        }, []);
        p.innerHTML = sents.map((s,i)=>{
          const html = `<span>${s}</span>` +
            (i < sents.length-1
              ? `<span class="split-handle" data-si="${i}">➕</span>`
              : '');
          return html;
        }).join('');
        container.appendChild(p);

        // If there’s another block after, insert merge handle
        if(bi < library[sec].length -1) {
          const mBtn = document.createElement('div');
          mBtn.className = 'merge-handle';
          mBtn.textContent = '⇆';
          mBtn.dataset.sec = sec;
          mBtn.dataset.bi = bi;
          container.appendChild(mBtn);
        }
      });
      ui.appendChild(container);
    });
  }

  // 5) EVENT LISTENING: split & merge
  document.body.addEventListener('click', e => {
    if(e.target.classList.contains('split-handle')) {
      const sec = e.target.closest('.block').dataset.sec;
      const bi  = +e.target.closest('.block').dataset.bi;
      const si  = +e.target.dataset.si;
      doSplit(sec, bi, si);
    }
    if(e.target.classList.contains('merge-handle')) {
      const sec = e.target.dataset.sec;
      const bi  = +e.target.dataset.bi;
      doMerge(sec, bi);
    }
  });

  function doSplit(sec, bi, si) {
    const block = library[sec][bi];
    // split into sentence array:
    const arr = block.split(/(\.\s+)/).reduce((acc,v,i,arr)=>{
      if(/\.\s+/.test(v)) acc[acc.length-1] += v;
      else acc.push(v);
      return acc;
    }, []);
    // build two new blocks
    const left  = arr.slice(0, si+1).join('').trim();
    const right = arr.slice(si+1).join('').trim();
    library[sec].splice(bi,1,
      left.endsWith('.')?left:left+'.',
      right.endsWith('.')?right:right+'.'
    );
    saveAndRender();
  }

  function doMerge(sec, bi) {
    const a = library[sec][bi], b = library[sec][bi+1];
    const merged = (a+' '+b).trim();
    library[sec].splice(bi,2, merged.endsWith('.')?merged:merged+'.');
    saveAndRender();
  }

  // 6) SAVE to localStorage & re-render
  function saveAndRender() {
    localStorage.setItem('phraseLib', JSON.stringify(library));
    renderUI();
  }

  // 7) HOOK UP CONTROLS
  document.getElementById('btn-parse')
    .addEventListener('click', () => parseBlob(
      document.getElementById('blob').value
    ));

  document.getElementById('btn-download')
    .addEventListener('click', () => {
      const blob = new Blob([localStorage.getItem('phraseLib')], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'phraseLibrary.json';
      a.click();
    });

  document.getElementById('json-upload')
    .addEventListener('change', e => e.target.files[0].text()
      .then(txt => {
        library = JSON.parse(txt);
        saveAndRender();
      })
    );

  // 8) INIT
  (() => {
    const saved = localStorage.getItem('phraseLib');
    if(saved) library = JSON.parse(saved);
    else reset();
    renderUI();
  })();
  </script>
</body>
</html>