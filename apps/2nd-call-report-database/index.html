<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Phrase Library w/ In‑bullet Split & Merge</title>
  <style>
    body { font-family: sans-serif; margin: 1rem; background: #fafafa; }
    h1 { margin-bottom: .5rem; }
    #controls { margin-bottom: 1rem; border-bottom: 1px solid #ccc; padding-bottom: 1rem;}
    textarea { width: 100%; height: 150px; font-family: monospace; box-sizing: border-box; }
    details { margin-top: 0.5rem; border-top: 1px solid #eee; padding-top: 0.5rem; }
    details summary { font-weight: 600; cursor: pointer; }
    ul { margin: .5rem 0 1rem 1.2rem; list-style-type: disc; padding-left: 1.5em; }
    li { position: relative; margin-bottom: 0.3em; line-height: 1.4;}
    li .sentence-span { /* Style for sentence text if needed */ }
    .split-handle, .merge-handle { display: inline-block; font-size: .9rem; background: white; border: 1px solid #ccc; border-radius: 3px; padding: 0 4px; line-height: 1; cursor: pointer; visibility: hidden; margin: 0 0.2em; vertical-align: middle; }
    .split-handle { color: green; }
    .merge-handle { color: blue; }
    li:hover .split-handle, li:hover .merge-handle { visibility: visible; }
    button, input[type="file"] { margin-right: .5rem; padding: .3rem .6rem; margin-top: .5rem; }
    input[type="file"] { border: 1px solid #ccc; border-radius: 3px; }
    #btn-reset-cache { background-color: #fdd; border-color: #d88; color: #800;}
  </style>
</head>
<body>
  <h1>Phrase Library</h1>
  <div id="controls">
    <label for="blob">Paste all cases here:</label><br>
    <textarea id="blob" placeholder="Case 1 Attending Report: ... Case 2 Attending Report: ..."></textarea><br>
    <button id="btn-parse">Parse Cases</button>
    <label for="json-upload" class="button-like">Upload JSON</label>
    <input type="file" id="json-upload" accept=".json" >
    <button id="btn-download">Download JSON</button>
    <hr style="margin: 0.75rem 0; border: none; border-top: 1px dashed #ccc;">
    <button id="btn-reset-cache">Clear Saved Library</button>
  </div>
  <div id="ui"></div>

  <script>
  // 1a) Canonical Section headers
  const SECTIONS = [
    "LOWER NECK", "LUNGS / AIRWAYS / PLEURA", "HEART / VESSELS", "MEDIASTINUM / ESOPHAGUS", "DIAPHRAGM",
    "LYMPH NODES", "CHEST WALL", "LIVER", "BILIARY TRACT", "GALLBLADDER", "PANCREAS", "SPLEEN", "ADRENALS",
    "KIDNEYS", "STOMACH / SMALL BOWEL", "COLON / APPENDIX", "PERITONEUM / MESENTERY", "RETROPERITONEUM",
    "VESSELS", "URINARY BLADDER", "REPRODUCTIVE ORGANS", "BODY WALL", "MUSCULOSKELETAL", "CONCLUSION"
  ];

  // 1b) Mapping for Variations Found in Text -> Canonical Section Name
  const SECTION_MAP = {
    "LOWER NECK": "LOWER NECK",
    "LUNGS / AIRWAYS / PLEURA": "LUNGS / AIRWAYS / PLEURA",
    "LUNG BASES / PLEURA": "LUNGS / AIRWAYS / PLEURA",
    "HEART / VESSELS": "HEART / VESSELS",
    "MEDIASTINUM / ESOPHAGUS": "MEDIASTINUM / ESOPHAGUS",
    "DISTAL ESOPHAGUS": "MEDIASTINUM / ESOPHAGUS",
    "DIAPHRAGM": "DIAPHRAGM",
    "LYMPH NODES": "LYMPH NODES",
    "CHEST WALL": "CHEST WALL",
    "LIVER": "LIVER",
    "LIVER/BILIARY TRACT": "LIVER",
    "BILIARY TRACT": "BILIARY TRACT",
    "GALLBLADDER": "GALLBLADDER",
    "PANCREAS": "PANCREAS",
    "SPLEEN": "SPLEEN",
    "ADRENALS": "ADRENALS",
    "KIDNEYS": "KIDNEYS",
    "STOMACH / SMALL BOWEL": "STOMACH / SMALL BOWEL",
    "COLON / APPENDIX": "COLON / APPENDIX",
    "COLON": "COLON / APPENDIX",
    "PERITONEUM / MESENTERY": "PERITONEUM / MESENTERY",
    "PERITONEUM": "PERITONEUM / MESENTERY",
    "RETROPERITONEUM": "RETROPERITONEUM",
    "VESSELS": "VESSELS",
    "OTHER VESSELS": "VESSELS",
    "ABDOMINAL AORTA": "VESSELS",
    "CELIAC AXIS": "VESSELS",
    "SMA": "VESSELS",
    "RIGHT RENAL": "VESSELS",
    "LEFT RENAL": "VESSELS",
    "IMA": "VESSELS",
    "RIGHT ILIAC / PROXIMAL FEMORAL ARTERIES": "VESSELS",
    "LEFT ILIAC / PROXIMAL FEMORAL ARTERIES": "VESSELS",
    "LOWER ABDOMINAL AORTA": "VESSELS",
    "RIGHT COMMON / INTERNAL ILIAC ARTERIES": "VESSELS",
    "RIGHT EXTERNAL ILIAC ARTERY": "VESSELS",
    "LEFT COMMON / INTERNAL ILIAC ARTERIES": "VESSELS",
    "LEFT EXTERNAL ILIAC ARTERY": "VESSELS",
    "URINARY BLADDER": "URINARY BLADDER",
    "REPRODUCTIVE ORGANS": "REPRODUCTIVE ORGANS",
    "BODY WALL": "BODY WALL",
    "MUSCULOSKELETAL": "MUSCULOSKELETAL",
    "CONCLUSION": "CONCLUSION",
    // Intermediate headers to explicitly ignore
    "ABDOMEN AND PELVIS": null, // *** THIS ENTRY PREVENTS CAPTURE ***
    "ABDOMEN": null,
    "PELVIS": null,
    "LOWER CHEST": null,
    "LOWER ABDOMEN": null,
    "UPPER ABDOMEN": null,
    "VASCULATURE": null,
    "FINDINGS": null,
    "STRUCTURED REPORT": null,
    "OTHER": null,
    "PERIANAL TISSUES": null,
    "PERIRECTAL / PERIANAL REGION": null,
    "IMAGE QUALITY": null,
    "OVERALL DIAGNOSTIC QUALITY": null,
    "LIVER LESIONS": "LIVER",
    "LIVER VASCULATURE AND COLLATERALS": null,
    "LIVER RELATED FINDINGS": null,
    "OTHER FINDINGS": null,
    "BOWEL": null,
  };

  // 2) Data
  const LOCAL_STORAGE_KEY = 'phraseLib';
  let library = {};
  function resetLibrary() {
    library = {};
    SECTIONS.forEach(s => library[s] = []);
  }

  // 3) Parse blob
  function parseBlob(text) {
    if (!text || text.trim() === "") { alert("Cannot parse empty text."); return; }
    resetLibrary();
    let uniquePhrasesInSection = {};
    SECTIONS.forEach(s => uniquePhrasesInSection[s] = new Set());
    const caseChunks = text.split(/(?=^Case\s*\d+)/m).filter(Boolean);

    caseChunks.forEach((chunk) => {
        const m = chunk.match(/Attending Report:\s*([\s\S]*?)(?=Resident Report:|Case\s*\d+|$)/i);
        if (!m || !m[1] || m[1].trim().length === 0) return;
        const attendingBlock = m[1].trim();
        const tempSectionTexts = {};
        SECTIONS.forEach(s => tempSectionTexts[s] = "");
        let currentCanonicalSectionKey = null;
        const lines = attendingBlock.split(/\r?\n/);

        lines.forEach((line) => {
            const trimmedLine = line.trim();
            if (!trimmedLine) return;
            const headerMatch = trimmedLine.match(/^([A-Z0-9 \-\/]+):\s*(.*)/);
            if (headerMatch) {
                const potentialHeader = headerMatch[1].trim().toUpperCase();
                const restOfLine = headerMatch[2].trim();
                if (SECTION_MAP.hasOwnProperty(potentialHeader)) {
                    const mappedSection = SECTION_MAP[potentialHeader];
                    if (mappedSection !== null) { // Check if not explicitly ignored
                        currentCanonicalSectionKey = mappedSection;
                        if (restOfLine) {
                            tempSectionTexts[currentCanonicalSectionKey] += restOfLine + (restOfLine.endsWith('.') ? ' ' : '. ');
                        }
                    } else { currentCanonicalSectionKey = null; } // Ignore header mapped to null
                } else { currentCanonicalSectionKey = null; } // Ignore unknown header
            } else if (currentCanonicalSectionKey) { // Only append if under a valid section
                const textToAppend = trimmedLine;
                tempSectionTexts[currentCanonicalSectionKey] += textToAppend + (textToAppend.endsWith('.') ? ' ' : '. ');
            }
        });

        SECTIONS.forEach(sec => {
            let collectedText = tempSectionTexts[sec]?.replace(/\s+/g, ' ').replace(/ \./g, '.').trim() || "";
            if (collectedText && !collectedText.endsWith('.')) collectedText += '.';
            if (collectedText) {
                if (!uniquePhrasesInSection[sec].has(collectedText)) {
                    library[sec].push(collectedText);
                    uniquePhrasesInSection[sec].add(collectedText);
                }
            }
        });
    });

    const totalPhrases = Object.values(library).reduce((sum, arr) => sum + arr.length, 0);
    console.log(`[INFO] Total unique phrases extracted: ${totalPhrases}`);
    if (totalPhrases === 0) { alert("Parsing finished, but no phrases were extracted."); }
    saveState();
    renderAllSections();
  }

  // --- SENTENCE REGEX Updated Here ---
  const sentenceSplitRegex = /\S.+?[.!?](?=\s+[A-ZÀ-ÖØ-Þ]|$)|\S.+/g;
  // Explanation:
  // \S.+?[.!?]       -> Match chars ending in punctuation (non-greedy)
  // (?=\s+[A-ZÀ-ÖØ-Þ]|$) -> Only if followed by (space + Capital OR end of string)
  // |\S.+            -> OR match any remaining non-whitespace chars (captures last "sentence" if no standard ending)
  // g                 -> Global match

  // 4) Render UI
  function renderAllSections() {
    const ui = document.getElementById('ui'); ui.innerHTML = ''; let hasContent = false;
    SECTIONS.forEach(sec => { if (renderSection(sec, ui)) { hasContent = true; } });
    if (!hasContent && ui.innerHTML === '') { ui.innerHTML = '<p style="color: grey; text-align: center; margin-top: 2rem;">Library is empty.</p>'; }
  }

  // 4b) Render Single Section - USES NEW SENTENCE REGEX
  function renderSection(sec, container) {
      const blocks = library[sec] || [];
      let det = container.querySelector(`details[data-section="${sec}"]`);
      if (blocks.length === 0) { if (det) det.remove(); return false; }
      let ul;
      if (!det) {
          det = document.createElement('details'); det.dataset.section = sec;
          const sum = document.createElement('summary'); det.appendChild(sum);
          ul = document.createElement('ul'); det.appendChild(ul);
          const currentSecIndex = SECTIONS.indexOf(sec); let insertBeforeElement = null;
          for (let i = currentSecIndex + 1; i < SECTIONS.length; i++) { const nextSec = SECTIONS[i]; const nextDet = container.querySelector(`details[data-section="${nextSec}"]`); if (nextDet) { insertBeforeElement = nextDet; break; } }
          if (insertBeforeElement) container.insertBefore(det, insertBeforeElement); else container.appendChild(det);
      } else { ul = det.querySelector('ul'); ul.innerHTML = ''; }
      det.querySelector('summary').textContent = `${sec} (${blocks.length})`;
      blocks.forEach((blk, i) => {
        const li = document.createElement('li'); li.dataset.sec = sec; li.dataset.idx = i;
        // *** USE UPDATED REGEX HERE ***
        const sents = blk.match(sentenceSplitRegex)?.map(s => s.trim()).filter(Boolean) || [blk];
        let currentHtml = '';
        sents.forEach((s, si) => {
          currentHtml += `<span class="sentence-span">${s}</span>`;
          if (si < sents.length - 1) currentHtml += `<span class="split-handle" title="Split" data-sec="${sec}" data-idx="${i}" data-sent-idx="${si}">➕</span>`;
        });
        if (i < blocks.length - 1) currentHtml += `<span class="merge-handle" title="Merge" data-sec="${sec}" data-idx="${i}">⇆</span>`;
        li.innerHTML = currentHtml;
        ul.appendChild(li);
      });
      return true;
  }

  // 5) Split & Merge Logic - USES NEW SENTENCE REGEX
  document.body.addEventListener('click', e => {
    const splitHandle = e.target.closest('.split-handle');
    const mergeHandle = e.target.closest('.merge-handle');
    if (splitHandle) {
      const sec = splitHandle.dataset.sec; const idx = +splitHandle.dataset.idx; const si = +splitHandle.dataset.sentIdx;
      if (!library[sec]?.[idx]) { console.error("Split Error"); return; }
      const blockToSplit = library[sec][idx];
      // *** USE UPDATED REGEX HERE ***
      const sents = blockToSplit.match(sentenceSplitRegex)?.map(s => s.trim()).filter(Boolean) || [blockToSplit];
      if (si >= 0 && si < sents.length - 1) {
        const left = sents.slice(0, si + 1).join(' ').trim(); const right = sents.slice(si + 1).join(' ').trim();
        library[sec].splice(idx, 1, left, right);
        saveState(); // Save triggers deduplication
        renderSection(sec, document.getElementById('ui'));
      } else { console.error("Invalid split index", si, sents.length); }
    } else if (mergeHandle) {
      const li = mergeHandle.closest('li'); if (!li) return;
      const sec = li.dataset.sec; const idx = +li.dataset.idx;
      if (!library[sec] || idx + 1 >= library[sec].length) { console.error("Merge Error"); return; }
      const merged = (library[sec][idx] + ' ' + library[sec][idx+1]).replace(/\s+/g, ' ').trim();
      library[sec].splice(idx, 2, merged);
      saveState(); // Save triggers deduplication
      renderSection(sec, document.getElementById('ui'));
    }
  });

  // 6) Persistence (Deduplicates before saving)
  function saveState() {
    try {
      const deduplicatedLibrary = {};
      SECTIONS.forEach(sec => {
        deduplicatedLibrary[sec] = [...new Set(library[sec] || [])];
      });
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(deduplicatedLibrary));
      // OPTIONAL: Immediately sync in-memory library
      // library = deduplicatedLibrary;
    } catch (e) { console.error("Error saving state:", e); alert("Could not save library changes."); }
  }
  function loadState() {
    const saved = localStorage.getItem(LOCAL_STORAGE_KEY); library = {}; SECTIONS.forEach(s => library[s] = []);
    if (saved) { try { const loaded = JSON.parse(saved); SECTIONS.forEach(s => { library[s] = loaded[s] || []; }); } catch(e) { console.error("Load Error:", e); resetLibrary(); } }
  }

  // --- Event Listeners ---
  document.getElementById('btn-parse').onclick = () => parseBlob(document.getElementById('blob').value);
  document.getElementById('btn-download').onclick = () => {
    if (Object.values(library).every(a=>a.length===0)) { alert("Library is empty."); return; }
    const currentDataToDownload = {}; SECTIONS.forEach(sec => { currentDataToDownload[sec] = [...new Set(library[sec] || [])]; });
    const dataStr = JSON.stringify(currentDataToDownload, null, 2); const blob = new Blob([dataStr], {type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `phraseLib-${Date.now()}.json`; a.click(); URL.revokeObjectURL(a.href);
  };
  document.getElementById('json-upload').addEventListener('change', e => {
    const file = e.target.files[0]; if (!file) return;
    file.text().then(txt => { try { const loaded = JSON.parse(txt); if(typeof loaded !== 'object' || loaded === null) throw new Error('Invalid format'); library = {}; SECTIONS.forEach(s => { library[s] = [...new Set(loaded[s] || [])]; }); saveState(); renderAllSections(); alert('Loaded!'); } catch (err) { alert(`Load error: ${err.message}`); } finally { e.target.value = null; }
    }).catch(err => { alert(`Read error: ${err.message}`); e.target.value = null; });
  });
 document.getElementById('btn-reset-cache').onclick = () => { if (confirm("Clear saved library?")) { try { localStorage.removeItem(LOCAL_STORAGE_KEY); resetLibrary(); renderAllSections(); alert("Cleared."); } catch (e) { alert("Clear error."); } } };

  // 7) Initialize
  (()=>{ loadState(); renderAllSections(); })();
  </script>
</body>
</html>
