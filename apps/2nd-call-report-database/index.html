<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Phrase Library - Sentence Mode (Unique & Merge/Unmerge)</title>
  <style>
    body { font-family: sans-serif; margin: 1rem; background: #fafafa; }
    h1 { margin-bottom: .5rem; }
    #controls { margin-bottom: 1rem; border-bottom: 1px solid #ccc; padding-bottom: 1rem;}
    textarea { width: 100%; height: 150px; font-family: monospace; box-sizing: border-box; }
    details { margin-top: 0.5rem; border-top: 1px solid #eee; padding-top: 0.5rem; }
    details summary { font-weight: 600; cursor: pointer; }
    ul { margin: .5rem 0 1rem 1.2rem; list-style-type: decimal; padding-left: 1.5em; } /* Changed list style */
    li { position: relative; margin-bottom: 0.1em; line-height: 1.4; padding-right: 3.5em; } /* Increased padding for two buttons */
    /* Removed highlight-group */
    .btn-action {
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      font-size: .9rem;
      background: white;
      border: 1px solid #ccc;
      border-radius: 3px;
      padding: 0 4px;
      line-height: 1;
      cursor: pointer;
      visibility: hidden;
      margin-left: 2px; /* Space between buttons */
    }
    .merge-handle { right: 1.8em; color: blue; } /* Position merge button */
    .unmerge-handle { right: 0; color: orange; } /* Position unmerge button */

    li:hover .btn-action { visibility: visible; }
    ul > li:last-child .merge-handle { display: none; } /* Hide merge on last item */
    /* Optionally hide unmerge if sentence doesn't look splittable (can be complex) */
    /* li:not(:has(> .splittable-marker)) .unmerge-handle { display: none; } */

    button, input[type="file"] { margin-right: .5rem; padding: .3rem .6rem; margin-top: .5rem; }
    input[type="file"] { border: 1px solid #ccc; border-radius: 3px; }
    #btn-reset-cache { background-color: #fdd; border-color: #d88; color: #800;}
    label.button-like { display: inline-block; padding: .3rem .6rem; border: 1px solid #ccc; border-radius: 3px; background-color: #eee; cursor: pointer; }
    #json-upload { display: none; } /* Hide the actual file input */
  </style>
</head>
<body>
  <h1>Phrase Library - Sentence Mode (Unique & Merge/Unmerge)</h1>
  <div id="controls">
    <label for="blob">Paste all cases here:</label><br>
    <textarea id="blob" placeholder="Case 1 Attending Report: ... Case 2 Attending Report: ..."></textarea><br>
    <button id="btn-parse">Parse Cases & Store Unique Sentences</button>
    <label for="json-upload" class="button-like">Upload JSON</label>
    <input type="file" id="json-upload" accept=".json">
    <button id="btn-download">Download JSON</button>
    <hr style="margin: 0.75rem 0; border: none; border-top: 1px dashed #ccc;">
    <button id="btn-reset-cache">Clear Saved Library</button>
  </div>

  <input
    type="text"
    id="txt-filter"
    placeholder="Filter sentences…"
    style="width:100%; box-sizing: border-box; padding: .4rem; margin-bottom:1rem;"
  >

  <div id="ui"></div>

  <script>
  // 1a) Canonical Section headers
  const SECTIONS = [
    "LOWER NECK", "LUNGS / AIRWAYS / PLEURA", "HEART / VESSELS", "MEDIASTINUM / ESOPHAGUS", "DIAPHRAGM",
    "LYMPH NODES", "CHEST WALL", "LIVER", "BILIARY TRACT", "GALLBLADDER", "PANCREAS", "SPLEEN", "ADRENALS",
    "KIDNEYS", "STOMACH / SMALL BOWEL", "COLON / APPENDIX", "PERITONEUM / MESENTERY", "RETROPERITONEUM",
    "VESSELS", "URINARY BLADDER", "REPRODUCTIVE ORGANS", "BODY WALL", "MUSCULOSKELETAL", "CONCLUSION"
  ];

  // 1b) Mapping for Variations
  const SECTION_MAP = {
    "LOWER NECK": "LOWER NECK",
    "LUNGS / AIRWAYS / PLEURA": "LUNGS / AIRWAYS / PLEURA",
    "LUNG BASES / PLEURA": "LUNGS / AIRWAYS / PLEURA",
    "HEART / VESSELS": "HEART / VESSELS",
    "MEDIASTINUM / ESOPHAGUS": "MEDIASTINUM / ESOPHAGUS",
    "DISTAL ESOPHAGUS": "MEDIASTINUM / ESOPHAGUS",
    "DIAPHRAGM": "DIAPHRAGM",
    "LYMPH NODES": "LYMPH NODES",
    "CHEST WALL": "CHEST WALL",
    "LIVER": "LIVER",
    "LIVER/BILIARY TRACT": "LIVER", // Map combined to primary for now
    "BILIARY TRACT": "BILIARY TRACT",
    "GALLBLADDER": "GALLBLADDER",
    "PANCREAS": "PANCREAS",
    "SPLEEN": "SPLEEN",
    "ADRENALS": "ADRENALS",
    "KIDNEYS": "KIDNEYS",
    "STOMACH / SMALL BOWEL": "STOMACH / SMALL BOWEL",
    "COLON / APPENDIX": "COLON / APPENDIX",
    "COLON": "COLON / APPENDIX",
    "PERITONEUM / MESENTERY": "PERITONEUM / MESENTERY",
    "PERITONEUM": "PERITONEUM / MESENTERY",
    "RETROPERITONEUM": "RETROPERITONEUM",
    "VESSELS": "VESSELS",
    "OTHER VESSELS": "VESSELS",
    "ABDOMINAL AORTA": "VESSELS",
    "CELIAC AXIS": "VESSELS",
    "SMA": "VESSELS",
    "RIGHT RENAL": "VESSELS",
    "LEFT RENAL": "VESSELS",
    "IMA": "VESSELS",
    "RIGHT ILIAC / PROXIMAL FEMORAL ARTERIES": "VESSELS",
    "LEFT ILIAC / PROXIMAL FEMORAL ARTERIES": "VESSELS",
    "LOWER ABDOMINAL AORTA": "VESSELS",
    "RIGHT COMMON / INTERNAL ILIAC ARTERIES": "VESSELS",
    "RIGHT EXTERNAL ILIAC ARTERY": "VESSELS",
    "LEFT COMMON / INTERNAL ILIAC ARTERIES": "VESSELS",
    "LEFT EXTERNAL ILIAC ARTERY": "VESSELS",
    "URINARY BLADDER": "URINARY BLADDER",
    "REPRODUCTIVE ORGANS": "REPRODUCTIVE ORGANS",
    "BODY WALL": "BODY WALL",
    "MUSCULOSKELETAL": "MUSCULOSKELETAL",
    "CONCLUSION": "CONCLUSION",
    // Ignore these
    "ABDOMEN AND PELVIS": null, "ABDOMEN": null, "PELVIS": null,
    "LOWER CHEST": null, "LOWER ABDOMEN": null, "UPPER ABDOMEN": null,
    "VASCULATURE": null, "FINDINGS": null, "STRUCTURED REPORT": null,
    "OTHER": null, "PERIANAL TISSUES": null,
    "PERIRECTAL / PERIANAL REGION": null,
    "IMAGE QUALITY": null, "OVERALL DIAGNOSTIC QUALITY": null,
    "LIVER LESIONS": "LIVER", "LIVER VASCULATURE AND COLLATERALS": null,
    "LIVER RELATED FINDINGS": null, "OTHER FINDINGS": null, "BOWEL": null
  };

  // 2) Data - Flat Array Structure per Section
  const LOCAL_STORAGE_KEY = 'phraseLibSentenceMode_v2_unique'; // New key for new structure
  let library = {};
  function resetLibrary() {
    library = {};
    SECTIONS.forEach(s => library[s] = []); // Initialize with empty arrays
  }

  // Sentence split regex - Improved slightly for potential internal splits
  const sentenceSplitRegex = /\S.+?[.!?](?=\s+[A-ZÀ-ÖØ-Þ0-9]|$)|S.+?[.!?]$|\S.+/g;
  // Regex to check if a sentence likely contains more than one sentence structure (for unmerge button)
  const potentialMultiSentenceRegex = /.+?[.!?]\s+[A-ZÀ-ÖØ-Þ0-9]/;

  // 3) Parse blob - Modified for unique sentences
  function parseBlob(text) {
    if (!text.trim()) { alert("Cannot parse empty text."); return; }
    resetLibrary(); // Start fresh but keep existing library data until overwritten
    const currentLibrary = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}');
    const uniqueSentencesInSection = {};
    SECTIONS.forEach(s => uniqueSentencesInSection[s] = new Set(currentLibrary[s] || [])); // Initialize with existing unique sentences

    const caseChunks = text.split(/(?=^Case\s*\d+)/m).filter(Boolean);
    caseChunks.forEach(chunk => {
      const m = chunk.match(/Attending Report:\s*([\s\S]*?)(?=Resident Report:|Case\s*\d+|$)/i);
      if (!m?.[1]?.trim()) return;
      const attendingBlock = m[1].trim();

      const tempSectionTexts = {};
      SECTIONS.forEach(s => tempSectionTexts[s] = "");
      let currentCanonicalSectionKey = null;

      attendingBlock.split(/\r?\n/).forEach(line => {
        const t = line.trim();
        if (!t) return;
        const headerMatch = t.match(/^([A-Z0-9 \-\/]+):\s*(.*)/);
        if (headerMatch) {
          const hdr = headerMatch[1].toUpperCase();
          const rest = headerMatch[2].trim();
          if (hdr in SECTION_MAP) {
            const mapped = SECTION_MAP[hdr];
            currentCanonicalSectionKey = mapped;
            if (mapped && rest) {
                // Add space cautiously, handle existing punctuation
                 let prefix = tempSectionTexts[mapped].length > 0 && !tempSectionTexts[mapped].endsWith(' ') ? ' ' : '';
                 // Ensure previous sentence ends correctly before adding new text
                 if (tempSectionTexts[mapped].length > 0 && !/[.!?]$/.test(tempSectionTexts[mapped].trim())) {
                    prefix = '. ' + prefix;
                 }
                 tempSectionTexts[mapped] += prefix + rest;
            }
          } else {
            currentCanonicalSectionKey = null; // Reset if header isn't mapped
          }
        } else if (currentCanonicalSectionKey) {
            // Add space cautiously, handle existing punctuation
            let prefix = tempSectionTexts[currentCanonicalSectionKey].length > 0 && !tempSectionTexts[currentCanonicalSectionKey].endsWith(' ') ? ' ' : '';
            // Ensure previous sentence ends correctly before adding new text
            if (tempSectionTexts[currentCanonicalSectionKey].length > 0 && !/[.!?]$/.test(tempSectionTexts[currentCanonicalSectionKey].trim())) {
               prefix = '. ' + prefix;
            }
          tempSectionTexts[currentCanonicalSectionKey] += prefix + t;
        }
      });

      // Process collected text for each section
      SECTIONS.forEach(sec => {
          let txt = (tempSectionTexts[sec] || "").replace(/\s+/g, ' ').replace(/ \./g, '.').trim();
          if (txt && !txt.endsWith('.') && !txt.endsWith('?') && !txt.endsWith('!')) txt += '.'; // Ensure text ends with punctuation if not empty
          if (!txt) return;

          const sentences = txt.match(sentenceSplitRegex)?.map(s => s.trim()).filter(Boolean) || [];
          sentences.forEach(sentence => {
              if (sentence) { // Ensure we don't add empty strings
                uniqueSentencesInSection[sec].add(sentence);
              }
          });
      });
    });

    // Update the main library object with unique sentences
    SECTIONS.forEach(sec => {
        library[sec] = Array.from(uniqueSentencesInSection[sec]);
        library[sec].sort(); // Optional: Sort sentences alphabetically
    });


    saveState();
    renderAllSections();
    document.getElementById('blob').value = ''; // Clear textarea after parsing
    alert(`Parsed ${caseChunks.length} case blocks. Library updated with unique sentences.`);
  }

  // 4) Render - Updated for flat structure
  function renderAllSections() {
    const ui = document.getElementById('ui');
    ui.innerHTML = '';
    let hasContent = false;
    SECTIONS.forEach(sec => {
      if (renderSection(sec, ui)) {
        hasContent = true;
      }
    });
    if (!hasContent) {
      ui.innerHTML = '<p style="color: grey; text-align: center; margin-top: 2rem;">Library is empty. Paste cases or upload JSON.</p>';
    }
     // Re-apply filter after rendering
     applyFilter();
  }

  function renderSection(sec, container) {
    const sentences = library[sec] || [];
    let det = container.querySelector(`details[data-section="${sec}"]`);

    if (sentences.length === 0) {
      det?.remove();
      return false; // No content for this section
    }

    let ul;
    let isNew = false;
    if (!det) {
      isNew = true;
      det = document.createElement('details');
      det.dataset.section = sec;
      const sum = document.createElement('summary');
      det.appendChild(sum);
      ul = document.createElement('ul');
      det.appendChild(ul);

      // Insert in correct order
      const sectionIndex = SECTIONS.indexOf(sec);
      let inserted = false;
      for (let i = sectionIndex + 1; i < SECTIONS.length; i++) {
          const nextSectionKey = SECTIONS[i];
          const nextSectionElement = container.querySelector(`details[data-section="${nextSectionKey}"]`);
          if (nextSectionElement) {
              container.insertBefore(det, nextSectionElement);
              inserted = true;
              break;
          }
      }
      if (!inserted) {
          container.appendChild(det);
      }
    } else {
      ul = det.querySelector('ul');
      ul.innerHTML = ''; // Clear previous content
    }

    det.querySelector('summary').textContent = `${sec} (${sentences.length} unique sentences)`;

    sentences.forEach((sentence, sIdx) => {
      const li = document.createElement('li');
      li.dataset.sec = sec;
      li.dataset.sentIdx = sIdx;
      li.textContent = sentence;

      // Add Merge Button (except for last item)
      if (sIdx < sentences.length - 1) {
           li.innerHTML += ` <span class="btn-action merge-handle" title="Merge with next">⇆</span>`;
      }
       // Add Unmerge Button (conditionally or always)
        const canPotentiallyUnmerge = potentialMultiSentenceRegex.test(sentence);
        // Always add unmerge button for simplicity, action handler will check if split possible
        li.innerHTML += ` <span class="btn-action unmerge-handle" title="Split this sentence">⨷</span>`;
       // Add invisible marker if potentially splittable (useful for optional CSS hiding)
        // if (canPotentiallyUnmerge) {
        //   li.innerHTML += `<span class="splittable-marker" style="display:none;"></span>`;
        // }

      ul.appendChild(li);
    });

     // Preserve open/closed state if element existed before
    // if (!isNew) {
    //     // This simple approach re-opens on any re-render. A more complex state tracking is needed
    //     // det.open = true; // Or track state externally
    // }

    return true; // Section has content
  }

  // 5) Actions (Merge/Unmerge)
  const uiContainer = document.getElementById('ui');

  uiContainer.addEventListener('click', e => {
    const target = e.target;

    // Handle Merge
    if (target.classList.contains('merge-handle')) {
      const li1 = target.closest('li');
      const li2 = li1.nextElementSibling; // Merge always happens with the next sibling
      if (!li1 || !li2 || !li1.dataset.sec || li1.dataset.sec !== li2.dataset.sec) return;

      const sec = li1.dataset.sec;
      const s1 = +li1.dataset.sentIdx; // Index of the first sentence
      const s2 = +li2.dataset.sentIdx; // Index of the second sentence (should be s1 + 1)

      if (s2 !== s1 + 1) { // Sanity check
        console.error("Merge indices are not sequential:", s1, s2);
        return;
      }

      const t1 = library[sec][s1];
      const t2 = library[sec][s2];
      const merged = (t1 + ' ' + t2).replace(/\s+/g, ' ').trim();

      // Update library: replace first sentence, remove second
      library[sec][s1] = merged;
      library[sec].splice(s2, 1);

      saveState();
      renderSection(sec, uiContainer); // Re-render only the affected section
    }

    // Handle Unmerge (Re-split)
    else if (target.classList.contains('unmerge-handle')) {
      const li = target.closest('li');
      if (!li || !li.dataset.sec) return;

      const sec = li.dataset.sec;
      const sIdx = +li.dataset.sentIdx;
      const text = library[sec][sIdx];

      // Attempt to split the sentence using the regex
      const parts = text.match(sentenceSplitRegex)?.map(s => s.trim()).filter(Boolean) || [];

      if (parts.length > 1) {
        // Replace the original sentence with the split parts
        library[sec].splice(sIdx, 1, ...parts);
        saveState();
        renderSection(sec, uiContainer); // Re-render the section
      } else {
        alert("Cannot split this sentence further based on punctuation (.!?) followed by a capital letter.");
      }
    }
  });

  // 6) Persistence
  function saveState() {
    try {
        // Clean up empty arrays before saving
        const libraryToSave = {};
        SECTIONS.forEach(sec => {
            if (library[sec] && library[sec].length > 0) {
                libraryToSave[sec] = library[sec];
            }
        });
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(libraryToSave));
    } catch (e) {
        console.error("Error saving state to localStorage:", e);
        alert("Error saving state. LocalStorage might be full or unavailable.");
    }
  }

  function loadState() {
    const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
    resetLibrary(); // Ensures all sections exist in the library object
    if (saved) {
      try {
        const loadedLibrary = JSON.parse(saved);
        // Ensure only known sections are loaded and they contain arrays
        SECTIONS.forEach(sec => {
          if (loadedLibrary[sec] && Array.isArray(loadedLibrary[sec])) {
            library[sec] = loadedLibrary[sec];
          }
        });
      } catch (e) {
          console.error("Error loading state from localStorage:", e);
          localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear corrupted data
      }
    }
  }

  // 7) Event Listeners
  document.getElementById('btn-parse').onclick = () =>
    parseBlob(document.getElementById('blob').value);

  document.getElementById('btn-download').onclick = () => {
    const sectionsWithContent = Object.keys(library).filter(sec => library[sec] && library[sec].length > 0);
    if (sectionsWithContent.length === 0) {
       alert("Library is empty. Nothing to download.");
       return;
    }
    // Create a clean object with only non-empty sections for download
    const libraryToDownload = {};
    sectionsWithContent.forEach(sec => libraryToDownload[sec] = library[sec]);

    const str = JSON.stringify(libraryToDownload, null, 2);
    const blob = new Blob([str], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    const date = new Date();
    const timestamp = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
    a.download = `phraseLibSentenceMode_${timestamp}.json`;
    document.body.appendChild(a); // Required for Firefox
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  };

  document.getElementById('json-upload').addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const loadedLibrary = JSON.parse(event.target.result);
            // Validate and merge/replace logic (simple replace for now)
            resetLibrary(); // Clear current library before loading
             SECTIONS.forEach(sec => {
               if (loadedLibrary[sec] && Array.isArray(loadedLibrary[sec])) {
                 // Basic validation: ensure items are strings
                 library[sec] = loadedLibrary[sec].filter(item => typeof item === 'string' && item.trim().length > 0);
               }
             });
            saveState();
            renderAllSections();
            alert('Library loaded successfully from JSON!');
        } catch (err) {
            alert(`Error loading or parsing JSON file: ${err.message}`);
            console.error("JSON Load Error:", err);
        } finally {
            e.target.value = ''; // Reset file input
        }
    };
    reader.onerror = (event) => {
        alert("Error reading file.");
        console.error("File Reader Error:", event);
        e.target.value = ''; // Reset file input
    };
    reader.readAsText(f);
  });

  document.getElementById('btn-reset-cache').onclick = () => {
    if (confirm("Are you sure you want to clear the entire saved library from your browser? This cannot be undone.")) {
      localStorage.removeItem(LOCAL_STORAGE_KEY);
      resetLibrary();
      renderAllSections();
      alert("Saved library cleared.");
    }
  };

  // 8) Live search filter
  const filterInput = document.getElementById('txt-filter');
  filterInput.addEventListener('input', applyFilter);

  function applyFilter() {
      const term = filterInput.value.trim().toLowerCase();
      let anyVisibleSections = false;
      document.querySelectorAll('#ui details').forEach(det => {
          let sectionHasVisibleItems = false;
          det.querySelectorAll('li').forEach(li => {
              const sentenceText = li.textContent.toLowerCase();
              // Remove button text from comparison if necessary, though usually not needed
              // const sentenceOnlyText = li.firstChild.textContent.toLowerCase();
              const isVisible = !term || sentenceText.includes(term);
              li.style.display = isVisible ? '' : 'none';
              if (isVisible) {
                  sectionHasVisibleItems = true;
              }
          });

          det.style.display = sectionHasVisibleItems ? '' : 'none';
          // Optionally open sections with matches, close others
          if (sectionHasVisibleItems && term) {
              det.open = true;
          } else if (!sectionHasVisibleItems && term) {
             det.open = false; // Close if no matches in this section
          } else if (!term) {
             // Decide behaviour when filter is cleared (e.g., close all or keep state)
             // det.open = false; // Close all when filter is empty
          }

          if (sectionHasVisibleItems) {
            anyVisibleSections = true;
          }
      });

       // Optional: Show a message if filter returns no results
       const noResultsMessage = document.getElementById('no-filter-results');
       if (!anyVisibleSections && term && !noResultsMessage) {
           const p = document.createElement('p');
           p.id = 'no-filter-results';
           p.textContent = 'No sentences match your filter.';
           p.style.textAlign = 'center';
           p.style.color = 'grey';
           uiContainer.appendChild(p);
       } else if (anyVisibleSections && noResultsMessage) {
           noResultsMessage.remove();
       } else if (!term && noResultsMessage) {
            noResultsMessage.remove(); // Remove message when filter is cleared
       }
  }


  // 9) Initialize
  (()=>{
    loadState();
    renderAllSections();
  })();
  </script>
</body>
</html>