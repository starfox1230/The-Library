<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Phrase Library - Sentence Mode</title>
  <style>
    body { font-family: sans-serif; margin: 1rem; background: #fafafa; }
    h1 { margin-bottom: .5rem; }
    #controls { margin-bottom: 1rem; border-bottom: 1px solid #ccc; padding-bottom: 1rem;}
    textarea { width: 100%; height: 150px; font-family: monospace; box-sizing: border-box; }
    details { margin-top: 0.5rem; border-top: 1px solid #eee; padding-top: 0.5rem; }
    details summary { font-weight: 600; cursor: pointer; }
    ul { margin: .5rem 0 1rem 1.2rem; list-style-type: disc; padding-left: 1.5em; }
    li { position: relative; margin-bottom: 0.1em; line-height: 1.4; padding-right: 1.5em; }
    li.highlight-group { background-color: #e0f0ff; }
    .merge-handle {
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      font-size: .9rem;
      background: white;
      border: 1px solid #ccc;
      border-radius: 3px;
      padding: 0 4px;
      line-height: 1;
      cursor: pointer;
      visibility: hidden;
      color: blue;
    }
    li:hover .merge-handle { visibility: visible; }
    ul > li:last-child .merge-handle { display: none; }

    button, input[type="file"] { margin-right: .5rem; padding: .3rem .6rem; margin-top: .5rem; }
    input[type="file"] { border: 1px solid #ccc; border-radius: 3px; }
    #btn-reset-cache { background-color: #fdd; border-color: #d88; color: #800;}
  </style>
</head>
<body>
  <h1>Phrase Library - Sentence Mode</h1>
  <div id="controls">
    <label for="blob">Paste all cases here:</label><br>
    <textarea id="blob" placeholder="Case 1 Attending Report: ... Case 2 Attending Report: ..."></textarea><br>
    <button id="btn-parse">Parse Cases & Split Sentences</button>
    <label for="json-upload" class="button-like">Upload JSON</label>
    <input type="file" id="json-upload" accept=".json">
    <button id="btn-download">Download JSON</button>
    <hr style="margin: 0.75rem 0; border: none; border-top: 1px dashed #ccc;">
    <button id="btn-reset-cache">Clear Saved Library</button>
  </div>

  <!--  FILTER INPUT ADDED HERE  -->
  <input
    type="text"
    id="txt-filter"
    placeholder="Filter sentences…"
    style="width:100%; margin-bottom:1rem;"
  >

  <div id="ui"></div>

  <script>
  // 1a) Canonical Section headers
  const SECTIONS = [
    "LOWER NECK", "LUNGS / AIRWAYS / PLEURA", "HEART / VESSELS", "MEDIASTINUM / ESOPHAGUS", "DIAPHRAGM",
    "LYMPH NODES", "CHEST WALL", "LIVER", "BILIARY TRACT", "GALLBLADDER", "PANCREAS", "SPLEEN", "ADRENALS",
    "KIDNEYS", "STOMACH / SMALL BOWEL", "COLON / APPENDIX", "PERITONEUM / MESENTERY", "RETROPERITONEUM",
    "VESSELS", "URINARY BLADDER", "REPRODUCTIVE ORGANS", "BODY WALL", "MUSCULOSKELETAL", "CONCLUSION"
  ];

  // 1b) Mapping for Variations
  const SECTION_MAP = {
    "LOWER NECK": "LOWER NECK",
    "LUNGS / AIRWAYS / PLEURA": "LUNGS / AIRWAYS / PLEURA",
    "LUNG BASES / PLEURA": "LUNGS / AIRWAYS / PLEURA",
    "HEART / VESSELS": "HEART / VESSELS",
    "MEDIASTINUM / ESOPHAGUS": "MEDIASTINUM / ESOPHAGUS",
    "DISTAL ESOPHAGUS": "MEDIASTINUM / ESOPHAGUS",
    "DIAPHRAGM": "DIAPHRAGM",
    "LYMPH NODES": "LYMPH NODES",
    "CHEST WALL": "CHEST WALL",
    "LIVER": "LIVER",
    "LIVER/BILIARY TRACT": "LIVER",
    "BILIARY TRACT": "BILIARY TRACT",
    "GALLBLADDER": "GALLBLADDER",
    "PANCREAS": "PANCREAS",
    "SPLEEN": "SPLEEN",
    "ADRENALS": "ADRENALS",
    "KIDNEYS": "KIDNEYS",
    "STOMACH / SMALL BOWEL": "STOMACH / SMALL BOWEL",
    "COLON / APPENDIX": "COLON / APPENDIX",
    "COLON": "COLON / APPENDIX",
    "PERITONEUM / MESENTERY": "PERITONEUM / MESENTERY",
    "PERITONEUM": "PERITONEUM / MESENTERY",
    "RETROPERITONEUM": "RETROPERITONEUM",
    "VESSELS": "VESSELS",
    "OTHER VESSELS": "VESSELS",
    "ABDOMINAL AORTA": "VESSELS",
    "CELIAC AXIS": "VESSELS",
    "SMA": "VESSELS",
    "RIGHT RENAL": "VESSELS",
    "LEFT RENAL": "VESSELS",
    "IMA": "VESSELS",
    "RIGHT ILIAC / PROXIMAL FEMORAL ARTERIES": "VESSELS",
    "LEFT ILIAC / PROXIMAL FEMORAL ARTERIES": "VESSELS",
    "LOWER ABDOMINAL AORTA": "VESSELS",
    "RIGHT COMMON / INTERNAL ILIAC ARTERIES": "VESSELS",
    "RIGHT EXTERNAL ILIAC ARTERY": "VESSELS",
    "LEFT COMMON / INTERNAL ILIAC ARTERIES": "VESSELS",
    "LEFT EXTERNAL ILIAC ARTERY": "VESSELS",
    "URINARY BLADDER": "URINARY BLADDER",
    "REPRODUCTIVE ORGANS": "REPRODUCTIVE ORGANS",
    "BODY WALL": "BODY WALL",
    "MUSCULOSKELETAL": "MUSCULOSKELETAL",
    "CONCLUSION": "CONCLUSION",
    // Ignore these
    "ABDOMEN AND PELVIS": null, "ABDOMEN": null, "PELVIS": null,
    "LOWER CHEST": null, "LOWER ABDOMEN": null, "UPPER ABDOMEN": null,
    "VASCULATURE": null, "FINDINGS": null, "STRUCTURED REPORT": null,
    "OTHER": null, "PERIANAL TISSUES": null,
    "PERIRECTAL / PERIANAL REGION": null,
    "IMAGE QUALITY": null, "OVERALL DIAGNOSTIC QUALITY": null,
    "LIVER LESIONS": "LIVER", "LIVER VASCULATURE AND COLLATERALS": null,
    "LIVER RELATED FINDINGS": null, "OTHER FINDINGS": null, "BOWEL": null
  };

  // 2) Data - Nested Array Structure
  const LOCAL_STORAGE_KEY = 'phraseLibSentenceMode';
  let library = {};
  function resetLibrary() {
    library = {};
    SECTIONS.forEach(s => library[s] = []);
  }

  // Sentence split regex
  const sentenceSplitRegex = /\S.+?[.!?](?=\s+[A-ZÀ-ÖØ-Þ]|$)|\S.+/g;

  // 3) Parse blob
  function parseBlob(text) {
    if (!text.trim()) { alert("Cannot parse empty text."); return; }
    resetLibrary();
    const uniqueBlocksInSection = {};
    SECTIONS.forEach(s => uniqueBlocksInSection[s] = new Set());

    const caseChunks = text.split(/(?=^Case\s*\d+)/m).filter(Boolean);
    caseChunks.forEach(chunk => {
      const m = chunk.match(/Attending Report:\s*([\s\S]*?)(?=Resident Report:|Case\s*\d+|$)/i);
      if (!m?.[1]?.trim()) return;
      const attendingBlock = m[1].trim();

      const tempSectionTexts = {};
      SECTIONS.forEach(s => tempSectionTexts[s] = "");
      let currentCanonicalSectionKey = null;

      attendingBlock.split(/\r?\n/).forEach(line => {
        const t = line.trim();
        if (!t) return;
        const headerMatch = t.match(/^([A-Z0-9 \-\/]+):\s*(.*)/);
        if (headerMatch) {
          const hdr = headerMatch[1].toUpperCase();
          const rest = headerMatch[2].trim();
          if (hdr in SECTION_MAP) {
            const mapped = SECTION_MAP[hdr];
            currentCanonicalSectionKey = mapped;
            if (mapped && rest) {
              tempSectionTexts[mapped] += rest + (rest.endsWith('.') ? ' ' : '. ');
            }
          } else {
            currentCanonicalSectionKey = null;
          }
        } else if (currentCanonicalSectionKey) {
          tempSectionTexts[currentCanonicalSectionKey] += t + (t.endsWith('.') ? ' ' : '. ');
        }
      });

      SECTIONS.forEach(sec => {
        let txt = (tempSectionTexts[sec] || "").replace(/\s+/g, ' ').replace(/ \./g, '.').trim();
        if (txt && !txt.endsWith('.')) txt += '.';
        if (!txt) return;
        const sentences = txt.match(sentenceSplitRegex)?.map(s => s.trim()).filter(Boolean) || [];
        if (!sentences.length) return;
        const key = JSON.stringify(sentences);
        if (!uniqueBlocksInSection[sec].has(key)) {
          uniqueBlocksInSection[sec].add(key);
          library[sec].push(sentences);
        }
      });
    });

    saveState();
    renderAllSections();
  }

  // 4) Render
  function renderAllSections() {
    const ui = document.getElementById('ui');
    ui.innerHTML = '';
    let has = false;
    SECTIONS.forEach(sec => { if (renderSection(sec, ui)) has = true; });
    if (!has) {
      ui.innerHTML = '<p style="color: grey; text-align: center; margin-top: 2rem;">Library is empty.</p>';
    }
  }

  function renderSection(sec, container) {
    const blocks = library[sec] || [];
    const totalSentences = blocks.reduce((c, b) => c + b.length, 0);
    let det = container.querySelector(`details[data-section="${sec}"]`);
    if (totalSentences === 0) {
      det?.remove();
      return false;
    }

    let ul;
    if (!det) {
      det = document.createElement('details');
      det.dataset.section = sec;
      const sum = document.createElement('summary');
      det.appendChild(sum);
      ul = document.createElement('ul');
      det.appendChild(ul);

      // Insert in correct order
      const idx = SECTIONS.indexOf(sec);
      let before = null;
      for (let i = idx + 1; i < SECTIONS.length; i++) {
        const nxt = container.querySelector(`details[data-section="${SECTIONS[i]}"]`);
        if (nxt) { before = nxt; break; }
      }
      if (before) container.insertBefore(det, before);
      else container.appendChild(det);
    } else {
      ul = det.querySelector('ul');
      ul.innerHTML = '';
    }

    det.querySelector('summary').textContent = `${sec} (${totalSentences} sentences / ${blocks.length} original blocks)`;

    blocks.forEach((block, bIdx) => {
      block.forEach((sentence, sIdx) => {
        const li = document.createElement('li');
        li.dataset.sec = sec;
        li.dataset.blockIdx = bIdx;
        li.dataset.sentIdx = sIdx;
        li.textContent = sentence;
        li.innerHTML += `<span class="merge-handle" title="Merge with next">⇆</span>`;
        ul.appendChild(li);
      });
    });

    return true;
  }

  // 5a) Highlight
  const uiContainer = document.getElementById('ui');
  uiContainer.addEventListener('mouseover', e => {
    const li = e.target.closest('li');
    if (!li?.dataset.sec) return;
    const sec = li.dataset.sec;
    const b = li.dataset.blockIdx;
    uiContainer.querySelectorAll(`li[data-sec="${sec}"][data-block-idx="${b}"]`)
      .forEach(x => x.classList.add('highlight-group'));
  });
  uiContainer.addEventListener('mouseout', e => {
    const li = e.target.closest('li');
    if (!li?.dataset.sec) return;
    const sec = li.dataset.sec;
    const b = li.dataset.blockIdx;
    uiContainer.querySelectorAll(`li[data-sec="${sec}"][data-block-idx="${b}"]`)
      .forEach(x => x.classList.remove('highlight-group'));
  });

  // 5b) Merge
  uiContainer.addEventListener('click', e => {
    const handle = e.target.closest('.merge-handle');
    if (!handle) return;
    const li1 = handle.closest('li');
    const li2 = li1.nextElementSibling;
    if (!li1 || !li2 || li1.dataset.sec !== li2.dataset.sec) return;
    const sec = li1.dataset.sec;
    const b1 = +li1.dataset.blockIdx, s1 = +li1.dataset.sentIdx;
    const b2 = +li2.dataset.blockIdx, s2 = +li2.dataset.sentIdx;
    const t1 = library[sec][b1][s1];
    const t2 = library[sec][b2][s2];
    library[sec][b1][s1] = (t1 + ' ' + t2).replace(/\s+/g, ' ').trim();
    library[sec][b2].splice(s2, 1);
    if (library[sec][b2].length === 0) library[sec].splice(b2, 1);
    saveState();
    renderSection(sec, uiContainer);
  });

  // 6) Persistence
  function saveState() {
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(library));
  }
  function loadState() {
    const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
    resetLibrary();
    if (saved) {
      try {
        const obj = JSON.parse(saved);
        SECTIONS.forEach(s => { library[s] = obj[s] || []; });
      } catch {}
    }
  }

  // 7) Event Listeners
  document.getElementById('btn-parse').onclick = () =>
    parseBlob(document.getElementById('blob').value);

  document.getElementById('btn-download').onclick = () => {
    const empty = Object.values(library).every(a => a.length === 0);
    if (empty) { alert("Library is empty."); return; }
    const str = JSON.stringify(library, null, 2);
    const blob = new Blob([str], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `phraseLibSentenceMode-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
  };

  document.getElementById('json-upload').addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    f.text().then(txt => {
      try {
        const obj = JSON.parse(txt);
        resetLibrary();
        SECTIONS.forEach(s => { library[s] = obj[s] || []; });
        saveState();
        renderAllSections();
        alert('Loaded!');
      } catch (err) {
        alert(`Load error: ${err.message}`);
      } finally {
        e.target.value = '';
      }
    });
  });

  document.getElementById('btn-reset-cache').onclick = () => {
    if (!confirm("Clear saved library?")) return;
    localStorage.removeItem(LOCAL_STORAGE_KEY);
    resetLibrary();
    renderAllSections();
    alert("Cleared.");
  };

  // 8) Live search filter
  const filterInput = document.getElementById('txt-filter');
  filterInput.addEventListener('input', () => {
    const term = filterInput.value.trim().toLowerCase();
    document.querySelectorAll('details').forEach(det => {
      let any = false;
      det.querySelectorAll('li').forEach(li => {
        const ok = !term || li.textContent.toLowerCase().includes(term);
        li.style.display = ok ? '' : 'none';
        if (ok) any = true;
      });
      det.style.display = any ? '' : 'none';
      det.open = any;
    });
  });

  // 9) Initialize
  (()=>{
    loadState();
    renderAllSections();
  })();
  </script>
</body>
</html>