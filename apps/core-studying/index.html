<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Textbook Copier</title>
  <style>
    :root {
      --bg: #121212;
      --card-bg: #1e1e1e;
      --text: #e0e0e0;
      --accent: #bb86fc;
      --input-bg: #272727;
      --input-border: #333;
      --radius: 8px;
      --spacing: 16px;
      --font: 16px;
    }
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0; padding: 0;
      background: var(--bg);
      color: var(--text);
      font: var(--font)/1.5 system-ui, sans-serif;
      height: 100vh;
      display: flex; align-items: center; justify-content: center;
    }
    .container {
      display: flex; flex-direction: column;
      padding: var(--spacing);
      max-width: 800px; width: 100%; height: 100%;
    }
    .form-group {
      display: flex; flex-wrap: wrap;
      gap: var(--spacing);
      margin-bottom: var(--spacing);
    }
    .form-group > div {
      flex: 1 1 20%; min-width: 120px;
    }
    label {
      display: block; margin-bottom: 4px; font-weight: 500;
    }
    select {
      width: 100%; padding: 8px;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: var(--radius);
      font-size: 1rem;
    }
    .actions {
      display: flex; gap: 8px;
      margin-bottom: var(--spacing);
    }
    .actions button {
      flex: 1; padding: 12px;
      font-size: 1rem; font-weight: 500;
      color: var(--bg); background: var(--accent);
      border: none; border-radius: var(--radius);
      cursor: pointer;
    }
    .actions button:disabled {
      opacity: 0.4; cursor: not-allowed;
    }
    #text-content {
      flex: 1; width: 100%;
      padding: var(--spacing);
      background: var(--card-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: var(--radius);
      resize: none; overflow-y: auto;
      font-size: 0.9rem; line-height: 1.4;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Textbook Copier</h1>

    <div class="form-group">
      <div>
        <label for="book">Book</label>
        <select id="book"><option value="">-- Select Book --</option></select>
      </div>
      <div>
        <label for="chapter">Chapter</label>
        <select id="chapter" disabled><option value="">--</option></select>
      </div>
      <div>
        <label for="start-section">Start Section</label>
        <select id="start-section" disabled><option value="">--</option></select>
      </div>
      <div>
        <label for="end-section">End Section (optional)</label>
        <select id="end-section" disabled><option value="">--</option></select>
      </div>
    </div>

    <div class="actions">
      <button id="fetch-btn" disabled>Fetch Text</button>
      <button id="copy-btn" disabled>Copy to Clipboard</button>
    </div>

    <textarea id="text-content" readonly placeholder="Your selection will appear here…"></textarea>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const encodePath = p => p.split('/').map(encodeURIComponent).join('/');
  const setCookie = (name, value, days = 365) => {
    const d = new Date();
    d.setTime(d.getTime() + days * 24 * 60 * 60 * 1000);
    const expires = "; expires=" + d.toUTCString();
    document.cookie = `${name}=${value || ""}${expires}; path=/; SameSite=Lax`;
  };
  const getCookie = name => {
    const nameEQ = name + "=";
    return document.cookie.split(';').map(c => c.trim()).find(c => c.startsWith(nameEQ))?.substring(nameEQ.length) || null;
  };

  let booksData, currentBookManifest, currentBookPath;
  let currentSections = [];

  const bookEl = document.getElementById('book');
  const chapterEl = document.getElementById('chapter');
  const startEl = document.getElementById('start-section');
  const endEl = document.getElementById('end-section');
  const fetchBtn = document.getElementById('fetch-btn');
  const copyBtn = document.getElementById('copy-btn');
  const outTA = document.getElementById('text-content');

  const natCompare = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
  const compareSectionKeys = (a, b) => {
    const toNums = k => k.split('.').map(x => parseInt(x, 10)).filter(Number.isFinite);
    const A = toNums(a), B = toNums(b), n = Math.max(A.length, B.length);
    for (let i = 0; i < n; i++) {
      const da = A[i] || 0, db = B[i] || 0;
      if (da !== db) return da - db;
    }
    return natCompare(a, b);
  };

  const resetDropdowns = (from) => {
    const order = ['book', 'chapter', 'start'];
    const idx = order.indexOf(from);
    const targets = [chapterEl, startEl, endEl];
    for (let i = idx; i < targets.length; i++) {
      targets[i].innerHTML = '<option value="">--</option>';
      targets[i].disabled = true;
    }
    fetchBtn.disabled = true;
    copyBtn.disabled = true;
    outTA.value = '';
  };

  // --- Data Loading and UI Population Functions ---

  async function updateChapters() {
    resetDropdowns('book');
    const bookValue = bookEl.value;
    if (!bookValue) return;

    const info = booksData[bookValue];
    currentBookPath = info.basePath;
    try {
      const manifest = await fetch(encodePath(info.manifest)).then(r => r.json());
      currentBookManifest = manifest;
      Object.entries(manifest)
        .sort(([ka], [kb]) => natCompare(ka, kb))
        .forEach(([key, ch]) => {
          const o = document.createElement('option');
          o.value = key;
          const num = (key.match(/\d+/) || [])[0];
          const labelLeft = num ? `Chapter ${num}` : key;
          o.textContent = `${labelLeft} – ${ch.title || ''}`.replace(/ – $/, '');
          chapterEl.appendChild(o);
        });
      chapterEl.disabled = chapterEl.options.length <= 1;
    } catch (err) {
      alert('Error loading manifest: ' + err);
    }
  }

  function updateSections() {
    resetDropdowns('chapter');
    const chapterValue = chapterEl.value;
    if (!chapterValue) return;

    const ch = currentBookManifest[chapterValue];
    const intro = ch.introFile ? [['00', { title: ch.introTitle || 'Chapter intro', file: ch.introFile }]] : [];
    const source = ch.sections || ch;
    const entries = Object.entries(source)
      .filter(([k, v]) => !['title', 'introFile', 'introTitle', 'sections'].includes(k) && v && typeof v === 'object' && v.file)
      .sort(([a], [b]) => compareSectionKeys(a, b));
    currentSections = [...intro, ...entries];

    currentSections.forEach(([secKey, sec]) => {
      const o = document.createElement('option');
      o.value = secKey;
      o.textContent = `${secKey} – ${sec.title || ''}`.replace(/ – $/, '');
      startEl.appendChild(o);
    });
    startEl.disabled = currentSections.length === 0;
  }

  function updateEndSections() {
    resetDropdowns('start');
    const startValue = startEl.value;
    if (!startValue) return;

    const idx = currentSections.findIndex(([k]) => k === startValue);
    for (let i = idx; i < currentSections.length; i++) {
      const [secKey, sec] = currentSections[i];
      const o = document.createElement('option');
      o.value = secKey;
      o.textContent = `${secKey} – ${sec.title || ''}`.replace(/ – $/, '');
      endEl.appendChild(o);
    }
    endEl.disabled = false;
    fetchBtn.disabled = false;
  }

  // --- Event Listeners for User Interaction ---

  bookEl.addEventListener('change', () => {
    setCookie('selectedBook', bookEl.value);
    setCookie('selectedChapter', '', -1);
    setCookie('selectedStart', '', -1);
    setCookie('selectedEnd', '', -1);
    updateChapters();
  });

  chapterEl.addEventListener('change', () => {
    setCookie('selectedChapter', chapterEl.value);
    setCookie('selectedStart', '', -1);
    setCookie('selectedEnd', '', -1);
    updateSections();
  });

  startEl.addEventListener('change', () => {
    setCookie('selectedStart', startEl.value);
    setCookie('selectedEnd', '', -1);
    updateEndSections();
  });

  endEl.addEventListener('change', () => {
    setCookie('selectedEnd', endEl.value);
  });
  
  // --- Initial Page Load and State Restoration ---

  (async () => {
    try {
      const data = await fetch('books.json').then(r => r.json());
      booksData = data;
      Object.keys(booksData).forEach(name => {
        const o = document.createElement('option');
        o.value = name; o.textContent = name;
        bookEl.appendChild(o);
      });

      // ** SEQUENTIAL STATE RESTORATION **
      const savedBook = getCookie('selectedBook');
      if (savedBook && bookEl.querySelector(`option[value="${savedBook}"]`)) {
        bookEl.value = savedBook;
        await updateChapters(); // Wait for chapters to load

        const savedChapter = getCookie('selectedChapter');
        if (savedChapter && chapterEl.querySelector(`option[value="${savedChapter}"]`)) {
          chapterEl.value = savedChapter;
          updateSections(); // This can be sync

          const savedStart = getCookie('selectedStart');
          if (savedStart && startEl.querySelector(`option[value="${savedStart}"]`)) {
            startEl.value = savedStart;
            updateEndSections(); // This can be sync

            const savedEnd = getCookie('selectedEnd');
            if (savedEnd && endEl.querySelector(`option[value="${savedEnd}"]`)) {
              endEl.value = savedEnd;
            }
          }
        }
      }
    } catch (err) {
      alert('Error loading books.json: ' + err);
    }
  })();
  
  // --- Action Buttons ---

  fetchBtn.addEventListener('click', async () => {
    const startKey = startEl.value;
    const endKey = endEl.value || startKey;
    const keys = currentSections.map(([k]) => k);
    const slice = keys.slice(keys.indexOf(startKey), keys.indexOf(endKey) + 1);

    outTA.value = 'Loading…';
    try {
      const texts = await Promise.all(slice.map(k => {
        const [, secObj] = currentSections.find(([key]) => key === k);
        const url = encodePath(`${currentBookPath}/${secObj.file}`);
        return fetch(url).then(r => {
          if (!r.ok) throw new Error(`${r.status} ${r.statusText} while fetching ${secObj.file}`);
          return r.text();
        });
      }));
      outTA.value = texts.join('\n\n');
      copyBtn.disabled = false;
    } catch (e) {
      outTA.value = 'Error: ' + e.message;
      copyBtn.disabled = true;
    }
  });

  copyBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(outTA.value)
      .then(() => alert('Copied!'))
      .catch(e => alert('Copy failed: ' + e));
  });
});
</script>

</body>
</html>
