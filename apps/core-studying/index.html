<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Textbook Copier</title>
  <style>
    :root {
      --bg: #121212;
      --card-bg: #1e1e1e;
      --text: #e0e0e0;
      --accent: #bb86fc;
      --input-bg: #272727;
      --input-border: #333;
      --radius: 8px;
      --spacing: 16px;
      --font: 16px;
    }
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0; padding: 0;
      background: var(--bg);
      color: var(--text);
      font: var(--font)/1.5 system-ui, sans-serif;
      height: 100vh;
      display: flex; align-items: center; justify-content: center;
    }
    .container {
      display: flex; flex-direction: column;
      padding: var(--spacing);
      max-width: 800px; width: 100%; height: 100%;
    }
    .form-group {
      display: flex; flex-wrap: wrap;
      gap: var(--spacing);
      margin-bottom: var(--spacing);
    }
    .form-group > div {
      flex: 1 1 20%; min-width: 120px;
    }
    label {
      display: block; margin-bottom: 4px; font-weight: 500;
    }
    select {
      width: 100%; padding: 8px;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: var(--radius);
      font-size: 1rem;
    }
    .actions {
      display: flex; gap: 8px;
      margin-bottom: var(--spacing);
    }
    .actions button {
      flex: 1; padding: 12px;
      font-size: 1rem; font-weight: 500;
      color: var(--bg); background: var(--accent);
      border: none; border-radius: var(--radius);
      cursor: pointer;
    }
    .actions button:disabled {
      opacity: 0.4; cursor: not-allowed;
    }
    #text-content {
      flex: 1; width: 100%;
      padding: var(--spacing);
      background: var(--card-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: var(--radius);
      resize: none; overflow-y: auto;
      font-size: 0.9rem; line-height: 1.4;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Textbook Copier</h1>

    <div class="form-group">
      <div>
        <label for="book">Book</label>
        <select id="book"><option value="">-- Select Book --</option></select>
      </div>
      <div>
        <label for="chapter">Chapter</label>
        <select id="chapter" disabled><option value="">--</option></select>
      </div>
      <div>
        <label for="start-section">Start Section</label>
        <select id="start-section" disabled><option value="">--</option></select>
      </div>
      <div>
        <label for="end-section">End Section (optional)</label>
        <select id="end-section" disabled><option value="">--</option></select>
      </div>
    </div>

    <div class="actions">
      <button id="fetch-btn" disabled>Fetch Text</button>
      <button id="copy-btn" disabled>Copy to Clipboard</button>
    </div>

    <textarea id="text-content" readonly placeholder="Your selection will appear here…"></textarea>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- Cookie helpers ---
  const setCookie = (name, value, days = 365) => {
    let expires = "";
    if (days) {
      const d = new Date();
      d.setTime(d.getTime() + days*24*60*60*1000);
      expires = "; expires=" + d.toUTCString();
    }
    document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
  };
  const getCookie = (name) => {
    const nameEQ = name + "=";
    return document.cookie.split(';').map(c => c.trim()).find(c => c.indexOf(nameEQ) === 0)?.substring(nameEQ.length) || null;
  };

  // Restore selections
  const saved = {
    book: getCookie('selectedBook'),
    chapter: getCookie('selectedChapter'),
    start: getCookie('selectedStart'),
    end: getCookie('selectedEnd'),
  };

  let booksData, currentBookManifest, currentBookPath;
  /** @type {Array<[string, {title:string, file:string}]>} */
  let currentSections = [];

  const bookEl   = document.getElementById('book');
  const chapterEl= document.getElementById('chapter');
  const startEl  = document.getElementById('start-section');
  const endEl    = document.getElementById('end-section');
  const fetchBtn = document.getElementById('fetch-btn');
  const copyBtn  = document.getElementById('copy-btn');
  const outTA    = document.getElementById('text-content');

  const resetDropdowns = (from) => {
    const order = ['book','chapter','start'];
    const idx = order.indexOf(from);
    const targets = [chapterEl, startEl, endEl];
    for (let i = idx; i < targets.length; i++) {
      targets[i].innerHTML = '<option value="">--</option>';
      targets[i].disabled = true;
    }
    fetchBtn.disabled = true;
    copyBtn.disabled = true;
    outTA.value = '';
  };

  // Natural compare helpers
  const natCompare = (a,b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
  const compareSectionKeys = (a,b) => {
    const toNums = k => k.split('.').map(x => parseInt(x,10)).filter(Number.isFinite);
    const A = toNums(a), B = toNums(b), n = Math.max(A.length,B.length);
    for (let i=0;i<n;i++){ const da=A[i]||0, db=B[i]||0; if (da!==db) return da-db; }
    return natCompare(a,b);
  };

  // Load books.json
  fetch('books.json')
    .then(r => r.json())
    .then(data => {
      booksData = data;
      Object.keys(booksData).forEach(name => {
        const o = document.createElement('option');
        o.value = name; o.textContent = name;
        bookEl.appendChild(o);
      });
      if (saved.book && bookEl.querySelector(`option[value="${saved.book}"]`)) {
        bookEl.value = saved.book;
        bookEl.dispatchEvent(new Event('change'));
      }
    })
    .catch(err => alert('Error loading books.json: ' + err));

  // Book change
  bookEl.addEventListener('change', (ev) => {
    if (ev.isTrusted) {
      setCookie('selectedBook', bookEl.value);
      setCookie('selectedChapter','',-1);
      setCookie('selectedStart','',-1);
      setCookie('selectedEnd','',-1);
    }
    resetDropdowns('book');
    if (!bookEl.value) return;

    const info = booksData[bookEl.value];
    currentBookPath = info.basePath;

    fetch(info.manifest)
      .then(r => r.json())
      .then(manifest => {
        currentBookManifest = manifest;

        // Populate chapters with natural sorting; support arbitrary keys
        Object.entries(manifest)
          .sort(([ka],[kb]) => natCompare(ka,kb))
          .forEach(([key, ch]) => {
            const o = document.createElement('option');
            o.value = key;
            // Label: try to show "Chapter <digits>" when present, else raw key
            const num = (key.match(/\d+/)||[])[0];
            const labelLeft = num ? `Chapter ${num}` : key;
            o.textContent = `${labelLeft} – ${ch.title || ''}`.replace(/ – $/,'');
            chapterEl.appendChild(o);
          });

        chapterEl.disabled = true; // will be enabled only if at least one chapter
        if (chapterEl.options.length > 1) chapterEl.disabled = false;

        if (saved.chapter && chapterEl.querySelector(`option[value="${saved.chapter}"]`)) {
          chapterEl.value = saved.chapter;
          chapterEl.dispatchEvent(new Event('change'));
        }
      })
      .catch(err => alert('Error loading manifest: ' + err));
  });

  // Chapter change
  chapterEl.addEventListener('change', (ev) => {
    if (ev.isTrusted) {
      setCookie('selectedChapter', chapterEl.value);
      setCookie('selectedStart','',-1);
      setCookie('selectedEnd','',-1);
    }
    resetDropdowns('chapter');
    if (!chapterEl.value) return;

    const ch = currentBookManifest[chapterEl.value];

    // Build a normalized [key, {title,file}] list from either:
    // - nested "sections" style (recommended), with optional "introFile"
    // - flat style where numeric keys live alongside "title"
    const intro = ch.introFile ? [['00', { title: ch.introTitle || 'Chapter intro', file: ch.introFile }]] : [];
    const source = ch.sections ? ch.sections : ch;

    const entries = Object.entries(source)
      .filter(([k,v]) => !['title','introFile','introTitle','sections'].includes(k) && v && typeof v === 'object' && v.file)
      .sort(([a],[b]) => compareSectionKeys(a,b));

    currentSections = [...intro, ...entries];

    // Populate start dropdown
    currentSections.forEach(([secKey, sec]) => {
      const o = document.createElement('option');
      o.value = secKey;
      o.textContent = `${secKey} – ${sec.title || ''}`.replace(/ – $/,'');
      startEl.appendChild(o);
    });
    startEl.disabled = currentSections.length === 0;

    if (saved.start && startEl.querySelector(`option[value="${saved.start}"]`)) {
      startEl.value = saved.start;
      startEl.dispatchEvent(new Event('change'));
    }
  });

  // Start section change
  startEl.addEventListener('change', (ev) => {
    if (ev.isTrusted) {
      setCookie('selectedStart', startEl.value);
      setCookie('selectedEnd','',-1);
    }
    resetDropdowns('start');
    if (!startEl.value) return;

    const idx = currentSections.findIndex(([k]) => k === startEl.value);
    for (let i = idx; i < currentSections.length; i++) {
      const [secKey, sec] = currentSections[i];
      const o = document.createElement('option');
      o.value = secKey;
      o.textContent = `${secKey} – ${sec.title || ''}`.replace(/ – $/,'');
      endEl.appendChild(o);
    }
    endEl.disabled = false;
    fetchBtn.disabled = false;

    if (saved.end && endEl.querySelector(`option[value="${saved.end}"]`)) {
      endEl.value = saved.end;
    }
  });

  // End section change -> save cookie
  endEl.addEventListener('change', (ev) => {
    if (ev.isTrusted) setCookie('selectedEnd', endEl.value);
  });

  // Fetch
  fetchBtn.addEventListener('click', async () => {
    const startKey = startEl.value;
    const endKey = endEl.value || startKey;

    const keys = currentSections.map(([k]) => k);
    const slice = keys.slice(keys.indexOf(startKey), keys.indexOf(endKey) + 1);

    outTA.value = 'Loading…';
    try {
      const texts = await Promise.all(slice.map(k => {
        const [, secObj] = currentSections.find(([key]) => key === k);
        return fetch(`${currentBookPath}/${secObj.file}`).then(r => {
          if (!r.ok) throw new Error(`${r.status} ${r.statusText} while fetching ${secObj.file}`);
          return r.text();
        });
      }));
      outTA.value = texts.join('\n\n');
      copyBtn.disabled = false;
    } catch (e) {
      outTA.value = 'Error: ' + e.message;
      copyBtn.disabled = true;
    }
  });

  // Copy
  copyBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(outTA.value)
      .then(() => alert('Copied!'))
      .catch(e => alert('Copy failed: ' + e));
  });
});
</script>

</body>
</html>