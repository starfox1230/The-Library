<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Textbook Copier</title>
  <style>
    :root {
      --bg: #121212;
      --card-bg: #1e1e1e;
      --text: #e0e0e0;
      --accent: #bb86fc;
      --input-bg: #272727;
      --input-border: #333;
      --radius: 8px;
      --spacing: 16px;
      --font: 16px;
    }
    *, *::before, *::after { box-sizing: border-box; }

    /* Avoid iOS picker-closing due to layout recentering:
       - No vertical flex centering on <body>
       - Use dynamic viewport units instead of 100vh */
    body {
      margin: 0; padding: 0;
      background: var(--bg);
      color: var(--text);
      font: var(--font)/1.5 system-ui, sans-serif;
      min-height: 100svh;     /* stable against browser UI changes */
    }
    @supports (height: 100dvh) {
      body { min-height: 100dvh; }
    }

    .container {
      max-width: 800px;
      width: 100%;
      padding: var(--spacing);
      margin: 24px auto;      /* top spacing, centered horizontally only */
    }

    .form-group {
      display: flex; flex-wrap: wrap;
      gap: var(--spacing);
      margin-bottom: var(--spacing);
    }
    .form-group > div {
      flex: 1 1 20%; min-width: 120px;
    }
    label {
      display: block; margin-bottom: 4px; font-weight: 500;
    }
    select {
      width: 100%; padding: 8px;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: var(--radius);
      font-size: 1rem;
      -webkit-appearance: menulist; /* keep native, avoid custom styling quirks */
    }
    .actions {
      display: flex; gap: 8px;
      margin-bottom: var(--spacing);
    }
    .actions button {
      flex: 1; padding: 12px;
      font-size: 1rem; font-weight: 500;
      color: var(--bg); background: var(--accent);
      border: none; border-radius: var(--radius);
      cursor: pointer;
    }
    .actions button:disabled {
      opacity: 0.4; cursor: not-allowed;
    }
    #text-content {
      width: 100%;
      min-height: 40vh;       /* give breathing room without forcing full-screen */
      padding: var(--spacing);
      background: var(--card-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: var(--radius);
      resize: none; overflow-y: auto;
      font-size: 0.9rem; line-height: 1.4;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Textbook Copier</h1>

    <div class="form-group">
      <div>
        <label for="book">Book</label>
        <select id="book"><option value="">-- Select Book --</option></select>
      </div>
      <div>
        <label for="chapter">Chapter</label>
        <select id="chapter" disabled><option value="">--</option></select>
      </div>
      <div>
        <label for="start-section">Start Section</label>
        <select id="start-section" disabled><option value="">--</option></select>
      </div>
      <div>
        <label for="end-section">End Section (optional)</label>
        <select id="end-section" disabled><option value="">--</option></select>
      </div>
    </div>

    <div class="actions">
      <button id="fetch-btn" disabled>Fetch Text</button>
      <button id="copy-btn" disabled>Copy to Clipboard</button>
    </div>

    <textarea id="text-content" readonly placeholder="Your selection will appear here…"></textarea>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // ---------- Utilities ----------
  const encodePath = p => p.split('/').map(encodeURIComponent).join('/');
  const setCookie = (name, value, days = 365) => {
    const d = new Date();
    d.setTime(d.getTime() + days * 24 * 60 * 60 * 1000);
    const expires = "; expires=" + d.toUTCString();
    document.cookie = `${name}=${value || ""}${expires}; path=/; SameSite=Lax`;
  };
  const getCookie = name => {
    const nameEQ = name + "=";
    return document.cookie.split(';').map(c => c.trim()).find(c => c.startsWith(nameEQ))?.substring(nameEQ.length) || null;
  };
  const natCompare = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
  const compareSectionKeys = (a, b) => {
    const toNums = k => k.split('.').map(x => parseInt(x, 10)).filter(Number.isFinite);
    const A = toNums(a), B = toNums(b), n = Math.max(A.length, B.length);
    for (let i = 0; i < n; i++) {
      const da = A[i] || 0, db = B[i] || 0;
      if (da !== db) return da - db;
    }
    return natCompare(a, b);
  };

  // iOS detection (includes iPads in desktop mode)
  const isIOS = () =>
    /iPad|iPhone|iPod/.test(navigator.userAgent) ||
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

  // Two-frame yield (lets WebKit finish opening/closing pickers)
  const nextFrame = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

  // Safely replace options of a <select> without causing picker flakiness on iOS
  async function replaceOptions(select, items) {
    const wasFocused = (document.activeElement === select) && isIOS();
    if (wasFocused) select.blur();          // Workaround per WebKit guidance

    select.disabled = true;                 // batch: disable during rebuild
    select.options.length = 0;              // clear via options API (no innerHTML)

    for (const it of items) {
      select.add(new Option(it.text, it.value));
    }

    if (wasFocused) await nextFrame();      // let WebKit settle focus bookkeeping
    select.disabled = select.options.length <= 1;
  }

  // ---------- State ----------
  let booksData, currentBookManifest, currentBookPath;
  let currentSections = [];

  const bookEl   = document.getElementById('book');
  const chapterEl= document.getElementById('chapter');
  const startEl  = document.getElementById('start-section');
  const endEl    = document.getElementById('end-section');
  const fetchBtn = document.getElementById('fetch-btn');
  const copyBtn  = document.getElementById('copy-btn');
  const outTA    = document.getElementById('text-content');

  const resetDropdowns = (from) => {
    const order = ['book', 'chapter', 'start'];
    const idx = order.indexOf(from);
    const targets = [chapterEl, startEl, endEl];
    for (let i = idx; i < targets.length; i++) {
      const sel = targets[i];
      sel.options.length = 0;
      sel.add(new Option('--', ''));
      sel.disabled = true;
    }
    fetchBtn.disabled = true;
    copyBtn.disabled = true;
    outTA.value = '';
  };

  // ---------- Data Loading and UI Population ----------
  async function updateChapters() {
    resetDropdowns('book');

    const bookValue = bookEl.value;
    if (!bookValue) return;

    const info = booksData[bookValue];
    currentBookPath = info.basePath;

    const manifest = await fetch(encodePath(info.manifest)).then(r => r.json());
    currentBookManifest = manifest;

    const chapterItems = [{ value: '', text: '--' }].concat(
      Object.entries(manifest)
        .sort(([ka], [kb]) => natCompare(ka, kb))
        .map(([key, ch]) => {
          const num = (key.match(/\d+/) || [])[0];
          const left = num ? `Chapter ${num}` : key;
          return { value: key, text: `${left} – ${ch.title || ''}`.replace(/ – $/, '') };
        })
    );

    await replaceOptions(chapterEl, chapterItems);
  }

  function buildSectionList(chapterValue) {
    const ch = currentBookManifest[chapterValue];
    const intro = ch.introFile ? [['00', { title: ch.introTitle || 'Chapter intro', file: ch.introFile }]] : [];
    const source = ch.sections || ch;
    const entries = Object.entries(source)
      .filter(([k, v]) =>
        !['title', 'introFile', 'introTitle', 'sections'].includes(k) &&
        v && typeof v === 'object' && v.file)
      .sort(([a], [b]) => compareSectionKeys(a, b));
    return [...intro, ...entries];
  }

  async function updateSections() {
    resetDropdowns('chapter');

    const chapterValue = chapterEl.value;
    if (!chapterValue) return;

    currentSections = buildSectionList(chapterValue);

    const startItems = [{ value: '', text: '--' }].concat(
      currentSections.map(([secKey, sec]) => ({
        value: secKey,
        text: `${secKey} – ${sec.title || ''}`.replace(/ – $/, '')
      }))
    );

    await replaceOptions(startEl, startItems);
  }

  async function updateEndSections() {
    resetDropdowns('start');

    const startValue = startEl.value;
    if (!startValue) return;

    const idx = currentSections.findIndex(([k]) => k === startValue);
    const endItems = [{ value: '', text: '--' }].concat(
      currentSections.slice(idx).map(([secKey, sec]) => ({
        value: secKey,
        text: `${secKey} – ${sec.title || ''}`.replace(/ – $/, '')
      }))
    );

    await replaceOptions(endEl, endItems);
    fetchBtn.disabled = false;
  }

  // ---------- Event Listeners (tiny defers; no tap blocking) ----------
  bookEl.addEventListener('change', async () => {
    setCookie('selectedBook', bookEl.value);
    setCookie('selectedChapter', '', -1);
    setCookie('selectedStart', '', -1);
    setCookie('selectedEnd', '', -1);
    await nextFrame();            // avoid same-tick DOM churn with native picker
    await updateChapters();
  });

  chapterEl.addEventListener('change', async () => {
    setCookie('selectedChapter', chapterEl.value);
    setCookie('selectedStart', '', -1);
    setCookie('selectedEnd', '', -1);
    await nextFrame();
    await updateSections();
  });

  startEl.addEventListener('change', async () => {
    setCookie('selectedStart', startEl.value);
    setCookie('selectedEnd', '', -1);
    await nextFrame();
    await updateEndSections();
  });

  endEl.addEventListener('change', () => {
    setCookie('selectedEnd', endEl.value);
  });

  // ---------- Initial Page Load and State Restoration ----------
  (async () => {
    try {
      const data = await fetch('books.json').then(r => r.json());
      booksData = data;

      // Populate book list
      const frag = document.createDocumentFragment();
      Object.keys(booksData).forEach(name => {
        const o = document.createElement('option');
        o.value = name; o.textContent = name;
        frag.appendChild(o);
      });
      bookEl.appendChild(frag);

      // Sequential restore (no synthetic events)
      const savedBook = getCookie('selectedBook');
      if (savedBook && bookEl.querySelector(`option[value="${savedBook}"]`)) {
        bookEl.value = savedBook;
        await updateChapters();

        const savedChapter = getCookie('selectedChapter');
        if (savedChapter && chapterEl.querySelector(`option[value="${savedChapter}"]`)) {
          chapterEl.value = savedChapter;
          await updateSections();

          const savedStart = getCookie('selectedStart');
          if (savedStart && startEl.querySelector(`option[value="${savedStart}"]`)) {
            startEl.value = savedStart;
            await updateEndSections();

            const savedEnd = getCookie('selectedEnd');
            if (savedEnd && endEl.querySelector(`option[value="${savedEnd}"]`)) {
              endEl.value = savedEnd;
            }
          }
        }
      }
    } catch (err) {
      alert('Error loading books.json: ' + err);
    }
  })();

  // ---------- Actions ----------
  fetchBtn.addEventListener('click', async () => {
    const startKey = startEl.value;
    const endKey = endEl.value || startKey;
    const keys = currentSections.map(([k]) => k);
    const slice = keys.slice(keys.indexOf(startKey), keys.indexOf(endKey) + 1);

    outTA.value = 'Loading…';
    try {
      const texts = await Promise.all(slice.map(k => {
        const [, secObj] = currentSections.find(([key]) => key === k);
        const url = encodePath(`${currentBookPath}/${secObj.file}`);
        return fetch(url).then(r => {
          if (!r.ok) throw new Error(`${r.status} ${r.statusText} while fetching ${secObj.file}`);
          return r.text();
        });
      }));
      outTA.value = texts.join('\n\n');
      copyBtn.disabled = false;
    } catch (e) {
      outTA.value = 'Error: ' + e.message;
      copyBtn.disabled = true;
    }
  });

  copyBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(outTA.value)
      .then(() => alert('Copied!'))
      .catch(e => alert('Copy failed: ' + e));
  });
});
</script>

</body>
</html>
