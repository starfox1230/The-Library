<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Core Study Organizer</title>
  <style>
    :root {
      --bg: #0d1117;
      --panel: #161b22;
      --card: #1f2630;
      --border: #30363d;
      --text: #c9d1d9;
      --muted: #8b949e;
      --accent: #58a6ff;
      --accent-hover: #79c0ff;
      --accent-2: #bc8cff;
      --success: #3fb950;
      --danger: #f85149;
      --radius: 8px;
      --shadow: 0 4px 12px rgba(0,0,0,0.5);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 16px;
      display: flex;
      justify-content: center;
    }
    .page {
      width: min(1000px, 100%);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* -- Header & Plan Manager -- */
    header {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow);
    }
    header h1 { margin: 0 0 8px; font-size: 1.5rem; color: var(--accent); }
    header p { margin: 0; color: var(--muted); font-size: 0.9rem; }

    .plan-manager {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .plan-manager select { flex: 1; min-width: 200px; }

    /* -- General UI Elements -- */
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow);
    }
    h2, h3, h4 { margin-top: 0; color: var(--text); }
    
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }
    
    label { display: block; font-weight: 500; margin-bottom: 6px; font-size: 0.85rem; color: var(--muted); }
    select, input[type="date"] {
      width: 100%;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #0d1117;
      color: var(--text);
      font-size: 0.95rem;
      outline: none;
    }
    select:focus, input:focus { border-color: var(--accent); }
    select:disabled { opacity: 0.6; cursor: not-allowed; }

    button {
      border: none;
      border-radius: 6px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
      background: var(--accent);
      color: #0d1117;
    }
    button:hover:not(:disabled) { background: var(--accent-hover); transform: translateY(-1px); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    button.secondary { background: #21262d; color: var(--accent); border: 1px solid var(--border); }
    button.secondary:hover:not(:disabled) { background: #30363d; }
    
    button.danger { background: rgba(248, 81, 73, 0.1); color: var(--danger); border: 1px solid rgba(248, 81, 73, 0.4); }
    button.danger:hover:not(:disabled) { background: rgba(248, 81, 73, 0.2); }
    
    button.success { background: var(--success); color: white; }

    .actions { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 16px; }
    .msg { margin-top: 10px; font-size: 0.9rem; min-height: 1.4em; }
    .msg.error { color: var(--danger); }
    .msg.info { color: var(--accent); }

    /* -- Summary Pills -- */
    .summary-pills { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 0; }
    .pill {
      background: rgba(88,166,255,0.1);
      border: 1px solid rgba(88,166,255,0.2);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.85rem;
      color: var(--accent-hover);
    }

    /* -- Calendar Visualization -- */
    .calendar-wrapper { margin-top: 20px; }
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
      gap: 6px;
      margin-top: 10px;
    }
    .cal-day {
      aspect-ratio: 1;
      border-radius: 4px;
      background: #21262d;
      border: 1px solid var(--border);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      color: rgba(255,255,255,0.7);
      transition: transform 0.1s;
      position: relative;
    }
    .cal-day:hover { transform: scale(1.1); z-index: 2; border-color: white; }
    .cal-day.active { border: 2px solid white; }
    /* Tooltip */
    .cal-day:hover::after {
      content: attr(data-date);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: black;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.7rem;
      white-space: nowrap;
      pointer-events: none;
      z-index: 10;
      margin-bottom: 5px;
    }

    /* -- Daily View -- */
    .day-header {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border);
    }
    .day-nav { display: flex; gap: 8px; align-items: center; }
    
    .section-item {
      background: #161b22;
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 16px;
      overflow: hidden;
    }
    .section-header {
      padding: 12px;
      background: #21262d;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .section-title { font-weight: 600; font-size: 0.95rem; }
    .section-meta { font-size: 0.8rem; color: var(--muted); margin-top: 2px; }
    
    .section-check {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9rem;
      cursor: pointer;
      user-select: none;
    }
    .section-check input { width: 18px; height: 18px; accent-color: var(--success); cursor: pointer; }

    .section-content {
      padding: 12px;
      overflow-x: auto;
    }
    pre {
      margin: 0;
      white-space: pre-wrap;
      font-family: inherit;
      font-size: 0.95rem;
      line-height: 1.6;
      color: #e6edf3;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .loading-text { color: var(--accent); font-style: italic; padding: 20px; text-align: center; }

    /* Utilities */
    .hidden { display: none !important; }
    
    @media (max-width: 600px) {
      .day-header { flex-direction: column; align-items: stretch; }
      .day-nav { justify-content: space-between; }
    }
  </style>
</head>
<body>

<div class="page">
  <!-- Top Bar -->
  <header>
    <h1>Core Study Organizer</h1>
    <p>Select a book, set a date range, and get a balanced plan. <br>Text is loaded dynamically to save space.</p>
    
    <div class="plan-manager">
      <select id="saved-plans-select">
        <option value="">-- Load a saved plan --</option>
      </select>
      <button id="load-plan-btn" class="secondary">Load</button>
      <button id="delete-plan-btn" class="danger">Delete</button>
      <div style="flex:1"></div>
      <button id="download-data-btn" class="secondary" title="Backup all data">⬇ Backup JSON</button>
      <button id="upload-data-btn" class="secondary" title="Restore data">⬆ Restore JSON</button>
      <input type="file" id="upload-file" accept=".json" style="display:none">
    </div>
  </header>

  <!-- Setup Card -->
  <div class="card" id="setup-card">
    <div class="grid">
      <div>
        <label for="book-select">Book</label>
        <select id="book-select"><option value="">Loading books...</option></select>
      </div>
      <div>
        <label for="start-section">Start Section</label>
        <select id="start-section" disabled><option>--</option></select>
      </div>
      <div>
        <label for="end-section">End Section</label>
        <select id="end-section" disabled><option>--</option></select>
      </div>
      <div>
        <label for="start-date">Start Date</label>
        <input type="date" id="start-date">
      </div>
      <div>
        <label for="end-date">Target Date</label>
        <input type="date" id="end-date">
      </div>
    </div>
    <div class="actions">
      <button id="generate-btn">Generate New Plan</button>
    </div>
    <div id="setup-msg" class="msg"></div>
  </div>

  <!-- Plan View (Calendar + Day) -->
  <div id="plan-view" class="hidden">
    <!-- Summary -->
    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px;">
        <div class="summary-pills">
          <div class="pill" id="sum-book"></div>
          <div class="pill" id="sum-range"></div>
          <div class="pill" id="sum-counts"></div>
        </div>
      </div>
      
      <div class="calendar-wrapper">
        <label>Progress Tracker (Click a day to view)</label>
        <div id="calendar-grid" class="calendar-grid"></div>
      </div>
    </div>

    <!-- Day Detail -->
    <div class="card">
      <div class="day-header">
        <div class="day-nav">
          <button id="prev-day" class="secondary">◀</button>
          <select id="day-jumper" style="width: auto; min-width: 140px;"></select>
          <button id="next-day" class="secondary">▶</button>
          <button id="today-btn">Today</button>
        </div>
        <button id="copy-day-btn" class="secondary">Copy Full Day</button>
      </div>

      <div id="day-content">
        <!-- Sections will be injected here -->
      </div>
    </div>
  </div>
</div>

<script>
/**
 * Core Study Organizer Logic V3
 * Features: LocalStorage Friendly (No Text Saved), Dynamic Fetching, Calendar
 */

// --- State Management ---
const STORAGE_KEY = 'core_study_data_lite';
let appData = {
  savedPlans: {}, // Key: ID, Value: Plan Object (without text)
  lastActiveId: null
};

// Books cache
let booksData = {};
let currentBookSections = []; // Used during setup
let currentBookPath = ''; // Used during generation and viewing

// Runtime State
let currentPlan = null;
let currentDayIndex = 0;
// We use a small runtime cache so if you switch days, we don't re-fetch immediately
let runtimeTextCache = {}; 

// DOM Elements
const els = {
  savedSelect: document.getElementById('saved-plans-select'),
  loadBtn: document.getElementById('load-plan-btn'),
  delBtn: document.getElementById('delete-plan-btn'),
  dlBtn: document.getElementById('download-data-btn'),
  ulBtn: document.getElementById('upload-data-btn'),
  ulInput: document.getElementById('upload-file'),
  
  bookSelect: document.getElementById('book-select'),
  startSec: document.getElementById('start-section'),
  endSec: document.getElementById('end-section'),
  startDate: document.getElementById('start-date'),
  endDate: document.getElementById('end-date'),
  genBtn: document.getElementById('generate-btn'),
  msg: document.getElementById('setup-msg'),
  
  planView: document.getElementById('plan-view'),
  sumBook: document.getElementById('sum-book'),
  sumRange: document.getElementById('sum-range'),
  sumCounts: document.getElementById('sum-counts'),
  calGrid: document.getElementById('calendar-grid'),
  
  prevDay: document.getElementById('prev-day'),
  nextDay: document.getElementById('next-day'),
  dayJumper: document.getElementById('day-jumper'),
  todayBtn: document.getElementById('today-btn'),
  copyDayBtn: document.getElementById('copy-day-btn'),
  dayContent: document.getElementById('day-content')
};

// --- Initialization ---

async function init() {
  loadData();
  setDefaultDates();
  
  try {
    const res = await fetch('books.json');
    booksData = await res.json();
    populateBooks();
    
    // Auto-load most recent if available
    if (appData.lastActiveId && appData.savedPlans[appData.lastActiveId]) {
      // Small delay to ensure booksData is ready for path lookups
      setTimeout(() => loadPlan(appData.lastActiveId), 100);
    }
  } catch (e) {
    showMsg('Error loading books.json: ' + e.message, 'error');
  }
  
  updateSavedPlansDropdown();
}

// --- Data Persistence ---

function loadData() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (raw) {
    try {
      appData = JSON.parse(raw);
    } catch(e) { console.error("Data parse error", e); }
  }
}

function saveData() {
  // Safe to save because plan objects do not contain the text blobs
  localStorage.setItem(STORAGE_KEY, JSON.stringify(appData));
  updateSavedPlansDropdown();
}

function exportData() {
  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(appData));
  const node = document.createElement('a');
  node.setAttribute("href", dataStr);
  node.setAttribute("download", "study_plan_backup.json");
  document.body.appendChild(node);
  node.click();
  node.remove();
}

function importData(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (evt) => {
    try {
      const parsed = JSON.parse(evt.target.result);
      if (parsed.savedPlans) {
        appData = parsed;
        saveData();
        location.reload(); 
      } else {
        alert("Invalid file format.");
      }
    } catch(err) {
      alert("Error parsing JSON");
    }
  };
  reader.readAsText(file);
}

// --- Plan Manager UI ---

function updateSavedPlansDropdown() {
  els.savedSelect.innerHTML = '<option value="">-- Load a saved plan --</option>';
  const plans = Object.values(appData.savedPlans).sort((a,b) => b.created - a.created);
  
  plans.forEach(p => {
    const opt = document.createElement('option');
    opt.value = p.id;
    opt.textContent = `${p.book} (${new Date(p.startDate).toLocaleDateString()} - ${new Date(p.endDate).toLocaleDateString()})`;
    els.savedSelect.appendChild(opt);
  });
}

function loadPlanFromDropdown() {
  const id = els.savedSelect.value;
  if(id && appData.savedPlans[id]) {
    loadPlan(id);
  }
}

function deletePlan() {
  const id = els.savedSelect.value;
  if (!id) return;
  if (confirm("Are you sure you want to delete this plan?")) {
    delete appData.savedPlans[id];
    if (appData.lastActiveId === id) appData.lastActiveId = null;
    saveData();
    location.reload();
  }
}

// --- Book Loading Logic ---

function populateBooks() {
  els.bookSelect.innerHTML = '<option value="">-- Select Book --</option>';
  Object.keys(booksData).forEach(k => {
    const opt = document.createElement('option');
    opt.value = k;
    opt.textContent = k;
    els.bookSelect.appendChild(opt);
  });
}

async function handleBookChange() {
  const name = els.bookSelect.value;
  if (!name) return;
  
  const info = booksData[name];
  currentBookPath = info.basePath;
  
  try {
    const res = await fetch(info.manifest);
    const manifest = await res.json();
    currentBookSections = flattenManifest(manifest);
    populateRangeSelects();
  } catch(e) {
    showMsg("Error loading manifest", 'error');
  }
}

function flattenManifest(manifest) {
  const chapters = Object.keys(manifest).sort(natCompare);
  const flat = [];
  
  chapters.forEach(chKey => {
    const ch = manifest[chKey];
    if (ch.title && !ch.file && typeof ch === 'object') {
      const secKeys = Object.keys(ch).filter(k => k !== 'title').sort(compareSectionKeys);
      secKeys.forEach(secKey => {
        flat.push({
          chapter: ch.title,
          sectionKey: secKey,
          title: ch[secKey].title,
          file: ch[secKey].file,
          fullTitle: `${ch.title} · ${secKey} - ${ch[secKey].title}`
        });
      });
    }
  });
  return flat;
}

function populateRangeSelects() {
  els.startSec.innerHTML = '';
  els.endSec.innerHTML = '';
  els.startSec.disabled = false;
  els.endSec.disabled = false;
  
  currentBookSections.forEach((s, idx) => {
    const opt1 = new Option(s.fullTitle, idx);
    const opt2 = new Option(s.fullTitle, idx);
    els.startSec.add(opt1);
    els.endSec.add(opt2);
  });
  els.endSec.value = currentBookSections.length - 1;
}

// --- Generation Logic (The Fix for Quota Exceeded) ---

async function generatePlan() {
  const bookName = els.bookSelect.value;
  const startIdx = parseInt(els.startSec.value);
  const endIdx = parseInt(els.endSec.value);
  const sDate = new Date(els.startDate.value);
  const eDate = new Date(els.endDate.value);

  if (!bookName || isNaN(startIdx) || isNaN(endIdx) || !sDate || !eDate) {
    showMsg("Please fill all fields", 'error');
    return;
  }
  if (endIdx < startIdx) {
    showMsg("End section cannot be before start section", 'error');
    return;
  }
  if (eDate < sDate) {
    showMsg("Target date cannot be before start date", 'error');
    return;
  }

  els.genBtn.disabled = true;
  showMsg("Analyzing text lengths (this does not save text locally)...", 'info');

  try {
    const selection = currentBookSections.slice(startIdx, endIdx + 1);
    const hydratedSections = [];
    
    // 1. Fetch text TEMPORARILY to calculate length
    for (const sec of selection) {
      const url = encodePath(`${currentBookPath}/${sec.file}`);
      const r = await fetch(url);
      if(!r.ok) throw new Error(`Missing file: ${sec.file}`);
      const text = await r.text();
      hydratedSections.push({
        file: sec.file,          // Save path
        fullTitle: sec.fullTitle,// Save title
        length: text.length,     // Save length
        checked: false,          // Init state
        // WE DO NOT SAVE 'text' HERE for the plan object
      });
    }

    // 2. Algorithm: Even Distribution
    const daysCount = Math.floor((eDate - sDate) / (1000 * 60 * 60 * 24)) + 1;
    const totalChars = hydratedSections.reduce((acc, s) => acc + s.length, 0);
    const targetPerDay = totalChars / daysCount;

    const days = [];
    let secIndex = 0;

    for (let d = 0; d < daysCount; d++) {
      const dayDate = new Date(sDate);
      dayDate.setDate(sDate.getDate() + d);
      
      const dayObj = {
        date: dayDate.toISOString(),
        sections: []
      };

      let dayLoad = 0;

      while (secIndex < hydratedSections.length) {
        const sec = hydratedSections[secIndex];
        const remainingSections = hydratedSections.length - secIndex;
        const remainingDays = daysCount - d;

        // Force at least 1 section per remaining day if we run low
        if (remainingSections <= remainingDays && dayObj.sections.length > 0) {
          break; 
        }

        if (dayObj.sections.length === 0) {
          dayObj.sections.push(sec);
          dayLoad += sec.length;
          secIndex++;
        } else {
          const currentDiff = Math.abs(dayLoad - targetPerDay);
          const nextDiff = Math.abs((dayLoad + sec.length) - targetPerDay);
          
          if (nextDiff < currentDiff || (dayLoad < targetPerDay * 0.7)) {
            dayObj.sections.push(sec);
            dayLoad += sec.length;
            secIndex++;
          } else {
            break;
          }
        }
      }
      days.push(dayObj);
    }

    // Handle leftovers
    while(secIndex < hydratedSections.length) {
      days[days.length-1].sections.push(hydratedSections[secIndex++]);
    }

    // 3. Create Plan Object (Lightweight)
    const planId = Date.now().toString();
    const newPlan = {
      id: planId,
      created: Date.now(),
      book: bookName,
      range: `${selection[0].fullTitle} -> ${selection[selection.length-1].fullTitle.split('·')[1] || 'End'}`,
      startDate: els.startDate.value,
      endDate: els.endDate.value,
      totalSections: selection.length,
      days: days // These days contain file paths, but NO text
    };

    appData.savedPlans[planId] = newPlan;
    appData.lastActiveId = planId;
    saveData(); // This will succeed now
    
    showMsg("Plan created successfully!", 'info');
    loadPlan(planId);

  } catch(e) {
    showMsg("Error generating plan: " + e.message, 'error');
    console.error(e);
  } finally {
    els.genBtn.disabled = false;
  }
}

// --- Display Logic (Dynamic Fetching) ---

function loadPlan(id) {
  currentPlan = appData.savedPlans[id];
  if (!currentPlan) return;
  
  appData.lastActiveId = id;
  saveData();
  
  // Ensure we know the base path for this book
  if (booksData[currentPlan.book]) {
    currentBookPath = booksData[currentPlan.book].basePath;
  }
  
  // Render Summary
  els.planView.classList.remove('hidden');
  els.sumBook.innerHTML = `<strong>Book:</strong> ${currentPlan.book}`;
  els.sumRange.innerHTML = `<strong>Range:</strong> ${currentPlan.range}`;
  els.sumCounts.innerHTML = `<strong>Stats:</strong> ${currentPlan.days.length} Days, ${currentPlan.totalSections} Sections`;
  
  renderCalendar();
  
  // Populate Jumper
  els.dayJumper.innerHTML = '';
  currentPlan.days.forEach((d, i) => {
    const opt = new Option(`Day ${i+1}: ${new Date(d.date).toLocaleDateString()}`, i);
    els.dayJumper.add(opt);
  });

  const todayIdx = getTodayIndex();
  setDay(todayIdx);
  
  // Update inputs to match plan for context
  els.bookSelect.value = currentPlan.book;
}

function renderCalendar() {
  els.calGrid.innerHTML = '';
  currentPlan.days.forEach((day, idx) => {
    const el = document.createElement('div');
    el.className = 'cal-day';
    el.dataset.date = `Day ${idx+1}: ${new Date(day.date).toLocaleDateString()}`;
    el.textContent = idx + 1;
    updateDayColor(el, day);
    el.onclick = () => setDay(idx);
    els.calGrid.appendChild(el);
  });
}

function updateDayColor(el, day) {
  if (day.sections.length === 0) {
    el.style.background = '#21262d'; 
    return;
  }
  const completed = day.sections.filter(s => s.checked).length;
  const pct = completed / day.sections.length;
  
  let r, g, b = 85;
  if (pct < 0.5) {
    r = 255;
    g = Math.round(85 + (170 * (pct * 2))); 
  } else {
    r = Math.round(255 - (170 * ((pct - 0.5) * 2))); 
    g = 255;
  }
  el.style.backgroundColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
  el.style.borderColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
}

// --- The Core View Logic: Fetch Text on Demand ---

async function setDay(idx) {
  if (!currentPlan) return;
  
  // Bounds check
  if (idx < 0) idx = 0;
  if (idx >= currentPlan.days.length) idx = currentPlan.days.length - 1;
  
  currentDayIndex = idx;
  els.dayJumper.value = idx;
  
  // Calendar Highlight
  document.querySelectorAll('.cal-day').forEach((el, i) => {
    if (i === idx) el.classList.add('active');
    else el.classList.remove('active');
  });

  const day = currentPlan.days[idx];
  els.dayContent.innerHTML = ''; // Clear

  if (day.sections.length === 0) {
    els.dayContent.innerHTML = '<div style="padding:20px; text-align:center; color:var(--muted)">Rest Day</div>';
    return;
  }

  // Show Loading State
  els.dayContent.innerHTML = '<div class="loading-text">Fetching section content from repository...</div>';

  try {
    // Parallel Fetching of text files
    const sectionPromises = day.sections.map(async (sec) => {
      const cacheKey = currentPlan.book + '_' + sec.file;
      
      // Return cached text if we visited this day this session
      if (runtimeTextCache[cacheKey]) {
        return { ...sec, text: runtimeTextCache[cacheKey] };
      }
      
      // Fetch fresh
      const url = encodePath(`${currentBookPath}/${sec.file}`);
      const res = await fetch(url);
      if (!res.ok) return { ...sec, text: "Error loading text." };
      const txt = await res.text();
      
      // Cache it
      runtimeTextCache[cacheKey] = txt;
      return { ...sec, text: txt };
    });

    const richSections = await Promise.all(sectionPromises);
    
    // Clear loading
    els.dayContent.innerHTML = '';

    // Render HTML
    richSections.forEach((sec, sIdx) => {
      const item = document.createElement('div');
      item.className = 'section-item';
      
      const head = document.createElement('div');
      head.className = 'section-header';
      
      const left = document.createElement('div');
      const label = document.createElement('label');
      label.className = 'section-check';
      
      const chk = document.createElement('input');
      chk.type = 'checkbox';
      chk.checked = day.sections[sIdx].checked || false; // Use original plan data for checked status
      chk.onchange = () => toggleCheck(idx, sIdx, chk.checked);
      
      const txt = document.createElement('div');
      txt.innerHTML = `<div class="section-title">${sec.fullTitle}</div><div class="section-meta">${sec.length} chars</div>`;
      
      label.append(chk, txt);
      left.appendChild(label);
      
      const cpBtn = document.createElement('button');
      cpBtn.className = 'secondary';
      cpBtn.style.padding = '4px 8px';
      cpBtn.style.fontSize = '0.8rem';
      cpBtn.textContent = 'Copy';
      cpBtn.onclick = (e) => copyText(sec.text, e.target);
      
      head.append(left, cpBtn);
      
      const content = document.createElement('div');
      content.className = 'section-content';
      const pre = document.createElement('pre');
      pre.textContent = sec.text;
      content.appendChild(pre);
      
      item.append(head, content);
      els.dayContent.appendChild(item);
    });

  } catch (err) {
    els.dayContent.innerHTML = `<div class="msg error">Failed to load day content: ${err.message}</div>`;
  }
}

function toggleCheck(dayIdx, secIdx, isChecked) {
  currentPlan.days[dayIdx].sections[secIdx].checked = isChecked;
  saveData();
  const calDay = els.calGrid.children[dayIdx];
  if (calDay) updateDayColor(calDay, currentPlan.days[dayIdx]);
}

// --- Utilities ---

async function copyText(text, btnElement) {
  try {
    await navigator.clipboard.writeText(text);
    const orig = btnElement.textContent;
    btnElement.textContent = "Copied!";
    btnElement.classList.add('success');
    setTimeout(() => {
      btnElement.textContent = orig;
      btnElement.classList.remove('success');
    }, 1500);
  } catch (err) {
    console.error(err);
  }
}

async function copyFullDay() {
  const day = currentPlan.days[currentDayIndex];
  if (!day || !day.sections.length) return;
  
  // We must ensure text is loaded. 
  // We can grab it from runtime cache or DOM, but best to use cache logic.
  let fullBlob = "";
  
  // Temporarily indicate working
  const origText = els.copyDayBtn.textContent;
  els.copyDayBtn.textContent = "Gathering...";
  
  try {
    for (const sec of day.sections) {
      const cacheKey = currentPlan.book + '_' + sec.file;
      let txt = runtimeTextCache[cacheKey];
      
      if (!txt) {
         // Fetch if not currently displayed/cached
         const url = encodePath(`${currentBookPath}/${sec.file}`);
         const res = await fetch(url);
         txt = await res.text();
         runtimeTextCache[cacheKey] = txt;
      }
      
      fullBlob += `# ${sec.fullTitle}\n${txt}\n\n`;
    }
    
    await navigator.clipboard.writeText(fullBlob);
    els.copyDayBtn.textContent = "Copied!";
    els.copyDayBtn.classList.add('success');
    setTimeout(() => {
       els.copyDayBtn.textContent = origText;
       els.copyDayBtn.classList.remove('success');
    }, 1500);
    
  } catch (e) {
    els.copyDayBtn.textContent = "Error";
    console.error(e);
  }
}

function getTodayIndex() {
  if (!currentPlan) return 0;
  const now = new Date();
  now.setHours(0,0,0,0);
  const start = new Date(currentPlan.startDate);
  start.setHours(0,0,0,0);
  const diff = Math.floor((now - start) / (1000 * 60 * 60 * 24));
  if (diff < 0) return 0;
  if (diff >= currentPlan.days.length) return currentPlan.days.length - 1;
  return diff;
}

function setDefaultDates() {
  const today = new Date();
  els.startDate.value = today.toISOString().split('T')[0];
  const target = new Date();
  target.setDate(today.getDate() + 14);
  els.endDate.value = target.toISOString().split('T')[0];
}

function showMsg(txt, type) {
  els.msg.textContent = txt;
  els.msg.className = 'msg ' + type;
  setTimeout(() => els.msg.textContent = '', 4000);
}

const natCompare = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
const compareSectionKeys = (a, b) => {
  const numsA = a.split('.').map(Number);
  const numsB = b.split('.').map(Number);
  for (let i = 0; i < Math.max(numsA.length, numsB.length); i++) {
    const valA = numsA[i] || 0;
    const valB = numsB[i] || 0;
    if (valA !== valB) return valA - valB;
  }
  return 0;
};
const encodePath = (p) => p.split('/').map(encodeURIComponent).join('/');

// --- Event Listeners ---
els.bookSelect.addEventListener('change', handleBookChange);
els.genBtn.addEventListener('click', generatePlan);
els.loadBtn.addEventListener('click', loadPlanFromDropdown);
els.delBtn.addEventListener('click', deletePlan);
els.dlBtn.addEventListener('click', exportData);
els.ulBtn.addEventListener('click', () => els.ulInput.click());
els.ulInput.addEventListener('change', importData);
els.dayJumper.addEventListener('change', (e) => setDay(parseInt(e.target.value)));
els.prevDay.addEventListener('click', () => setDay(currentDayIndex - 1));
els.nextDay.addEventListener('click', () => setDay(currentDayIndex + 1));
els.todayBtn.addEventListener('click', () => setDay(getTodayIndex()));
els.copyDayBtn.addEventListener('click', copyFullDay);

init();
</script>
</body>
</html>