(function() {
    const STORAGE_KEY_AMANDA = 'amandaTasks_v2_storage';
    const initialDefaultAmandaTasks = [
        { id: 'amanda-task-1', text: "👕 Put rest of my clothes in bins", status: 0 },
        { id: 'amanda-task-2', text: "👟 Put my shoes in closet", status: 0 },
        { id: 'amanda-task-3', text: "👧 Put away girls’ old shoes (attic box)", status: 0 },
        { id: 'amanda-task-4', text: "🧺 Put away all my clean clothes", status: 0 },
        { id: 'amanda-task-5', text: "🛏️ Tidy our room – bench, sheets (Sterling will help)", status: 0 },
        { id: 'amanda-task-6', text: "🧼 Clean our closet dresser top", status: 0 },
        { id: 'amanda-task-7', text: "🛁 Clean bathroom countertop", status: 0 }
    ];
    let currentAmandaTasks;
    let isEditMode = false;
    let longPressTimer;
    const LONG_PRESS_DURATION = 1000; // 1 second
    let sortableInstance = null; // <<<< ADDED: To store the SortableJS instance

    const appContainer = document.querySelector('.app-container');
    const taskListElement = document.getElementById('taskListAmanda');
    const addTaskButton = document.getElementById('addTaskBtnAmanda');
    const pastelColorClasses = ['pastel-bg-1', 'pastel-bg-2', 'pastel-bg-3', 'pastel-bg-4'];

    function generateUniqueId(prefix = 'task') {
        return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    function loadTasksFromStorage() {
        try {
            const storedTasks = localStorage.getItem(STORAGE_KEY_AMANDA);
            if (storedTasks) {
                const parsedTasks = JSON.parse(storedTasks);
                if (Array.isArray(parsedTasks) &&
                    (parsedTasks.length === 0 || (typeof parsedTasks[0].id !== 'undefined' && typeof parsedTasks[0].status !== 'undefined'))) {
                    currentAmandaTasks = parsedTasks;
                    return;
                }
            }
        } catch (error) { /* Fall through to defaults */ }
        currentAmandaTasks = initialDefaultAmandaTasks.map(task => ({ ...task }));
    }

    function saveTasksToStorage() {
        try {
            localStorage.setItem(STORAGE_KEY_AMANDA, JSON.stringify(currentAmandaTasks));
        } catch (error) {
            console.error(`Error saving tasks to localStorage for ${STORAGE_KEY_AMANDA}:`, error);
        }
    }

    function renderTasks() {
        taskListElement.innerHTML = '';
        let completedTaskCounter = 0;
        
        currentAmandaTasks.forEach((task) => {
            const listItem = document.createElement('li');
            listItem.setAttribute('data-id', task.id); 
            listItem.className = `status-${task.status}`;
            if (isEditMode) {
                listItem.classList.add('edit-mode-item');
            }

            if (task.status === 2) {
                const pastelClass = pastelColorClasses[completedTaskCounter % pastelColorClasses.length];
                listItem.classList.add(pastelClass);
                completedTaskCounter++;
            }

            const checkboxContainer = document.createElement('span');
            checkboxContainer.className = `checkbox-container status-${task.status}`;
            checkboxContainer.innerHTML = `
                <i class="far fa-square"></i>
                <i class="fas fa-circle-half-stroke"></i>
                <i class="far fa-check-square"></i>
            `;
            if (!isEditMode) {
                checkboxContainer.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleTaskStatus(task.id);
                });
            }

            const taskTextElement = document.createElement('span');
            taskTextElement.classList.add('task-text');
            taskTextElement.textContent = task.text;

            listItem.appendChild(checkboxContainer);
            listItem.appendChild(taskTextElement);

            if (isEditMode) {
                taskTextElement.title = "Click to edit task text";
                taskTextElement.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    makeTaskEditable(task.id, listItem);
                });
                
                const deleteButton = document.createElement('span');
                deleteButton.className = 'delete-task-btn';
                deleteButton.innerHTML = '<i class="fas fa-times"></i>';
                deleteButton.title = "Delete task";
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    deleteTask(task.id);
                });
                listItem.appendChild(deleteButton);

            } else { 
                taskTextElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleTaskStatus(task.id);
                });
                
                let pressStartX, pressStartY;
                const handlePressStart = (e) => {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    if ((e.type === "mousedown" && e.button !== 0) || isEditMode || listItem.querySelector('input.task-edit-input')) return;
                    pressStartX = clientX;
                    pressStartY = clientY;
                    clearTimeout(longPressTimer); 
                    longPressTimer = setTimeout(() => {
                         if (document.querySelector('.task-edit-input:focus')) return;
                        enterEditMode(task.id);
                    }, LONG_PRESS_DURATION);
                };
                const clearLongPress = () => clearTimeout(longPressTimer);
                const handlePressMove = (e) => {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    if (Math.abs(clientX - pressStartX) > 10 || Math.abs(clientY - pressStartY) > 10) {
                        clearTimeout(longPressTimer);
                    }
                };
                listItem.addEventListener('mousedown', handlePressStart);
                listItem.addEventListener('mouseup', clearLongPress);
                listItem.addEventListener('mouseleave', clearLongPress);
                listItem.addEventListener('mousemove', handlePressMove);
                listItem.addEventListener('touchstart', handlePressStart, { passive: true });
                listItem.addEventListener('touchend', clearLongPress);
                listItem.addEventListener('touchcancel', clearLongPress);
                listItem.addEventListener('touchmove', handlePressMove, { passive: true });
            }
            
            taskListElement.appendChild(listItem);
        });
    }

    function makeTaskEditable(taskId, listItemElement) {
        const task = currentAmandaTasks.find(t => t.id === taskId);
        const taskTextSpan = listItemElement.querySelector('.task-text'); // Ensure it's the span, not an input
        if (!task || !taskTextSpan || listItemElement.querySelector('input.task-edit-input')) return;

        const otherActiveInput = taskListElement.querySelector('input.task-edit-input');
        if (otherActiveInput) { // If any input field is already active anywhere
             // Check if it's a different item's input. If it's the same, this function call is likely redundant.
            if (otherActiveInput.closest('li') !== listItemElement) {
                otherActiveInput.blur(); // This will trigger its own save and re-render
            } else {
                return; // Already editing this item
            }
        }
        
        // After a potential re-render from otherActiveInput.blur(), re-fetch the span if necessary.
        // For simplicity, we assume listItemElement and its child taskTextSpan are still valid
        // or that the user interaction flow prevents issues here.
        // A more robust solution would re-query taskTextSpan if a blur() occurred.
        const currentTaskTextSpan = listItemElement.querySelector('.task-text'); // Re-query in case of re-render
        if (!currentTaskTextSpan || currentTaskTextSpan.tagName === 'INPUT') return; // Safety check


        const input = document.createElement('input');
        input.type = 'text';
        input.value = task.text;
        input.className = 'task-edit-input';
        
        const saveChanges = () => {
            const newText = input.value.trim();
            if (newText && newText !== task.text) {
                task.text = newText;
            }
            saveTasksToStorage();
            // Only re-render if still in edit mode and input is part of DOM
            // (it might have been removed by sort's onEnd render)
            if (isEditMode && document.body.contains(input)) { 
                 renderTasks();
            }
        };

        input.addEventListener('blur', saveChanges);
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                input.blur();
            } else if (e.key === 'Escape') {
                input.value = task.text; 
                input.blur();
            }
        });

        currentTaskTextSpan.replaceWith(input);
        input.focus();
        input.select();
    }

    function toggleTaskStatus(taskId) {
        if (isEditMode) return; 
        const task = currentAmandaTasks.find(t => t.id === taskId);
        if (task) {
            task.status = (task.status + 1) % 3;
            saveTasksToStorage();
            renderTasks(); 
        }
    }

    function deleteTask(taskId) {
        currentAmandaTasks = currentAmandaTasks.filter(t => t.id !== taskId);
        saveTasksToStorage();
        renderTasks(); 
    }

    function enterEditMode(initiatingTaskId = null) {
        if (isEditMode) return;
        isEditMode = true;
        appContainer.classList.add('edit-mode');
        renderTasks(); // Render first to ensure all items have data-id and correct structure
        
        if (sortableInstance) sortableInstance.destroy(); // Should be null, but defensive
        
        sortableInstance = new Sortable(taskListElement, {
            animation: 150,
            ghostClass: 'sortable-ghost',
            chosenClass: 'sortable-chosen',
            dragClass: 'sortable-drag',
            filter: '.task-edit-input, .delete-task-btn, .checkbox-container', // Elements that should not trigger drag start
            preventOnFilter: true, // Necessary for filter to work
            onEnd: function (evt) {
                // evt.oldIndex and evt.newIndex are the original and new position of the moved item
                if (evt.oldIndex === evt.newIndex) return;

                // If an input field was active, save its current text before reordering
                const activeEditInput = taskListElement.querySelector('input.task-edit-input');
                if (activeEditInput) {
                    const listItemOfInput = activeEditInput.closest('li');
                    if (listItemOfInput) {
                        const taskIdOfInput = listItemOfInput.dataset.id;
                        const taskBeingEdited = currentAmandaTasks.find(t => t.id === taskIdOfInput);
                        if (taskBeingEdited) {
                            const newText = activeEditInput.value.trim();
                            if (newText && newText !== taskBeingEdited.text) {
                                taskBeingEdited.text = newText;
                            }
                            // Note: The input field itself will be removed by the renderTasks() call below.
                        }
                    }
                }

                // Reorder currentAmandaTasks array
                const movedItem = currentAmandaTasks.splice(evt.oldIndex, 1)[0];
                currentAmandaTasks.splice(evt.newIndex, 0, movedItem);
                
                saveTasksToStorage();
                // Re-render to apply correct styles and ensure UI consistency.
                renderTasks(); 
            }
        });
        console.log("Entered Edit Mode, SortableJS initialized.");
    }

    function exitEditMode() {
        if (!isEditMode) return;
        
        const activeInput = taskListElement.querySelector('input.task-edit-input:focus');
        if (activeInput) {
            activeInput.blur(); // This will trigger its saveChanges, which might call renderTasks
        }

        if (sortableInstance) {
            sortableInstance.destroy();
            sortableInstance = null;
            console.log("SortableJS destroyed.");
        }

        isEditMode = false;
        appContainer.classList.remove('edit-mode');
        // saveTasksToStorage(); // Usually saved by input blur or sort onEnd
        renderTasks(); // Final render for non-edit mode state
        console.log("Exited Edit Mode");
    }

    function addNewTask() {
        if (!isEditMode) return;
        // If an input is already active, blur it first to save it.
        const otherActiveInput = taskListElement.querySelector('input.task-edit-input');
        if (otherActiveInput) {
            otherActiveInput.blur(); // This will save and re-render.
        }

        const newText = "New Task";
        const newTask = {
            id: generateUniqueId('amanda-task'),
            text: newText,
            status: 0
        };
        currentAmandaTasks.push(newTask);
        saveTasksToStorage();
        renderTasks(); // Re-render the list with the new task

        // Find the newly added list item and make it editable
        const newListItem = taskListElement.querySelector(`li[data-id="${newTask.id}"]`);
        if (newListItem) {
            // Timeout ensures that this runs after the current execution context (including potential re-renders from blur)
            setTimeout(() => makeTaskEditable(newTask.id, newListItem), 0);
        }
    }

    addTaskButton.addEventListener('click', addNewTask);

    appContainer.addEventListener('click', (event) => {
        if (isEditMode) {
            // Exit edit mode if the click is on the appContainer itself (empty space),
            // not on its children (like the task list or add button).
            if (event.target === appContainer) {
                exitEditMode();
            }
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        loadTasksFromStorage();
        renderTasks();
    });
})();