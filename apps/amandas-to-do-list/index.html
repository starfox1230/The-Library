<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="format-detection" content="telephone=no">
  <title>Amanda's Tasks</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  />

  <!-- SortableJS REMOVED -->

  <style>
    html, body, button, input, textarea {
      touch-action: manipulation;
    }
    li, .drag-handle-amanda {
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      user-select: none !important;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Poppins', sans-serif;
      background-color: #FFF0F5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      color: #6D4C41;
      padding: 20px;
    }
    .app-container {
      position: relative;
      background-color: #fff;
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(216, 139, 167, 0.15);
      max-width: 500px;
      width: 100%;
    }
    h1 {
      text-align: center;
      color: #C2185B;
      margin-bottom: 20px;
      font-weight: 600;
      letter-spacing: .5px;
    }
    .toggle-edit-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 6px 12px;
      background: #C2185B;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: .9em;
      cursor: pointer;
      transition: background .2s;
    }
    .toggle-edit-btn.done { background: #4CAF50; }
    ul { list-style: none; margin: 0 0 60px; padding: 0; }
    li {
      display: flex;
      align-items: center;
      padding: 15px 5px;
      border-bottom: 1px solid #F8BBD0;
      transition: background .2s, border .2s, opacity .2s; /* Added opacity for dragging */
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    li:last-child { border-bottom: none; }

    .drag-handle-amanda {
      display: none;
      cursor: grab;
      margin-right: 10px;
      font-size: 1.2em;
      color: #AD1457;
      padding: 5px;
      touch-action: none;
    }
    .app-container.edit-mode li .drag-handle-amanda {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .app-container.edit-mode li .drag-handle-amanda:active { cursor: grabbing; }

    .checkbox-container {
      flex-shrink: 0;
      width: 28px;
      text-align: center;
      margin-right: 18px;
      font-size: 1.5em;
      color: #D7CCC8;
      cursor: pointer;
      transition: color .2s;
    }
    .checkbox-container.status-0 .fa-square { display: inline-block; }
    .checkbox-container.status-0 .fa-circle-half-stroke,
    .checkbox-container.status-0 .fa-check-square { display: none; }
    .checkbox-container.status-1 { color: #FFB74D; }
    .checkbox-container.status-1 .fa-circle-half-stroke { display: inline-block; }
    .checkbox-container.status-1 .fa-square,
    .checkbox-container.status-1 .fa-check-square { display: none; }
    .checkbox-container.status-2 { color: #AED581; }
    .checkbox-container.status-2 .fa-check-square { display: inline-block; }
    .checkbox-container.status-2 .fa-square,
    .checkbox-container.status-2 .fa-circle-half-stroke { display: none; }

    .task-text {
      flex-grow: 1;
      cursor: pointer;
      transition: color .3s, text-decoration .3s;
      word-break: break-word;
    }
    li.status-1 .task-text { color: #8D6E63; }
    li.status-2 .task-text {
      text-decoration: line-through;
      color: #BCAAA4;
    }
    .pastel-bg-1 { background: #FFDFD3; }
    .pastel-bg-2 { background: #D4F0F0; }
    .pastel-bg-3 { background: #E6E0FF; }
    .pastel-bg-4 { background: #FFFACD; }
    li.status-2.pastel-bg-1 .task-text,
    li.status-2.pastel-bg-2 .task-text,
    li.status-2.pastel-bg-3 .task-text,
    li.status-2.pastel-bg-4 .task-text { color: #6D4C41; }

    .app-container.edit-mode li {
      /* border: 1px dashed #E91E63; */ /* Optional: keep if desired */
      /* margin-bottom: -1px; */
    }
    .app-container.edit-mode .checkbox-container { cursor: default; }
    .app-container.edit-mode .task-text { cursor: text; }

    .add-task-btn {
      display: none;
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: #C2185B;
      color: #fff;
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(194, 24, 91, 0.3);
    }
    .add-task-btn i { margin-right: 8px; }
    .app-container.edit-mode .add-task-btn { display: block; }
    .add-task-btn:hover { background: #AD1457; }

    .delete-task-btn {
      display: none;
      color: #E91E63;
      font-size: 1.1em;
      margin-left: 12px;
      padding: 3px 6px;
      cursor: pointer;
      border-radius: 50%;
      transition: background .2s, color .2s;
      flex-shrink: 0;
    }
    .app-container.edit-mode li .delete-task-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .delete-task-btn:hover { background: #FCE4EC; color: #C2185B; }

    .task-edit-input {
        flex-grow: 1;
        padding: 5px;
        border: 1px solid #C2185B;
        border-radius: 4px;
        font-family: 'Poppins', sans-serif;
        font-size: inherit;
        color: #6D4C41;
    }

    /* NEW Drag and Drop Styles */
    li.dragging { /* Style for the item being actively dragged */
        opacity: 0.6;
        background: #FFECF0 !important; /* Light pink, ensure it overrides other BGs */
        box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        /* border: 1px solid #C2185B !important; */ /* Optional: border for dragged item */
    }
    .drag-over-placeholder-amanda { /* Placeholder style */
        /* Height should roughly match an item's height + vertical margins */
        height: 60px; /* Adjust based on li padding and border */
        background-color: rgba(248, 187, 208, 0.2); /* Very light pink, slightly transparent */
        border: 2px dashed #C2185B;
        border-radius: 8px; /* Match app's border radius aesthetic */
        margin: 5px 0 5px 0; /* Adjust to center placeholder between items */
        box-sizing: border-box;
        /* Ensure it doesn't have content that would take space */
        display: block;
        list-style-type: none; /* Explicitly no list bullet */
    }


    @media (max-width: 600px) {
      h1 { font-size: 1.7em; margin-bottom: 20px; }
      .checkbox-container { width: 25px; margin-right: 12px; font-size: 1.3em; }
      .task-text { font-size: .95em; }
      li { padding: 12px 5px; }
      .add-task-btn { font-size: .9em; padding: 8px 15px; }
      .delete-task-btn { font-size: 1em; margin-left: 8px; }
      .drag-over-placeholder-amanda { height: 55px; }
    }
  </style>

  <script>
    let lastTouchEnd = 0;
    document.addEventListener('touchend', e => {
      const now = Date.now();
      if (
        now - lastTouchEnd <= 300 &&
        !['INPUT', 'TEXTAREA', 'BUTTON', 'SUMMARY'].includes(e.target.tagName) &&
        !e.target.closest('.drag-handle-amanda') && // Don't prevent default on drag handle
        !e.target.closest('.checkbox-container') && // Don't prevent double tap on checkbox
        !e.target.closest('.task-text:not(.task-edit-input)') && // Allow double tap on task text (if it had a purpose)
        !e.target.closest('.delete-task-btn')
      ) {
        // e.preventDefault(); // Be cautious with this, might interfere with legitimate fast taps
      }
      lastTouchEnd = now;
    }, { passive: false });
  </script>
</head>

<body>
  <div class="app-container">
    <h1>Amanda's Tasks</h1>
    <button id="toggleEditBtnAmanda" class="toggle-edit-btn">
      <i class="fas fa-edit"></i> Edit
    </button>

    <ul id="taskListAmanda"></ul>

    <button id="addTaskBtnAmanda" class="add-task-btn">
      <i class="fas fa-plus"></i> Add Task
    </button>
  </div>

  <script>
  (function(){
    const STORAGE_KEY = 'amandaTasks_v3_custom_dnd'; // Changed key to avoid conflict
    const defaults = [
      { id: 'amanda-task-1', text: "ðŸ‘• Put rest of my clothes in bins", status: 0 },
      { id: 'amanda-task-2', text: "ðŸ‘Ÿ Put my shoes in closet", status: 0 },
      { id: 'amanda-task-3', text: "ðŸ‘§ Put away girlsâ€™ old shoes (attic box)", status: 0 },
      { id: 'amanda-task-4', text: "ðŸ§º Put away all my clean clothes", status: 0 },
      { id: 'amanda-task-5', text: "ðŸ›ï¸ Tidy our room â€“ bench, sheets (Sterling will help)", status: 0 },
      { id: 'amanda-task-6', text: "ðŸ§¼ Clean our closet dresser top", status: 0 },
      { id: 'amanda-task-7', text: "ðŸ› Clean bathroom countertop", status: 0 }
    ];
    let tasks = [], isEditMode = false;
    // Removed sortableInst

    // NEW: Drag and Drop state variables
    let draggedItem = null;
    let amandaPlaceholder = null;

    const pastel = ['pastel-bg-1','pastel-bg-2','pastel-bg-3','pastel-bg-4'];
    const listEl = document.getElementById('taskListAmanda'),
          toggleBtn = document.getElementById('toggleEditBtnAmanda'),
          addBtn    = document.getElementById('addTaskBtnAmanda'),
          appContainer = document.querySelector('.app-container');

    function genId(){
      return 'task-'+Date.now()+'-'+Math.random().toString(36).slice(2,9);
    }
    function load(){
      try {
        const arr = JSON.parse(localStorage.getItem(STORAGE_KEY));
        if (Array.isArray(arr) && arr.length > 0) tasks = arr; // Ensure arr is not empty
        else throw 0;
      } catch {
        tasks = defaults.map(t=>({...t, id: t.id || genId()})); // Ensure IDs for defaults
      }
    }
    function save(){
      // tasks array should be in correct order due to updateTasksOrderFromDOM()
      localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
    }

    // NEW: Update tasks array based on DOM order
    function updateTasksOrderFromDOM() {
        const orderedTasks = [];
        const itemElements = listEl.querySelectorAll('li[data-id]'); // Select only actual task items
        itemElements.forEach(itemEl => {
            const taskId = itemEl.dataset.id;
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                orderedTasks.push(task);
            }
        });
        tasks = orderedTasks;
    }

    // NEW: Create placeholder element
    function createAmandaPlaceholder() {
        if (!amandaPlaceholder) {
            amandaPlaceholder = document.createElement('li');
            amandaPlaceholder.className = 'drag-over-placeholder-amanda';
        }
        return amandaPlaceholder;
    }

    // NEW: Determine element to insert before during drag
    function getDragAfterElementAmanda(container, y) {
        const draggableElements = [...container.querySelectorAll('li[data-id]:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }


    function render(){
      listEl.innerHTML = '';
      let doneCount = 0;
      tasks.forEach(t => {
        const li = document.createElement('li');
        li.dataset.id = t.id;
        li.className = `status-${t.status}`; // Base class
        if (t.status === 2) {
            li.classList.add(pastel[doneCount++ % pastel.length]);
        }

        const chk = document.createElement('span');
        chk.className = `checkbox-container status-${t.status}`;
        chk.innerHTML = '<i class="far fa-square"></i><i class="fas fa-circle-half-stroke"></i><i class="far fa-check-square"></i>';
        if(!isEditMode) {
            chk.addEventListener('click',()=>{
                t.status=(t.status+1)%3; save(); render();
            });
        }
        

        const txt = document.createElement('span');
        txt.className='task-text';
        txt.textContent = t.text;
        if(isEditMode){
          txt.title='Click to edit';
          txt.addEventListener('click', (e) => {
            // Prevent drag from starting if clicking on text to edit
            e.stopPropagation(); 
            editText(t.id,li);
          });
        } else {
          txt.addEventListener('click',()=>{
            t.status=(t.status+1)%3; save(); render();
          });
        }
        

        if(isEditMode){
          li.setAttribute('draggable', 'true'); // Make item draggable for mouse
          const h = document.createElement('span');
          h.className='drag-handle-amanda';
          h.innerHTML='<i class="fas fa-grip-vertical"></i>';
          
          // Mouse drag events on the LI (handle is part of it)
          li.addEventListener('dragstart', handleLiDragStart);
          li.addEventListener('dragend', handleLiDragEnd);

          // Touch drag event on the HANDLE
          h.addEventListener('touchstart', handleTouchDragStartOnHandle, { passive: true });
          // Touchend for the item will be handled by a global listener on the document
          
          li.appendChild(h); // Add handle first for typical layout
        } else {
            li.removeAttribute('draggable');
        }
        
        li.appendChild(chk); // Then checkbox
        li.appendChild(txt); // Then text

        if(isEditMode){
          const del = document.createElement('span');
          del.className='delete-task-btn';
          del.innerHTML='<i class="fas fa-times"></i>';
          del.title='Delete';
          del.addEventListener('click',(e)=>{
            e.stopPropagation(); // Prevent drag
            tasks = tasks.filter(x=>x.id!==t.id);
            save(); render();
          });
          li.appendChild(del);
        }

        listEl.appendChild(li);
      });
    }

    function editText(id, li){
      const t = tasks.find(x=>x.id===id),
            span = li.querySelector('.task-text');
      if(!t||!span || li.querySelector('.task-edit-input')) return; // Prevent multiple edits

      const inp = document.createElement('input');
      inp.type='text'; inp.value=t.text; inp.className='task-edit-input';
      inp.style.flexGrow = '1';
      
      const finishEdit = () => {
        const v=inp.value.trim(); if(v) t.text=v;
        save(); render(); // Re-render to restore span and event listeners
      };

      inp.addEventListener('blur', finishEdit);
      inp.addEventListener('keydown',e=>{
        if(e.key==='Enter'){ e.preventDefault(); inp.blur(); }
        if(e.key==='Escape'){ inp.value=t.text; /* Restore original text */ inp.blur(); }
      });
      span.replaceWith(inp);
      inp.focus(); inp.select();
    }

    function enterEditMode(){
      isEditMode=true;
      appContainer.classList.add('edit-mode');
      render(); // Re-render to add drag handles and listeners
    }

    function exitEditMode(){
      isEditMode=false;
      appContainer.classList.remove('edit-mode');
      
      // Ensure any drag state is cleaned up if "Done" is clicked mid-drag (basic cleanup)
      if (draggedItem) {
          draggedItem.classList.remove('dragging');
          draggedItem = null;
      }
      if (amandaPlaceholder && amandaPlaceholder.parentNode) {
          amandaPlaceholder.remove();
          amandaPlaceholder = null; // Clear the reference
      }

      updateTasksOrderFromDOM(); // Make sure tasks array matches DOM before saving
      save();
      render(); // Re-render in non-edit mode
    }

    function addTask(){
      if(!isEditMode) return;
      const newT={ id:genId(), text:'New Task', status:0 };
      tasks.push(newT); // Add to end of array
      save(); // Save before render, or save after ensuring new item is in tasks array
      render(); 
      const li = listEl.querySelector(`li[data-id="${newT.id}"]`);
      if(li) editText(newT.id, li);
    }

    toggleBtn.addEventListener('click',()=>{
      if(isEditMode){
        exitEditMode();
        toggleBtn.classList.remove('done');
        toggleBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
      } else {
        enterEditMode();
        toggleBtn.classList.add('done');
        toggleBtn.innerHTML = '<i class="fas fa-check"></i> Done';
      }
    });
    addBtn.addEventListener('click', addTask);

    // --- DRAG AND DROP EVENT HANDLERS ---
    function handleLiDragStart(e) { // 'this' is the li
        if (!isEditMode) { e.preventDefault(); return; }
        
        // Filter: Prevent drag if click originated on interactive elements within the li
        const targetTagName = e.target.tagName.toLowerCase();
        if (e.target.classList.contains('task-edit-input') ||
            e.target.closest('.delete-task-btn') ||
            e.target.closest('.checkbox-container') ||
            targetTagName === 'input' || targetTagName === 'button' ||
            (e.target.closest('.task-text') && this.querySelector('.task-edit-input')) // If editing text
           ) {
            e.preventDefault();
            return;
        }

        draggedItem = this;
        try { e.dataTransfer.setData('text/plain', ''); } catch(err) {} // Firefox
        e.dataTransfer.effectAllowed = 'move';
        
        setTimeout(() => { // Allow browser to paint drag image before style change
            if (draggedItem) draggedItem.classList.add('dragging');
        }, 0);
    }

    function handleLiDragEnd() { // 'this' is the li
        if (this.classList.contains('dragging')) {
            this.classList.remove('dragging');
        }
        if (amandaPlaceholder && amandaPlaceholder.parentNode) {
            amandaPlaceholder.remove();
            // amandaPlaceholder = null; // Don't nullify here, createAmandaPlaceholder handles it
        }
        
        // Save should happen after DOM is updated by 'drop'
        // and tasks array is updated.
        if (draggedItem) { // Only if a drag was successfully completed (not cancelled)
            updateTasksOrderFromDOM();
            save();
        }
        draggedItem = null;
    }

    function handleTouchDragStartOnHandle(e) { // 'e.currentTarget' is the handle
        if (!isEditMode) return;
        const listItem = e.currentTarget.closest('li');
        if (!listItem) return;
        
        draggedItem = listItem;
        // 'dragging' class will be added on first touchmove to distinguish from tap
    }

    function handleDragOverOrMove(e) {
        if (!draggedItem || !isEditMode) return;

        if (e.type === 'touchmove' && !draggedItem.classList.contains('dragging')) {
            draggedItem.classList.add('dragging'); // Add dragging class on first significant move
        }
        
        e.preventDefault(); // Crucial for dragover and to prevent scroll on touchmove

        const currentY = e.clientY || (e.touches && e.touches[0].clientY);
        if (currentY === undefined) return;

        const ph = createAmandaPlaceholder();
        const afterElement = getDragAfterElementAmanda(listEl, currentY);

        // Ensure placeholder is not inserted into the dragged item itself (edge case)
        if (draggedItem.contains(ph)) return;

        if (afterElement == null) {
            if (listEl.lastChild !== ph) listEl.appendChild(ph);
        } else {
            if (afterElement !== ph && afterElement.previousSibling !== ph) {
                 listEl.insertBefore(ph, afterElement);
            }
        }
    }

    listEl.addEventListener('dragover', handleDragOverOrMove);
    listEl.addEventListener('touchmove', (e) => {
        if (!draggedItem || !isEditMode) return;
        e.preventDefault(); // Prevent scrolling during item drag
        handleDragOverOrMove(e);
    }, { passive: false });

    listEl.addEventListener('drop', (e) => {
        if (!draggedItem || !isEditMode) return;
        e.preventDefault();
        if (amandaPlaceholder && amandaPlaceholder.parentNode === listEl) {
            listEl.insertBefore(draggedItem, amandaPlaceholder);
            // Placeholder removal and save happens in dragend
        }
        // No immediate save here; dragend will handle it after class removal.
    });
    
    // Global touchend for robust touch drop handling
    document.addEventListener('touchend', (e) => {
        if (!draggedItem || !isEditMode) return;

        // Only proceed if a drag was actually happening (dragging class was applied)
        if (!draggedItem.classList.contains('dragging')) {
            draggedItem = null; // It was likely a tap, not a drag
            return;
        }

        if (amandaPlaceholder && amandaPlaceholder.parentNode === listEl) {
            listEl.insertBefore(draggedItem, amandaPlaceholder);
            amandaPlaceholder.remove(); 
            // amandaPlaceholder = null; // Handled by createPlaceholder
        }
        
        draggedItem.classList.remove('dragging');
        updateTasksOrderFromDOM();
        save();
        draggedItem = null; // Reset
    });


    document.addEventListener('DOMContentLoaded',()=>{
      load(); 
      render(); // Initial render
      // D&D listeners on listEl and document are added globally once and remain.
    });
  })();
  </script>
</body>
</html>