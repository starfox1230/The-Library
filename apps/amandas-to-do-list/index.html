<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amanda's Tasks</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<style>
    body {
        font-family: 'Poppins', sans-serif;
        background-color: #FFF0F5; /* LavenderBlush */
        margin: 0;
        padding: 20px;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        color: #6D4C41; /* Warm Dark Brown */
    }

    .app-container {
        background-color: #ffffff;
        padding: 30px;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(216, 139, 167, 0.15); /* Soft pinkish shadow */
        width: 100%;
        max-width: 500px;
        position: relative; /* For positioning add button */
    }

    h1 {
        color: #C2185B; /* Deeper, elegant pink */
        text-align: center;
        margin-top: 0;
        margin-bottom: 30px;
        font-weight: 600;
        letter-spacing: 0.5px;
    }

    ul {
        list-style-type: none;
        padding: 0;
        margin: 0 0 60px 0; /* Add margin for add button */
    }

    li {
        display: flex;
        align-items: center;
        padding: 15px 5px;
        border-bottom: 1px solid #F8BBD0; /* Soft Pink border */
        transition: background-color 0.2s ease-in-out, border 0.2s ease-in-out;
        position: relative; /* For drag indicators if needed */
    }

    li:last-child {
        border-bottom: none;
    }

    .checkbox-container {
        font-size: 1.5em;
        margin-right: 18px;
        cursor: pointer;
        width: 28px;
        text-align: center;
        transition: color 0.2s ease-in-out;
        flex-shrink: 0;
        color: #D7CCC8; /* Default icon color */
    }

    .task-text {
        flex-grow: 1;
        font-size: 1em;
        line-height: 1.5;
        transition: color 0.3s ease, text-decoration 0.3s ease;
        cursor: pointer;
    }

    /* State Styles for Icons */
    .checkbox-container.status-0 .fa-square { display: inline-block; }
    .checkbox-container.status-0 .fa-circle-half-stroke,
    .checkbox-container.status-0 .fa-check-square { display: none; }

    .checkbox-container.status-1 { color: #FFB74D; } /* Pastel Orange/Peach */
    .checkbox-container.status-1 .fa-circle-half-stroke { display: inline-block; }
    .checkbox-container.status-1 .fa-square,
    .checkbox-container.status-1 .fa-check-square { display: none; }

    .checkbox-container.status-2 { color: #AED581; } /* Pastel Green */
    .checkbox-container.status-2 .fa-check-square { display: inline-block; }
    .checkbox-container.status-2 .fa-square,
    .checkbox-container.status-2 .fa-circle-half-stroke { display: none; }

    /* State Styles for List Item & Text */
    li.status-1 .task-text { color: #8D6E63; } /* Warm medium brown */
    
    li.status-2 .task-text {
        text-decoration: line-through;
        color: #BCAAA4; /* Lighter, muted warm grey */
    }

    /* Alternating Pastel Backgrounds for Completed Tasks */
    .pastel-bg-1 { background-color: #FFDFD3; } /* Pastel Peach */
    .pastel-bg-2 { background-color: #D4F0F0; } /* Pastel Mint */
    .pastel-bg-3 { background-color: #E6E0FF; } /* Pastel Lavender */
    .pastel-bg-4 { background-color: #FFFACD; } /* LemonChiffon */

    li.status-2.pastel-bg-1 .task-text,
    li.status-2.pastel-bg-2 .task-text,
    li.status-2.pastel-bg-3 .task-text,
    li.status-2.pastel-bg-4 .task-text {
        color: #6D4C41; /* Darker text for contrast on light pastels */
    }


    li:hover:not(.edit-mode-item) { /* Don't apply hover if it's an edit mode item, to avoid style conflicts */
        background-color: #FFF8FA;
    }

    /* Edit Mode Styles */
    .app-container.edit-mode li {
        border: 1px dashed #E91E63; /* Pink dashed border for editable items */
        margin-bottom: -1px; /* Compensate for border */
        cursor: grab;
    }
    .app-container.edit-mode li:active {
        cursor: grabbing;
    }
    .app-container.edit-mode .checkbox-container {
        cursor: default; /* Checkbox not interactive in edit mode */
    }
     .app-container.edit-mode .task-text {
        cursor: text; /* Indicate text is editable */
    }


    .task-edit-input {
        flex-grow: 1;
        font-family: 'Poppins', sans-serif;
        font-size: 1em;
        padding: 4px 6px;
        border: 1px solid #C2185B;
        border-radius: 4px;
        outline-color: #AD1457;
    }

    .add-task-btn {
        display: none; /* Hidden by default */
        position: absolute;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background-color: #C2185B;
        color: white;
        border: none;
        border-radius: 8px;
        font-family: 'Poppins', sans-serif;
        font-size: 0.95em;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(194, 24, 91, 0.3);
        transition: background-color 0.2s ease;
    }
    .app-container.edit-mode .add-task-btn {
        display: block; /* Show in edit mode */
    }
    .add-task-btn:hover {
        background-color: #AD1457;
    }
    .add-task-btn i {
        margin-right: 8px;
    }

    /* Drag and Drop Visuals */
    .dragging {
        opacity: 0.5;
        background: #FFECF0; /* Light pinkish tint when dragging */
    }
    .drag-over-target {
        /* You can add a top/bottom border to indicate drop position */
        /* For simplicity, we'll rely on natural element flow */
         box-shadow: 0 0 0 2px #FFB74D inset; /* Pastel Orange highlight */
    }
    
    @media (max-width: 600px) {
        .app-container { padding: 20px; margin-top: 10px; }
        h1 { font-size: 1.7em; margin-bottom: 20px; }
        .checkbox-container { font-size: 1.3em; margin-right: 12px; width: 25px; }
        .task-text { font-size: 0.95em; }
        li { padding: 12px 5px; }
        ul { margin-bottom: 70px; } /* More space for button on small screens */
        .add-task-btn { font-size: 0.9em; padding: 8px 15px; }
    }
</style>
</head>
<body>
    <div class="app-container">
        <h1>Amanda's Tasks</h1>
        <ul id="taskListAmanda">
            <!-- Tasks will be rendered here by JavaScript -->
        </ul>
        <button class="add-task-btn" id="addTaskBtnAmanda">
            <i class="fas fa-plus"></i> Add Task
        </button>
    </div>

<script>
    (function() {
        const STORAGE_KEY_AMANDA = 'amandaTasks_v2_storage';
        const initialDefaultAmandaTasks = [
            { id: 'amanda-task-1', text: "ðŸ‘• Put rest of my clothes in bins", status: 0 },
            { id: 'amanda-task-2', text: "ðŸ‘Ÿ Put my shoes in closet", status: 0 },
            { id: 'amanda-task-3', text: "ðŸ‘§ Put away girlsâ€™ old shoes (attic box)", status: 0 },
            { id: 'amanda-task-4', text: "ðŸ§º Put away all my clean clothes", status: 0 },
            { id: 'amanda-task-5', text: "ðŸ›ï¸ Tidy our room â€“ bench, sheets (Sterling will help)", status: 0 },
            { id: 'amanda-task-6', text: "ðŸ§¼ Clean our closet dresser top", status: 0 },
            { id: 'amanda-task-7', text: "ðŸ› Clean bathroom countertop", status: 0 }
        ];
        let currentAmandaTasks;
        let isEditMode = false;
        let longPressTimer;
        const LONG_PRESS_DURATION = 1000; // 1 second
        let draggedItemId = null;

        const appContainer = document.querySelector('.app-container');
        const taskListElement = document.getElementById('taskListAmanda');
        const addTaskButton = document.getElementById('addTaskBtnAmanda');
        const pastelColorClasses = ['pastel-bg-1', 'pastel-bg-2', 'pastel-bg-3', 'pastel-bg-4'];


        function generateUniqueId(prefix = 'task') {
            return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        }

        function loadTasksFromStorage() {
            try {
                const storedTasks = localStorage.getItem(STORAGE_KEY_AMANDA);
                if (storedTasks) {
                    const parsedTasks = JSON.parse(storedTasks);
                    if (Array.isArray(parsedTasks) &&
                        (parsedTasks.length === 0 || (typeof parsedTasks[0].id !== 'undefined' && typeof parsedTasks[0].status !== 'undefined'))) {
                        currentAmandaTasks = parsedTasks;
                        return;
                    } else {
                        console.warn(`Invalid data in localStorage for ${STORAGE_KEY_AMANDA}, falling back to defaults.`);
                    }
                }
            } catch (error) {
                console.error(`Error loading tasks from localStorage for ${STORAGE_KEY_AMANDA}:`, error);
            }
            currentAmandaTasks = initialDefaultAmandaTasks.map(task => ({ ...task }));
        }

        function saveTasksToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY_AMANDA, JSON.stringify(currentAmandaTasks));
            } catch (error) {
                console.error(`Error saving tasks to localStorage for ${STORAGE_KEY_AMANDA}:`, error);
            }
        }

        function renderTasks() {
            taskListElement.innerHTML = '';
            let completedTaskCounter = 0;
            
            currentAmandaTasks.forEach((task) => {
                const listItem = document.createElement('li');
                listItem.setAttribute('data-id', task.id);
                listItem.className = `status-${task.status}`;
                if (isEditMode) {
                    listItem.classList.add('edit-mode-item');
                }

                if (task.status === 2) {
                    const pastelClass = pastelColorClasses[completedTaskCounter % pastelColorClasses.length];
                    listItem.classList.add(pastelClass);
                    completedTaskCounter++;
                }

                const checkboxContainer = document.createElement('span');
                checkboxContainer.className = `checkbox-container status-${task.status}`;
                checkboxContainer.innerHTML = `
                    <i class="far fa-square"></i>
                    <i class="fas fa-circle-half-stroke"></i>
                    <i class="far fa-check-square"></i>
                `;
                if (!isEditMode) { // Checkbox only interactive if not in edit mode
                    checkboxContainer.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleTaskStatus(task.id);
                    });
                }


                const taskTextElement = document.createElement('span');
                taskTextElement.classList.add('task-text');
                taskTextElement.textContent = task.text;

                if (isEditMode) {
                    taskTextElement.title = "Click to edit task text";
                    taskTextElement.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent triggering other li listeners
                        makeTaskEditable(task.id, listItem);
                    });
                    listItem.draggable = true;
                    listItem.addEventListener('dragstart', (e) => handleDragStart(e, task.id));
                    listItem.addEventListener('dragover', handleDragOver);
                    listItem.addEventListener('drop', (e) => handleDrop(e, listItem));
                    listItem.addEventListener('dragend', handleDragEnd);
                } else {
                    taskTextElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleTaskStatus(task.id);
                    });
                    // Long press listeners only if not in edit mode
                    let pressStartX, pressStartY;
                    listItem.addEventListener('mousedown', (e) => {
                        if (e.button !== 0 || isEditMode || listItem.querySelector('input.task-edit-input')) return;
                        pressStartX = e.clientX;
                        pressStartY = e.clientY;
                        clearTimeout(longPressTimer); // Clear any existing timer
                        longPressTimer = setTimeout(() => {
                             if (document.querySelector('.task-edit-input:focus')) return;
                            enterEditMode(task.id);
                        }, LONG_PRESS_DURATION);
                    });
                    const clearLongPress = () => clearTimeout(longPressTimer);
                    listItem.addEventListener('mouseup', clearLongPress);
                    listItem.addEventListener('mouseleave', clearLongPress);
                    listItem.addEventListener('mousemove', (e) => {
                        if (Math.abs(e.clientX - pressStartX) > 5 || Math.abs(e.clientY - pressStartY) > 5) {
                            clearTimeout(longPressTimer);
                        }
                    });
                }

                listItem.appendChild(checkboxContainer);
                listItem.appendChild(taskTextElement);
                taskListElement.appendChild(listItem);
            });
        }

        function makeTaskEditable(taskId, listItemElement) {
            const task = currentAmandaTasks.find(t => t.id === taskId);
            const taskTextSpan = listItemElement.querySelector('.task-text');
            if (!task || !taskTextSpan || listItemElement.querySelector('input.task-edit-input')) return;

            // If another input is already active, blur it first
            const otherActiveInput = taskListElement.querySelector('input.task-edit-input');
            if (otherActiveInput && otherActiveInput !== taskTextSpan) {
                otherActiveInput.blur();
            }

            const input = document.createElement('input');
            input.type = 'text';
            input.value = task.text;
            input.className = 'task-edit-input';
            
            const saveChanges = () => {
                const newText = input.value.trim();
                if (newText && newText !== task.text) {
                    task.text = newText;
                    saveTasksToStorage();
                }
                // Replace input with span - renderTasks will do this fully,
                // but for immediate feedback if not re-rendering everything:
                if (isEditMode && listItemElement.contains(input)) { // Check if still in edit mode and input is there
                     renderTasks(); // Re-render to reflect changes and maintain edit mode UI
                }
            };

            input.addEventListener('blur', saveChanges);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                } else if (e.key === 'Escape') {
                    input.value = task.text; // Revert
                    input.blur();
                }
            });

            taskTextSpan.replaceWith(input);
            input.focus();
            input.select();
        }


        function toggleTaskStatus(taskId) {
            if (isEditMode) return; // Don't toggle status in edit mode
            const task = currentAmandaTasks.find(t => t.id === taskId);
            if (task) {
                task.status = (task.status + 1) % 3;
                saveTasksToStorage();
                renderTasks(); // Re-render to apply new styles and pastel logic
            }
        }

        function enterEditMode(initiatingTaskId = null) {
            if (isEditMode) return;
            isEditMode = true;
            appContainer.classList.add('edit-mode');
            console.log("Entered Edit Mode");
            renderTasks(); 
            // If a specific task initiated edit mode, and we want to auto-edit it:
            if (initiatingTaskId) {
                 const itemToEditLi = taskListElement.querySelector(`li[data-id="${initiatingTaskId}"]`);
                 if (itemToEditLi) {
                    //  setTimeout(() => makeTaskEditable(initiatingTaskId, itemToEditLi), 50); // Small delay
                 }
            }
        }

        function exitEditMode() {
            if (!isEditMode) return;
            
            const activeInput = taskListElement.querySelector('input.task-edit-input:focus');
            if (activeInput) {
                activeInput.blur(); // This will trigger save and its own render
                // We need to ensure the final state is non-edit mode
                isEditMode = false; // Set before the final render
                appContainer.classList.remove('edit-mode');
                saveTasksToStorage(); 
                renderTasks(); // Final render for exiting
                return;
            }

            isEditMode = false;
            appContainer.classList.remove('edit-mode');
            console.log("Exited Edit Mode");
            saveTasksToStorage(); // Save any reordering
            renderTasks();
        }

        function addNewTask() {
            if (!isEditMode) return;
            const newText = "New Task...";
            const newTask = {
                id: generateUniqueId('amanda-task'),
                text: newText,
                status: 0
            };
            currentAmandaTasks.push(newTask);
            saveTasksToStorage();
            renderTasks(); 

            const newListItem = taskListElement.querySelector(`li[data-id="${newTask.id}"]`);
            if (newListItem) {
                setTimeout(() => makeTaskEditable(newTask.id, newListItem), 0);
            }
        }

        // Drag and Drop Handlers
        function handleDragStart(event, taskId) {
            draggedItemId = taskId;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', taskId);
            event.currentTarget.classList.add('dragging');
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            const targetLi = event.target.closest('li');
            if (targetLi && targetLi.dataset.id !== draggedItemId) {
                // Basic visual cue (can be enhanced)
                document.querySelectorAll('.drag-over-target').forEach(el => el.classList.remove('drag-over-target'));
                targetLi.classList.add('drag-over-target');
            }
        }

        function handleDrop(event, targetListItem) {
            event.preventDefault();
            const droppedOnItemId = targetListItem.dataset.id;
            if (!draggedItemId || draggedItemId === droppedOnItemId) {
                 document.querySelectorAll('.drag-over-target').forEach(el => el.classList.remove('drag-over-target'));
                return;
            }

            const draggedItemIndex = currentAmandaTasks.findIndex(t => t.id === draggedItemId);
            let targetItemIndex = currentAmandaTasks.findIndex(t => t.id === droppedOnItemId);

            if (draggedItemIndex === -1 || targetItemIndex === -1) return;

            const [draggedItem] = currentAmandaTasks.splice(draggedItemIndex, 1);

            // Adjust target index if the dragged item was before the target
            if (draggedItemIndex < targetItemIndex) {
                targetItemIndex--;
            }
            
            // Determine if dropping before or after the target based on mouse position
            const rect = targetListItem.getBoundingClientRect();
            const isDroppingBefore = event.clientY < rect.top + rect.height / 2;

            if (isDroppingBefore) {
                currentAmandaTasks.splice(targetItemIndex, 0, draggedItem);
            } else {
                currentAmandaTasks.splice(targetItemIndex + 1, 0, draggedItem);
            }
            
            draggedItemId = null;
            saveTasksToStorage();
            renderTasks(); // Re-render to reflect new order in edit mode
        }

        function handleDragEnd(event) {
            event.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.drag-over-target').forEach(el => el.classList.remove('drag-over-target'));
            draggedItemId = null;
        }


        // Event Listeners
        addTaskButton.addEventListener('click', addNewTask);

        // Click outside to exit edit mode
        appContainer.addEventListener('click', (event) => {
            if (isEditMode) {
                // If the click is directly on appContainer's background (not on ul or add button)
                if (event.target === appContainer) {
                    exitEditMode();
                }
            }
        });


        document.addEventListener('DOMContentLoaded', () => {
            loadTasksFromStorage();
            renderTasks();
        });
    })();
</script>
</body>
</html>