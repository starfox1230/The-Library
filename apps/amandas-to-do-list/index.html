<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amanda's Tasks</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- SortableJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js" integrity="sha512-Eezs+g9Lq4TCCq0wae01s97wKye9gpASwl28OEYnlUPHZzPdiSbSKqck7VHCjwlgJrtIokUdsTEuaWiA8cnmA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<style>
    body {
        font-family: 'Poppins', sans-serif;
        background-color: #FFF0F5; /* LavenderBlush */
        margin: 0;
        padding: 20px;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        color: #6D4C41; /* Warm Dark Brown */
    }

    .app-container {
        background-color: #ffffff;
        padding: 30px;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(216, 139, 167, 0.15);
        width: 100%;
        max-width: 500px;
        position: relative;
    }

    h1 {
        color: #C2185B;
        text-align: center;
        margin-top: 0;
        margin-bottom: 30px;
        font-weight: 600;
        letter-spacing: 0.5px;
    }

    ul {
        list-style-type: none;
        padding: 0;
        margin: 0 0 60px 0;
    }

    li {
        display: flex;
        align-items: center;
        padding: 15px 5px;
        border-bottom: 1px solid #F8BBD0;
        transition: background-color 0.2s ease-in-out, border 0.2s ease-in-out;
        position: relative;
        -webkit-touch-callout: none;
    }

    li:last-child {
        border-bottom: none;
    }

    .checkbox-container {
        font-size: 1.5em;
        margin-right: 18px;
        cursor: pointer;
        width: 28px;
        text-align: center;
        transition: color 0.2s ease-in-out;
        flex-shrink: 0;
        color: #D7CCC8;
    }

    .task-text {
        flex-grow: 1;
        font-size: 1em;
        line-height: 1.5;
        transition: color 0.3s ease, text-decoration 0.3s ease;
        cursor: pointer;
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none;    /* Firefox */
        -ms-user-select: none;     /* IE10+/Edge */
        user-select: none;         /* Standard */
    }

    .task-edit-input {
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
        user-select: text !important;
        flex-grow: 1;
        font-family: 'Poppins', sans-serif;
        font-size: 1em;
        padding: 4px 6px;
        border: 1px solid #C2185B;
        border-radius: 4px;
        outline-color: #AD1457;
    }


    /* State Styles for Icons */
    .checkbox-container.status-0 .fa-square { display: inline-block; }
    .checkbox-container.status-0 .fa-circle-half-stroke,
    .checkbox-container.status-0 .fa-check-square { display: none; }

    .checkbox-container.status-1 { color: #FFB74D; }
    .checkbox-container.status-1 .fa-circle-half-stroke { display: inline-block; }
    .checkbox-container.status-1 .fa-square,
    .checkbox-container.status-1 .fa-check-square { display: none; }

    .checkbox-container.status-2 { color: #AED581; }
    .checkbox-container.status-2 .fa-check-square { display: inline-block; }
    .checkbox-container.status-2 .fa-square,
    .checkbox-container.status-2 .fa-circle-half-stroke { display: none; }

    /* State Styles for List Item & Text */
    li.status-1 .task-text { color: #8D6E63; }
    
    li.status-2 .task-text {
        text-decoration: line-through;
        color: #BCAAA4;
    }

    .pastel-bg-1 { background-color: #FFDFD3; } /* Pastel Peach */
    .pastel-bg-2 { background-color: #D4F0F0; } /* Pastel Mint */
    .pastel-bg-3 { background-color: #E6E0FF; } /* Pastel Lavender */
    .pastel-bg-4 { background-color: #FFFACD; } /* LemonChiffon */

    li.status-2.pastel-bg-1 .task-text,
    li.status-2.pastel-bg-2 .task-text,
    li.status-2.pastel-bg-3 .task-text,
    li.status-2.pastel-bg-4 .task-text {
        color: #6D4C41;
    }

    li:hover:not(.edit-mode-item):not(.sortable-chosen):not(.sortable-ghost) {
        background-color: #FFF8FA;
    }

    /* Edit Mode Styles */
    .app-container.edit-mode li {
        border: 1px dashed #E91E63;
        margin-bottom: -1px; /* Compensate for border */
        cursor: grab; /* Default cursor for draggable items */
    }
    .app-container.edit-mode li:active {
        cursor: grabbing;
    }
    .app-container.edit-mode .checkbox-container {
        cursor: default;
    }
     .app-container.edit-mode .task-text:not(input) { /* Apply to span, not input */
        cursor: text;
    }


    .add-task-btn {
        display: none;
        position: absolute;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background-color: #C2185B;
        color: white;
        border: none;
        border-radius: 8px;
        font-family: 'Poppins', sans-serif;
        font-size: 0.95em;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(194, 24, 91, 0.3);
        transition: background-color 0.2s ease;
    }
    .app-container.edit-mode .add-task-btn {
        display: block;
    }
    .add-task-btn:hover {
        background-color: #AD1457;
    }
    .add-task-btn i {
        margin-right: 8px;
    }

    .delete-task-btn {
        display: none; 
        color: #E91E63; 
        font-size: 1.1em; 
        margin-left: 12px; 
        padding: 3px 6px; 
        cursor: pointer;
        border-radius: 50%;
        transition: background-color 0.2s, color 0.2s;
        line-height: 1; 
        align-self: center; 
    }
    .app-container.edit-mode li .delete-task-btn {
        display: inline-flex; 
        align-items: center;
        justify-content: center;
    }
    .delete-task-btn:hover {
        background-color: #FCE4EC; 
        color: #C2185B; 
    }

    /* SortableJS Custom Styles (Optional) */
    .sortable-ghost { /* The placeholder for the item being dragged */
        opacity: 0.4;
        background-color: #FFECF0 !important; /* Light pinkish tint */
    }
    .sortable-chosen { /* The item being dragged */
        /* e.g., box-shadow: 0 0 10px rgba(0,0,0,0.2); */
    }
    .sortable-drag { /* Also the item being dragged, often same as chosen */
         /* opacity: 0.7; */
    }
    
    @media (max-width: 600px) {
        .app-container { padding: 20px; margin-top: 10px; }
        h1 { font-size: 1.7em; margin-bottom: 20px; }
        .checkbox-container { font-size: 1.3em; margin-right: 12px; width: 25px; }
        .task-text { font-size: 0.95em; }
        li { padding: 12px 5px; }
        ul { margin-bottom: 70px; }
        .add-task-btn { font-size: 0.9em; padding: 8px 15px; }
        .delete-task-btn { font-size: 1em; margin-left: 8px; }
    }
</style>
</head>
<body>
    <div class="app-container">
        <h1>Amanda's Tasks</h1>
        <ul id="taskListAmanda">
            <!-- Tasks will be rendered here by JavaScript -->
        </ul>
        <button class="add-task-btn" id="addTaskBtnAmanda">
            <i class="fas fa-plus"></i> Add Task
        </button>
    </div>

<script>
    (function() {
        const STORAGE_KEY_AMANDA = 'amandaTasks_v2_storage';
        const initialDefaultAmandaTasks = [
            { id: 'amanda-task-1', text: "ðŸ‘• Put rest of my clothes in bins", status: 0 },
            { id: 'amanda-task-2', text: "ðŸ‘Ÿ Put my shoes in closet", status: 0 },
            { id: 'amanda-task-3', text: "ðŸ‘§ Put away girlsâ€™ old shoes (attic box)", status: 0 },
            { id: 'amanda-task-4', text: "ðŸ§º Put away all my clean clothes", status: 0 },
            { id: 'amanda-task-5', text: "ðŸ›ï¸ Tidy our room â€“ bench, sheets (Sterling will help)", status: 0 },
            { id: 'amanda-task-6', text: "ðŸ§¼ Clean our closet dresser top", status: 0 },
            { id: 'amanda-task-7', text: "ðŸ› Clean bathroom countertop", status: 0 }
        ];
        let currentAmandaTasks;
        let isEditMode = false;
        let longPressTimer;
        const LONG_PRESS_DURATION = 1000; // 1 second
        let sortableInstance = null; 

        const appContainer = document.querySelector('.app-container');
        const taskListElement = document.getElementById('taskListAmanda');
        const addTaskButton = document.getElementById('addTaskBtnAmanda');
        const pastelColorClasses = ['pastel-bg-1', 'pastel-bg-2', 'pastel-bg-3', 'pastel-bg-4'];


        function generateUniqueId(prefix = 'task') {
            return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        }

        function loadTasksFromStorage() {
            try {
                const storedTasks = localStorage.getItem(STORAGE_KEY_AMANDA);
                if (storedTasks) {
                    const parsedTasks = JSON.parse(storedTasks);
                    if (Array.isArray(parsedTasks) &&
                        (parsedTasks.length === 0 || (typeof parsedTasks[0].id !== 'undefined' && typeof parsedTasks[0].status !== 'undefined'))) {
                        currentAmandaTasks = parsedTasks;
                        return;
                    }
                }
            } catch (error) { /* Fall through to defaults */ }
            currentAmandaTasks = initialDefaultAmandaTasks.map(task => ({ ...task }));
        }

        function saveTasksToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY_AMANDA, JSON.stringify(currentAmandaTasks));
            } catch (error) {
                console.error(`Error saving tasks to localStorage for ${STORAGE_KEY_AMANDA}:`, error);
            }
        }

        function renderTasks() {
            taskListElement.innerHTML = '';
            let completedTaskCounter = 0;
            
            currentAmandaTasks.forEach((task) => {
                const listItem = document.createElement('li');
                listItem.setAttribute('data-id', task.id); 
                listItem.className = `status-${task.status}`;
                if (isEditMode) {
                    listItem.classList.add('edit-mode-item');
                }

                if (task.status === 2) {
                    const pastelClass = pastelColorClasses[completedTaskCounter % pastelColorClasses.length];
                    listItem.classList.add(pastelClass);
                    completedTaskCounter++;
                }

                const checkboxContainer = document.createElement('span');
                checkboxContainer.className = `checkbox-container status-${task.status}`;
                checkboxContainer.innerHTML = `
                    <i class="far fa-square"></i>
                    <i class="fas fa-circle-half-stroke"></i>
                    <i class="far fa-check-square"></i>
                `;
                if (!isEditMode) {
                    checkboxContainer.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleTaskStatus(task.id);
                    });
                }

                const taskTextElement = document.createElement('span');
                taskTextElement.classList.add('task-text');
                taskTextElement.textContent = task.text;

                listItem.appendChild(checkboxContainer);
                listItem.appendChild(taskTextElement);

                if (isEditMode) {
                    taskTextElement.title = "Click to edit task text";
                    taskTextElement.addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        makeTaskEditable(task.id, listItem);
                    });
                    
                    const deleteButton = document.createElement('span');
                    deleteButton.className = 'delete-task-btn';
                    deleteButton.innerHTML = '<i class="fas fa-times"></i>';
                    deleteButton.title = "Delete task";
                    deleteButton.addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        deleteTask(task.id);
                    });
                    listItem.appendChild(deleteButton);

                } else { 
                    taskTextElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleTaskStatus(task.id);
                    });
                    
                    let pressStartX, pressStartY;
                    const handlePressStart = (e) => {
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        if ((e.type === "mousedown" && e.button !== 0) || isEditMode || listItem.querySelector('input.task-edit-input')) return;
                        pressStartX = clientX;
                        pressStartY = clientY;
                        clearTimeout(longPressTimer); 
                        longPressTimer = setTimeout(() => {
                             if (document.querySelector('.task-edit-input:focus')) return;
                            enterEditMode(task.id);
                        }, LONG_PRESS_DURATION);
                    };
                    const clearLongPress = () => clearTimeout(longPressTimer);
                    const handlePressMove = (e) => {
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        if (Math.abs(clientX - pressStartX) > 10 || Math.abs(clientY - pressStartY) > 10) {
                            clearTimeout(longPressTimer);
                        }
                    };
                    listItem.addEventListener('mousedown', handlePressStart);
                    listItem.addEventListener('mouseup', clearLongPress);
                    listItem.addEventListener('mouseleave', clearLongPress);
                    listItem.addEventListener('mousemove', handlePressMove);
                    listItem.addEventListener('touchstart', handlePressStart, { passive: true });
                    listItem.addEventListener('touchend', clearLongPress);
                    listItem.addEventListener('touchcancel', clearLongPress);
                    listItem.addEventListener('touchmove', handlePressMove, { passive: true });
                }
                
                taskListElement.appendChild(listItem);
            });
        }

        function makeTaskEditable(taskId, listItemElement) {
            const task = currentAmandaTasks.find(t => t.id === taskId);
             // Try to find the span, not an existing input.
            const taskTextSpan = listItemElement.querySelector('span.task-text');
            
            // If it's already an input, or no task/span, bail.
            if (!task || !taskTextSpan || listItemElement.querySelector('input.task-edit-input')) return;


            const otherActiveInput = taskListElement.querySelector('input.task-edit-input');
            if (otherActiveInput) { 
                if (otherActiveInput.closest('li') !== listItemElement) {
                    otherActiveInput.blur(); 
                } else {
                    return; 
                }
            }
            
            const currentTaskTextSpanToReplace = listItemElement.querySelector('span.task-text'); // Re-query after potential blur
            if (!currentTaskTextSpanToReplace || currentTaskTextSpanToReplace.tagName === 'INPUT') return;


            const input = document.createElement('input');
            input.type = 'text';
            input.value = task.text;
            input.className = 'task-edit-input';
            
            const saveChanges = () => {
                const newText = input.value.trim();
                if (newText && newText !== task.text) {
                    task.text = newText;
                }
                saveTasksToStorage();
                // Only re-render if still in edit mode and the input *was* part of this list item.
                // This check is a bit tricky if the item itself was removed by another action.
                // A safer check is simply `if (isEditMode)` and rely on `renderTasks` to handle item presence.
                if (isEditMode && document.body.contains(input)) { 
                     renderTasks();
                } else if (isEditMode && !document.body.contains(input)) {
                    // If input is no longer in DOM (e.g., due to sort or delete), just ensure list is current
                    renderTasks();
                }
            };

            input.addEventListener('blur', saveChanges);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                } else if (e.key === 'Escape') {
                    input.value = task.text; 
                    input.blur();
                }
            });

            currentTaskTextSpanToReplace.replaceWith(input);
            input.focus();
            input.select();
        }

        function toggleTaskStatus(taskId) {
            if (isEditMode) return; 
            const task = currentAmandaTasks.find(t => t.id === taskId);
            if (task) {
                task.status = (task.status + 1) % 3;
                saveTasksToStorage();
                renderTasks(); 
            }
        }

        function deleteTask(taskId) {
            currentAmandaTasks = currentAmandaTasks.filter(t => t.id !== taskId);
            saveTasksToStorage();
            renderTasks(); 
        }

        function enterEditMode(initiatingTaskId = null) {
            if (isEditMode) return;
            isEditMode = true;
            appContainer.classList.add('edit-mode');
            renderTasks(); 
            
            if (sortableInstance) sortableInstance.destroy(); 
            
            sortableInstance = new Sortable(taskListElement, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                chosenClass: 'sortable-chosen',
                dragClass: 'sortable-drag',
                filter: '.task-edit-input, .delete-task-btn, .checkbox-container', 
                preventOnFilter: true, 
                onEnd: function (evt) {
                    if (evt.oldIndex === evt.newIndex) return;

                    const activeEditInput = taskListElement.querySelector('input.task-edit-input');
                    if (activeEditInput) {
                        // Temporarily remove blur listener to prevent double save/render
                        // This is a common pattern but can be tricky.
                        // A simpler way is to just grab the value and update data model.
                        const inputListItem = activeEditInput.closest('li');
                        if (inputListItem) {
                            const inputTaskId = inputListItem.dataset.id;
                            const taskBeingEdited = currentAmandaTasks.find(t => t.id === inputTaskId);
                            if (taskBeingEdited) {
                                const newText = activeEditInput.value.trim();
                                if (newText) { // Allow empty text to be saved if intended, or add validation
                                    taskBeingEdited.text = newText;
                                }
                            }
                        }
                        // No need to call activeEditInput.blur() here as renderTasks() will redraw.
                    }

                    const movedItem = currentAmandaTasks.splice(evt.oldIndex, 1)[0];
                    currentAmandaTasks.splice(evt.newIndex, 0, movedItem);
                    
                    saveTasksToStorage();
                    renderTasks(); // Re-render to reflect new order and clean up (e.g., remove input)
                }
            });
            console.log("Entered Edit Mode, SortableJS initialized.");
        }

        function exitEditMode() {
            if (!isEditMode) return;
            
            const activeInput = taskListElement.querySelector('input.task-edit-input');
            if (activeInput) {
                // Call blur to trigger its saveChanges logic, which includes a render
                activeInput.blur(); 
                // If blur itself caused a render, the DOM might be different.
                // However, the subsequent steps should handle it.
            }

            if (sortableInstance) {
                sortableInstance.destroy();
                sortableInstance = null;
                console.log("SortableJS destroyed.");
            }

            isEditMode = false;
            appContainer.classList.remove('edit-mode');
            // Save tasks just in case, though activeInput.blur() or onEnd should have done it.
            saveTasksToStorage(); 
            renderTasks(); // Ensure final render in non-edit mode state.
            console.log("Exited Edit Mode");
        }

        function addNewTask() {
            if (!isEditMode) return;
            
            const otherActiveInput = taskListElement.querySelector('input.task-edit-input');
            if (otherActiveInput) {
                otherActiveInput.blur(); // This will save and might re-render.
                                        // The timeout for makeTaskEditable helps here.
            }

            const newText = "New Task";
            const newTask = {
                id: generateUniqueId('amanda-task'),
                text: newText,
                status: 0
            };
            currentAmandaTasks.push(newTask);
            saveTasksToStorage();
            renderTasks(); 

            const newListItem = taskListElement.querySelector(`li[data-id="${newTask.id}"]`);
            if (newListItem) {
                setTimeout(() => makeTaskEditable(newTask.id, newListItem), 0);
            }
        }

        addTaskButton.addEventListener('click', addNewTask);

        appContainer.addEventListener('click', (event) => {
            if (isEditMode) {
                if (event.target === appContainer) {
                    exitEditMode();
                }
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            loadTasksFromStorage();
            renderTasks();
        });
    })();
</script>
</body>
</html>