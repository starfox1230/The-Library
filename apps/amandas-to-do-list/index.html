<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="format-detection" content="telephone=no">
  <title>Amanda's Tasks</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  />

  <style>
    html, body, button, input, textarea {
      touch-action: manipulation;
    }
    li, .drag-handle-amanda {
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      user-select: none !important;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Poppins', sans-serif;
      background-color: #FFF0F5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      color: #6D4C41;
      padding: 20px;
    }
    .app-container {
      position: relative;
      background-color: #fff;
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(216, 139, 167, 0.15);
      max-width: 500px;
      width: 100%;
    }
    h1 {
      text-align: center;
      color: #C2185B;
      margin-bottom: 20px;
      font-weight: 600;
      letter-spacing: .5px;
    }
    /* .toggle-edit-btn { ... CSS for removed button ... } */
    ul#taskListAmanda {
      list-style: none;
      margin: 0 0 20px; /* Adjusted margin if Add Task button is always at bottom */
      padding: 0;
      min-height: 50px; /* Ensure there's area to tap/long-press if list is empty */
    }
    li {
      display: flex;
      align-items: center;
      padding: 15px 5px;
      border-bottom: 1px solid #F8BBD0;
      transition: background .2s, border .2s, opacity .2s;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    li:last-child { border-bottom: none; }

    .drag-handle-amanda {
      display: none;
      cursor: grab;
      margin-right: 10px;
      font-size: 1.2em;
      color: #AD1457;
      padding: 5px;
      touch-action: none;
    }
    .app-container.edit-mode li .drag-handle-amanda {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .app-container.edit-mode li .drag-handle-amanda:active { cursor: grabbing; }

    .checkbox-container {
      flex-shrink: 0;
      width: 28px;
      text-align: center;
      margin-right: 18px;
      font-size: 1.5em;
      color: #D7CCC8;
      cursor: pointer;
      transition: color .2s;
    }
    .checkbox-container.status-0 .fa-square { display: inline-block; }
    .checkbox-container.status-0 .fa-circle-half-stroke,
    .checkbox-container.status-0 .fa-check-square { display: none; }
    .checkbox-container.status-1 { color: #FFB74D; }
    .checkbox-container.status-1 .fa-circle-half-stroke { display: inline-block; }
    .checkbox-container.status-1 .fa-square,
    .checkbox-container.status-1 .fa-check-square { display: none; }
    .checkbox-container.status-2 { color: #AED581; }
    .checkbox-container.status-2 .fa-check-square { display: inline-block; }
    .checkbox-container.status-2 .fa-square,
    .checkbox-container.status-2 .fa-circle-half-stroke { display: none; }

    .task-text {
      flex-grow: 1;
      cursor: pointer;
      transition: color .3s, text-decoration .3s;
      word-break: break-word;
    }
    li.status-1 .task-text { color: #8D6E63; }
    li.status-2 .task-text {
      text-decoration: line-through;
      color: #BCAAA4;
    }
    .pastel-bg-1 { background: #FFDFD3; }
    .pastel-bg-2 { background: #D4F0F0; }
    .pastel-bg-3 { background: #E6E0FF; }
    .pastel-bg-4 { background: #FFFACD; }
    li.status-2.pastel-bg-1 .task-text,
    li.status-2.pastel-bg-2 .task-text,
    li.status-2.pastel-bg-3 .task-text,
    li.status-2.pastel-bg-4 .task-text { color: #6D4C41; }

    .app-container.edit-mode .checkbox-container { cursor: default; }
    .app-container.edit-mode .task-text { cursor: text; }

    .add-task-btn {
      display: none; /* Initially hidden */
      margin: 20px auto 0; /* Center it below the list */
      background: #C2185B;
      color: #fff;
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(194, 24, 91, 0.3);
    }
    .add-task-btn i { margin-right: 8px; }
    .app-container.edit-mode .add-task-btn { display: block; } /* Show in edit mode */
    .add-task-btn:hover { background: #AD1457; }

    .delete-task-btn {
      display: none;
      color: #E91E63;
      font-size: 1.1em;
      margin-left: 12px;
      padding: 3px 6px;
      cursor: pointer;
      border-radius: 50%;
      transition: background .2s, color .2s;
      flex-shrink: 0;
    }
    .app-container.edit-mode li .delete-task-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .delete-task-btn:hover { background: #FCE4EC; color: #C2185B; }

    .task-edit-input {
        flex-grow: 1;
        padding: 5px;
        border: 1px solid #C2185B;
        border-radius: 4px;
        font-family: 'Poppins', sans-serif;
        font-size: inherit;
        color: #6D4C41;
    }

    li.dragging {
        opacity: 0.6;
        background: #FFECF0 !important;
        box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    .drag-over-placeholder-amanda {
        height: 60px;
        background-color: rgba(248, 187, 208, 0.2);
        border: 2px dashed #C2185B;
        border-radius: 8px;
        margin: 5px 0 5px 0;
        box-sizing: border-box;
        display: block;
        list-style-type: none;
    }

    @media (max-width: 600px) {
      h1 { font-size: 1.7em; margin-bottom: 20px; }
      .checkbox-container { width: 25px; margin-right: 12px; font-size: 1.3em; }
      .task-text { font-size: .95em; }
      li { padding: 12px 5px; }
      .add-task-btn { font-size: .9em; padding: 8px 15px; }
      .delete-task-btn { font-size: 1em; margin-left: 8px; }
      .drag-over-placeholder-amanda { height: 55px; }
      ul#taskListAmanda { min-height: 40px; }
    }
  </style>

  <script>
    // Simplified double-tap prevention, can be removed if not strictly needed or causing issues.
    // let lastTouchEnd = 0;
    // document.addEventListener('touchend', e => {
    //   const now = Date.now();
    //   if (now - lastTouchEnd <= 300 && !['INPUT', 'TEXTAREA', 'BUTTON', 'SUMMARY'].includes(e.target.tagName)) {
    //     // e.preventDefault(); // Be cautious with this
    //   }
    //   lastTouchEnd = now;
    // }, { passive: false });
  </script>
</head>

<body>
  <div class="app-container">
    <h1>Amanda's Tasks</h1>
    <!-- Edit button removed -->
    <ul id="taskListAmanda"></ul>
    <button id="addTaskBtnAmanda" class="add-task-btn">
      <i class="fas fa-plus"></i> Add Task
    </button>
  </div>

  <script>
  (function(){
    const STORAGE_KEY = 'amandaTasks_v4_longpress';
    const defaults = [ /* ... your defaults ... */ ];
    let tasks = [], isEditMode = false;
    let draggedItem = null;
    let amandaPlaceholder = null;

    // NEW: Long press variables
    let longPressTimer = null;
    const LONG_PRESS_DURATION = 750; // 0.75 seconds
    let pressStartX, pressStartY; // To detect movement for cancelling long press

    const pastel = ['pastel-bg-1','pastel-bg-2','pastel-bg-3','pastel-bg-4'];
    const listEl = document.getElementById('taskListAmanda'),
          addBtn = document.getElementById('addTaskBtnAmanda'),
          appContainer = document.querySelector('.app-container');

    function genId(){ /* ... */ return 'task-'+Date.now()+'-'+Math.random().toString(36).slice(2,9); }
    function load(){
      try {
        const arr = JSON.parse(localStorage.getItem(STORAGE_KEY));
        if (Array.isArray(arr) && arr.length > 0) tasks = arr;
        else throw 0;
      } catch {
        tasks = defaults.map(t=>({...t, id: t.id || genId()}));
      }
    }
    function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks)); }
    function updateTasksOrderFromDOM() { /* ... */ 
        const orderedTasks = [];
        const itemElements = listEl.querySelectorAll('li[data-id]');
        itemElements.forEach(itemEl => {
            const taskId = itemEl.dataset.id;
            const task = tasks.find(t => t.id === taskId);
            if (task) orderedTasks.push(task);
        });
        tasks = orderedTasks;
    }
    function createAmandaPlaceholder() { /* ... */ 
        if (!amandaPlaceholder) {
            amandaPlaceholder = document.createElement('li');
            amandaPlaceholder.className = 'drag-over-placeholder-amanda';
        }
        return amandaPlaceholder;
    }
    function getDragAfterElementAmanda(container, y) { /* ... */ 
        const draggableElements = [...container.querySelectorAll('li[data-id]:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else { return closest; }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function render(){
      listEl.innerHTML = '';
      let doneCount = 0;
      tasks.forEach(t => {
        const li = document.createElement('li');
        li.dataset.id = t.id;
        li.className = `status-${t.status}`;
        if (t.status === 2) li.classList.add(pastel[doneCount++ % pastel.length]);

        const chk = document.createElement('span');
        chk.className = `checkbox-container status-${t.status}`;
        chk.innerHTML = '<i class="far fa-square"></i><i class="fas fa-circle-half-stroke"></i><i class="far fa-check-square"></i>';
        if(!isEditMode) {
            chk.addEventListener('click',()=>{ t.status=(t.status+1)%3; save(); render(); });
        }
        
        const txt = document.createElement('span');
        txt.className='task-text';
        txt.textContent = t.text;
        if(isEditMode){
          txt.title='Click to edit';
          txt.addEventListener('click', (e) => { e.stopPropagation(); editText(t.id,li); });
        } else {
          txt.addEventListener('click',()=>{ t.status=(t.status+1)%3; save(); render(); });
        }
        
        if(isEditMode){
          li.setAttribute('draggable', 'true');
          const h = document.createElement('span');
          h.className='drag-handle-amanda';
          h.innerHTML='<i class="fas fa-grip-vertical"></i>';
          li.addEventListener('dragstart', handleLiDragStart);
          li.addEventListener('dragend', handleLiDragEnd);
          h.addEventListener('touchstart', handleTouchDragStartOnHandle, { passive: true });
          li.appendChild(h);
        } else {
            li.removeAttribute('draggable');
        }
        
        li.appendChild(chk);
        li.appendChild(txt);

        if(isEditMode){
          const del = document.createElement('span');
          del.className='delete-task-btn';
          del.innerHTML='<i class="fas fa-times"></i>';
          del.title='Delete';
          del.addEventListener('click',(e)=>{
            e.stopPropagation();
            tasks = tasks.filter(x=>x.id!==t.id);
            save(); render();
          });
          li.appendChild(del);
        }
        listEl.appendChild(li);
      });
    }

    function editText(id, li){ /* ... */ 
        const t = tasks.find(x=>x.id===id), span = li.querySelector('.task-text');
        if(!t||!span || li.querySelector('.task-edit-input')) return;
        const inp = document.createElement('input');
        inp.type='text'; inp.value=t.text; inp.className='task-edit-input';
        inp.style.flexGrow = '1';
        const finishEdit = () => {
            const v=inp.value.trim(); if(v) t.text=v;
            save(); render();
        };
        inp.addEventListener('blur', finishEdit);
        inp.addEventListener('keydown',e=>{
            if(e.key==='Enter'){ e.preventDefault(); inp.blur(); }
            if(e.key==='Escape'){ inp.value=t.text; inp.blur(); }
        });
        span.replaceWith(inp); inp.focus(); inp.select();
    }

    function enterEditMode(){
      if (isEditMode) return; // Already in edit mode
      isEditMode=true;
      appContainer.classList.add('edit-mode');
      render(); // Re-render to add drag handles, delete buttons, show Add Task btn
      // Add listeners to exit edit mode
      document.addEventListener('click', handleClickOutsideToExit, true); // Capture phase
      document.addEventListener('touchend', handleClickOutsideToExit, true); // Capture phase
    }

    function exitEditMode(){
      if (!isEditMode) return; // Not in edit mode
      isEditMode=false;
      appContainer.classList.remove('edit-mode');
      
      if (draggedItem) {
          draggedItem.classList.remove('dragging');
          draggedItem = null;
      }
      if (amandaPlaceholder && amandaPlaceholder.parentNode) {
          amandaPlaceholder.remove();
          // amandaPlaceholder = null; // createAmandaPlaceholder will re-create if needed
      }

      updateTasksOrderFromDOM();
      save();
      render(); // Re-render in non-edit mode
      // Remove listeners to exit edit mode
      document.removeEventListener('click', handleClickOutsideToExit, true);
      document.removeEventListener('touchend', handleClickOutsideToExit, true);
    }
    
    // NEW: Listener for tap outside to exit edit mode
    function handleClickOutsideToExit(event) {
        if (!isEditMode) return;

        const clickedOnTaskItem = event.target.closest('#taskListAmanda li[data-id]');
        const clickedOnAddTaskBtn = event.target.closest('#addTaskBtnAmanda');

        // If the click was NOT on a task item AND NOT on the "Add Task" button, then exit.
        if (!clickedOnTaskItem && !clickedOnAddTaskBtn) {
            // Check if the click is within the app container but not on interactive elements,
            // or completely outside the app container (though a click there might not be intended for this app).
            // For simplicity, any click not on a task or add button will exit.
            exitEditMode();
        }
    }


    function addTask(){
      if(!isEditMode) return; // Should not happen if button is only visible in edit mode
      const newT={ id:genId(), text:'New Task', status:0 };
      tasks.push(newT);
      save();
      render(); 
      const li = listEl.querySelector(`li[data-id="${newT.id}"]`);
      if(li) editText(newT.id, li);
    }

    // Removed toggleBtn event listener

    addBtn.addEventListener('click', addTask);

    // --- DRAG AND DROP EVENT HANDLERS ---
    function handleLiDragStart(e) { /* ... */ 
        if (!isEditMode) { e.preventDefault(); return; }
        const targetTagName = e.target.tagName.toLowerCase();
        if (e.target.classList.contains('task-edit-input') ||
            e.target.closest('.delete-task-btn') ||
            e.target.closest('.checkbox-container') ||
            targetTagName === 'input' || targetTagName === 'button' ||
            (e.target.closest('.task-text') && this.querySelector('.task-edit-input'))
           ) { e.preventDefault(); return; }
        draggedItem = this;
        try { e.dataTransfer.setData('text/plain', ''); } catch(err) {}
        e.dataTransfer.effectAllowed = 'move';
        setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0);
    }
    function handleLiDragEnd() { /* ... */ 
        if (this.classList.contains('dragging')) this.classList.remove('dragging');
        if (amandaPlaceholder && amandaPlaceholder.parentNode) amandaPlaceholder.remove();
        if (draggedItem) { updateTasksOrderFromDOM(); save(); }
        draggedItem = null;
    }
    function handleTouchDragStartOnHandle(e) { /* ... */ 
        if (!isEditMode) return;
        const listItem = e.currentTarget.closest('li');
        if (!listItem) return;
        draggedItem = listItem; // Dragging class added on first touchmove
    }
    function handleDragOverOrMove(e) { /* ... */ 
        if (!draggedItem || !isEditMode) return;
        if (e.type === 'touchmove' && !draggedItem.classList.contains('dragging')) {
            draggedItem.classList.add('dragging');
        }
        e.preventDefault();
        const currentY = e.clientY || (e.touches && e.touches[0].clientY);
        if (currentY === undefined) return;
        const ph = createAmandaPlaceholder();
        const afterElement = getDragAfterElementAmanda(listEl, currentY);
        if (draggedItem.contains(ph)) return;
        if (afterElement == null) { if (listEl.lastChild !== ph) listEl.appendChild(ph); }
        else { if (afterElement !== ph && afterElement.previousSibling !== ph) listEl.insertBefore(ph, afterElement); }
    }
    listEl.addEventListener('dragover', handleDragOverOrMove);
    listEl.addEventListener('touchmove', (e) => {
        if (!draggedItem || !isEditMode) return;
        // If long press timer is active, clear it because user is scrolling/dragging
        if (longPressTimer) clearTimeout(longPressTimer);
        e.preventDefault();
        handleDragOverOrMove(e);
    }, { passive: false });
    listEl.addEventListener('drop', (e) => { /* ... */ 
        if (!draggedItem || !isEditMode) return;
        e.preventDefault();
        if (amandaPlaceholder && amandaPlaceholder.parentNode === listEl) {
            listEl.insertBefore(draggedItem, amandaPlaceholder);
        }
    });
    document.addEventListener('touchend', (e) => { // Global touchend for drag
        if (!draggedItem || !isEditMode || !draggedItem.classList.contains('dragging')) {
            if (draggedItem && !draggedItem.classList.contains('dragging')) draggedItem = null; // Was a tap not a drag
            return;
        }
        if (amandaPlaceholder && amandaPlaceholder.parentNode === listEl) {
            listEl.insertBefore(draggedItem, amandaPlaceholder);
            amandaPlaceholder.remove(); 
        }
        draggedItem.classList.remove('dragging');
        updateTasksOrderFromDOM();
        save();
        draggedItem = null;
    });

    // --- LONG PRESS EVENT HANDLERS ---
    function handlePressStart(e) {
        if (isEditMode) return; // Don't trigger long press if already in edit mode
        // Prevent starting long press if target is an interactive element INSIDE a list item
        // (though list items themselves are not interactive in non-edit mode for press start)
        if (e.target.closest('li[data-id] .checkbox-container') || e.target.closest('li[data-id] .task-text')) {
             // If in future list items are interactive in non-edit mode, this check is useful
            return;
        }

        clearTimeout(longPressTimer); // Clear any existing timer

        if (e.type === 'touchstart') {
            pressStartX = e.touches[0].clientX;
            pressStartY = e.touches[0].clientY;
        } else {
            pressStartX = e.clientX;
            pressStartY = e.clientY;
        }

        longPressTimer = setTimeout(() => {
            // Check if it was a real long press (not a click that just took a while)
            // For simplicity, we'll just trigger. More complex logic could check if mouse/finger is still down.
            enterEditMode();
        }, LONG_PRESS_DURATION);
    }

    function handlePressMove(e) {
        if (longPressTimer) {
            let currentX, currentY;
            if (e.type === 'touchmove') {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
            } else {
                currentX = e.clientX;
                currentY = e.clientY;
            }
            // If moved more than a few pixels, cancel long press (it's a scroll/drag)
            if (Math.abs(currentX - pressStartX) > 10 || Math.abs(currentY - pressStartY) > 10) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
        }
    }

    function handlePressEnd() {
        clearTimeout(longPressTimer);
        longPressTimer = null;
    }

    listEl.addEventListener('mousedown', handlePressStart);
    listEl.addEventListener('touchstart', handlePressStart, { passive: true }); // passive true for scroll perf initially

    listEl.addEventListener('mousemove', handlePressMove);
    // listEl.addEventListener('touchmove', handlePressMove); // Already handled by global touchmove for drag

    listEl.addEventListener('mouseup', handlePressEnd);
    listEl.addEventListener('mouseleave', handlePressEnd); // If mouse leaves element
    // Global touchend for drag also effectively handles press end for touch.
    // We can add a specific one for the list element for clarity if needed for touchcancel or other scenarios.
    listEl.addEventListener('touchend', handlePressEnd);
    listEl.addEventListener('touchcancel', handlePressEnd);


    document.addEventListener('DOMContentLoaded',()=>{
      load(); 
      render();
    });
  })();
  </script>
</body>
</html>