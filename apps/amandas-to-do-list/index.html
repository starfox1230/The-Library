<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amanda's Tasks</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<style>
    body {
        font-family: 'Poppins', sans-serif;
        background-color: #FFF0F5; /* LavenderBlush */
        margin: 0;
        padding: 20px;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        color: #6D4C41; /* Warm Dark Brown */
    }

    .app-container {
        background-color: #ffffff;
        padding: 30px;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(216, 139, 167, 0.15);
        width: 100%;
        max-width: 500px;
        position: relative;
    }

    h1 {
        color: #C2185B;
        text-align: center;
        margin-top: 0;
        margin-bottom: 30px;
        font-weight: 600;
        letter-spacing: 0.5px;
    }

    ul {
        list-style-type: none;
        padding: 0;
        margin: 0 0 60px 0;
    }

    li {
        display: flex;
        align-items: center;
        padding: 15px 5px;
        border-bottom: 1px solid #F8BBD0;
        transition: background-color 0.2s ease-in-out, border 0.2s ease-in-out;
        position: relative;
        /* Prevent iOS callout menu on long press */
        -webkit-touch-callout: none;
    }

    li:last-child {
        border-bottom: none;
    }

    .checkbox-container {
        font-size: 1.5em;
        margin-right: 18px;
        cursor: pointer;
        width: 28px;
        text-align: center;
        transition: color 0.2s ease-in-out;
        flex-shrink: 0;
        color: #D7CCC8;
    }

    .task-text {
        flex-grow: 1;
        font-size: 1em;
        line-height: 1.5;
        transition: color 0.3s ease, text-decoration 0.3s ease;
        cursor: pointer;
        /* Prevent text selection during long-press attempts */
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none;    /* Firefox */
        -ms-user-select: none;     /* IE10+/Edge */
        user-select: none;         /* Standard */
    }

    /* Allow text selection for the input field when editing */
    .task-edit-input {
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
        user-select: text !important;
        /* Other input styles */
        flex-grow: 1;
        font-family: 'Poppins', sans-serif;
        font-size: 1em;
        padding: 4px 6px;
        border: 1px solid #C2185B;
        border-radius: 4px;
        outline-color: #AD1457;
    }


    /* State Styles for Icons */
    .checkbox-container.status-0 .fa-square { display: inline-block; }
    .checkbox-container.status-0 .fa-circle-half-stroke,
    .checkbox-container.status-0 .fa-check-square { display: none; }

    .checkbox-container.status-1 { color: #FFB74D; }
    .checkbox-container.status-1 .fa-circle-half-stroke { display: inline-block; }
    .checkbox-container.status-1 .fa-square,
    .checkbox-container.status-1 .fa-check-square { display: none; }

    .checkbox-container.status-2 { color: #AED581; }
    .checkbox-container.status-2 .fa-check-square { display: inline-block; }
    .checkbox-container.status-2 .fa-square,
    .checkbox-container.status-2 .fa-circle-half-stroke { display: none; }

    /* State Styles for List Item & Text */
    li.status-1 .task-text { color: #8D6E63; }
    
    li.status-2 .task-text {
        text-decoration: line-through;
        color: #BCAAA4;
    }

    /* Alternating Pastel Backgrounds for Completed Tasks */
    .pastel-bg-1 { background-color: #FFDFD3; } /* Pastel Peach */
    .pastel-bg-2 { background-color: #D4F0F0; } /* Pastel Mint */
    .pastel-bg-3 { background-color: #E6E0FF; } /* Pastel Lavender */
    .pastel-bg-4 { background-color: #FFFACD; } /* LemonChiffon */

    li.status-2.pastel-bg-1 .task-text,
    li.status-2.pastel-bg-2 .task-text,
    li.status-2.pastel-bg-3 .task-text,
    li.status-2.pastel-bg-4 .task-text {
        color: #6D4C41;
    }

    li:hover:not(.edit-mode-item) {
        background-color: #FFF8FA;
    }

    /* Edit Mode Styles */
    .app-container.edit-mode li {
        border: 1px dashed #E91E63;
        margin-bottom: -1px;
        cursor: grab;
    }
    .app-container.edit-mode li:active {
        cursor: grabbing;
    }
    .app-container.edit-mode .checkbox-container {
        cursor: default;
    }
     .app-container.edit-mode .task-text {
        cursor: text;
        /* Re-enable selection for task text in edit mode if needed, though input handles it */
        /* -webkit-user-select: auto; user-select: auto; */
    }

    .add-task-btn {
        display: none;
        position: absolute;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background-color: #C2185B;
        color: white;
        border: none;
        border-radius: 8px;
        font-family: 'Poppins', sans-serif;
        font-size: 0.95em;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(194, 24, 91, 0.3);
        transition: background-color 0.2s ease;
    }
    .app-container.edit-mode .add-task-btn {
        display: block;
    }
    .add-task-btn:hover {
        background-color: #AD1457;
    }
    .add-task-btn i {
        margin-right: 8px;
    }

    /* Delete Task Button */
    .delete-task-btn {
        display: none; /* Hidden by default */
        color: #E91E63; /* Pink to match edit mode border */
        font-size: 1.1em; /* Adjusted for better visual balance */
        margin-left: 12px; /* Spacing from text */
        padding: 3px 6px; /* Clickable area */
        cursor: pointer;
        border-radius: 50%;
        transition: background-color 0.2s, color 0.2s;
        line-height: 1; /* Ensure icon is centered well */
        align-self: center; /* Align with flex items */
    }

    .app-container.edit-mode li .delete-task-btn {
        display: inline-flex; /* Use flex for centering icon if needed */
        align-items: center;
        justify-content: center;
    }

    .delete-task-btn:hover {
        background-color: #FCE4EC; /* Light pink hover background */
        color: #C2185B; /* Darker pink on hover for icon */
    }


    /* Drag and Drop Visuals */
    .dragging {
        opacity: 0.5;
        background: #FFECF0;
    }
    .drag-over-target {
         box-shadow: 0 0 0 2px #FFB74D inset;
    }
    
    @media (max-width: 600px) {
        .app-container { padding: 20px; margin-top: 10px; }
        h1 { font-size: 1.7em; margin-bottom: 20px; }
        .checkbox-container { font-size: 1.3em; margin-right: 12px; width: 25px; }
        .task-text { font-size: 0.95em; }
        li { padding: 12px 5px; }
        ul { margin-bottom: 70px; }
        .add-task-btn { font-size: 0.9em; padding: 8px 15px; }
        .delete-task-btn { font-size: 1em; margin-left: 8px; }
    }
</style>
</head>
<body>
    <div class="app-container">
        <h1>Amanda's Tasks</h1>
        <ul id="taskListAmanda">
            <!-- Tasks will be rendered here by JavaScript -->
        </ul>
        <button class="add-task-btn" id="addTaskBtnAmanda">
            <i class="fas fa-plus"></i> Add Task
        </button>
    </div>

<script>
    (function() {
        const STORAGE_KEY_AMANDA = 'amandaTasks_v2_storage';
        const initialDefaultAmandaTasks = [
            { id: 'amanda-task-1', text: "ðŸ‘• Put rest of my clothes in bins", status: 0 },
            { id: 'amanda-task-2', text: "ðŸ‘Ÿ Put my shoes in closet", status: 0 },
            { id: 'amanda-task-3', text: "ðŸ‘§ Put away girlsâ€™ old shoes (attic box)", status: 0 },
            { id: 'amanda-task-4', text: "ðŸ§º Put away all my clean clothes", status: 0 },
            { id: 'amanda-task-5', text: "ðŸ›ï¸ Tidy our room â€“ bench, sheets (Sterling will help)", status: 0 },
            { id: 'amanda-task-6', text: "ðŸ§¼ Clean our closet dresser top", status: 0 },
            { id: 'amanda-task-7', text: "ðŸ› Clean bathroom countertop", status: 0 }
        ];
        let currentAmandaTasks;
        let isEditMode = false;
        let longPressTimer;
        const LONG_PRESS_DURATION = 1000; // 1 second
        let draggedItemId = null;

        const appContainer = document.querySelector('.app-container');
        const taskListElement = document.getElementById('taskListAmanda');
        const addTaskButton = document.getElementById('addTaskBtnAmanda');
        const pastelColorClasses = ['pastel-bg-1', 'pastel-bg-2', 'pastel-bg-3', 'pastel-bg-4'];


        function generateUniqueId(prefix = 'task') {
            return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        }

        function loadTasksFromStorage() {
            try {
                const storedTasks = localStorage.getItem(STORAGE_KEY_AMANDA);
                if (storedTasks) {
                    const parsedTasks = JSON.parse(storedTasks);
                    if (Array.isArray(parsedTasks) &&
                        (parsedTasks.length === 0 || (typeof parsedTasks[0].id !== 'undefined' && typeof parsedTasks[0].status !== 'undefined'))) {
                        currentAmandaTasks = parsedTasks;
                        return;
                    } else {
                        console.warn(`Invalid data in localStorage for ${STORAGE_KEY_AMANDA}, falling back to defaults.`);
                    }
                }
            } catch (error) {
                console.error(`Error loading tasks from localStorage for ${STORAGE_KEY_AMANDA}:`, error);
            }
            currentAmandaTasks = initialDefaultAmandaTasks.map(task => ({ ...task }));
        }

        function saveTasksToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY_AMANDA, JSON.stringify(currentAmandaTasks));
            } catch (error) {
                console.error(`Error saving tasks to localStorage for ${STORAGE_KEY_AMANDA}:`, error);
            }
        }

        function renderTasks() {
            taskListElement.innerHTML = '';
            let completedTaskCounter = 0;
            
            currentAmandaTasks.forEach((task) => {
                const listItem = document.createElement('li');
                listItem.setAttribute('data-id', task.id);
                listItem.className = `status-${task.status}`;
                if (isEditMode) {
                    listItem.classList.add('edit-mode-item');
                }

                if (task.status === 2) {
                    const pastelClass = pastelColorClasses[completedTaskCounter % pastelColorClasses.length];
                    listItem.classList.add(pastelClass);
                    completedTaskCounter++;
                }

                const checkboxContainer = document.createElement('span');
                checkboxContainer.className = `checkbox-container status-${task.status}`;
                checkboxContainer.innerHTML = `
                    <i class="far fa-square"></i>
                    <i class="fas fa-circle-half-stroke"></i>
                    <i class="far fa-check-square"></i>
                `;
                if (!isEditMode) {
                    checkboxContainer.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleTaskStatus(task.id);
                    });
                }


                const taskTextElement = document.createElement('span');
                taskTextElement.classList.add('task-text');
                taskTextElement.textContent = task.text;

                listItem.appendChild(checkboxContainer);
                listItem.appendChild(taskTextElement);

                if (isEditMode) {
                    taskTextElement.title = "Click to edit task text";
                    taskTextElement.addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        makeTaskEditable(task.id, listItem);
                    });
                    listItem.draggable = true;
                    listItem.addEventListener('dragstart', (e) => handleDragStart(e, task.id));
                    listItem.addEventListener('dragover', handleDragOver);
                    listItem.addEventListener('drop', (e) => handleDrop(e, listItem));
                    listItem.addEventListener('dragend', handleDragEnd);

                    // Add Delete Button in Edit Mode
                    const deleteButton = document.createElement('span');
                    deleteButton.className = 'delete-task-btn';
                    deleteButton.innerHTML = '<i class="fas fa-times"></i>';
                    deleteButton.title = "Delete task";
                    deleteButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent other LI listeners
                        deleteTask(task.id);
                    });
                    listItem.appendChild(deleteButton);

                } else { // Not in Edit Mode
                    taskTextElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleTaskStatus(task.id);
                    });
                    
                    // Long press listeners only if not in edit mode
                    let pressStartX, pressStartY;
                    const handlePressStart = (e) => {
                        // For touch events, use e.touches[0]
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                        if ((e.type === "mousedown" && e.button !== 0) || isEditMode || listItem.querySelector('input.task-edit-input')) return;
                        
                        pressStartX = clientX;
                        pressStartY = clientY;
                        clearTimeout(longPressTimer); 
                        longPressTimer = setTimeout(() => {
                             if (document.querySelector('.task-edit-input:focus')) return;
                            enterEditMode(task.id);
                        }, LONG_PRESS_DURATION);
                    };

                    const clearLongPress = () => clearTimeout(longPressTimer);

                    const handlePressMove = (e) => {
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        if (Math.abs(clientX - pressStartX) > 10 || Math.abs(clientY - pressStartY) > 10) { // Increased tolerance
                            clearTimeout(longPressTimer);
                        }
                    };

                    listItem.addEventListener('mousedown', handlePressStart);
                    listItem.addEventListener('mouseup', clearLongPress);
                    listItem.addEventListener('mouseleave', clearLongPress);
                    listItem.addEventListener('mousemove', handlePressMove);

                    // Add touch event listeners for long press on mobile
                    listItem.addEventListener('touchstart', handlePressStart, { passive: true }); // passive:true for better scroll performance
                    listItem.addEventListener('touchend', clearLongPress);
                    listItem.addEventListener('touchcancel', clearLongPress);
                    listItem.addEventListener('touchmove', handlePressMove, { passive: true });
                }
                
                taskListElement.appendChild(listItem);
            });
        }

        function makeTaskEditable(taskId, listItemElement) {
            const task = currentAmandaTasks.find(t => t.id === taskId);
            const taskTextSpan = listItemElement.querySelector('.task-text');
            if (!task || !taskTextSpan || listItemElement.querySelector('input.task-edit-input')) return;

            const otherActiveInput = taskListElement.querySelector('input.task-edit-input');
            if (otherActiveInput && otherActiveInput !== taskTextSpan) {
                otherActiveInput.blur();
            }

            const input = document.createElement('input');
            input.type = 'text';
            input.value = task.text;
            input.className = 'task-edit-input';
            
            const saveChanges = () => {
                const newText = input.value.trim();
                if (newText && newText !== task.text) {
                    task.text = newText;
                } else if (!newText && currentAmandaTasks.some(t => t.id === task.id)) { // Task still exists
                    // If text is cleared, revert to original or decide on a behavior (e.g., delete or keep old)
                    // For now, let's revert if cleared, unless it's a brand new task being cleared.
                    // This example will just keep the old text if newText is empty.
                    // If you want to delete if empty, add that logic here.
                }
                saveTasksToStorage();
                if (isEditMode && listItemElement.contains(input)) { 
                     renderTasks();
                }
            };

            input.addEventListener('blur', saveChanges);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                } else if (e.key === 'Escape') {
                    input.value = task.text; 
                    input.blur();
                }
            });

            taskTextSpan.replaceWith(input);
            input.focus();
            input.select();
        }


        function toggleTaskStatus(taskId) {
            if (isEditMode) return; 
            const task = currentAmandaTasks.find(t => t.id === taskId);
            if (task) {
                task.status = (task.status + 1) % 3;
                saveTasksToStorage();
                renderTasks(); 
            }
        }

        function deleteTask(taskId) {
            currentAmandaTasks = currentAmandaTasks.filter(t => t.id !== taskId);
            saveTasksToStorage();
            renderTasks(); // Re-render to show changes while still in edit mode
        }

        function enterEditMode(initiatingTaskId = null) {
            if (isEditMode) return;
            isEditMode = true;
            appContainer.classList.add('edit-mode');
            console.log("Entered Edit Mode");
            renderTasks(); 
        }

        function exitEditMode() {
            if (!isEditMode) return;
            
            const activeInput = taskListElement.querySelector('input.task-edit-input:focus');
            if (activeInput) {
                activeInput.blur(); 
                isEditMode = false; 
                appContainer.classList.remove('edit-mode');
                saveTasksToStorage(); 
                renderTasks(); 
                return;
            }

            isEditMode = false;
            appContainer.classList.remove('edit-mode');
            console.log("Exited Edit Mode");
            saveTasksToStorage(); 
            renderTasks();
        }

        function addNewTask() {
            if (!isEditMode) return;
            const newText = "New Task"; // Simpler default
            const newTask = {
                id: generateUniqueId('amanda-task'),
                text: newText,
                status: 0
            };
            currentAmandaTasks.push(newTask);
            saveTasksToStorage();
            renderTasks(); 

            const newListItem = taskListElement.querySelector(`li[data-id="${newTask.id}"]`);
            if (newListItem) {
                setTimeout(() => makeTaskEditable(newTask.id, newListItem), 0);
            }
        }

        // Drag and Drop Handlers
        function handleDragStart(event, taskId) {
            draggedItemId = taskId;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', taskId);
            event.currentTarget.classList.add('dragging');
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            const targetLi = event.target.closest('li');
            if (targetLi && targetLi.dataset.id !== draggedItemId) {
                document.querySelectorAll('.drag-over-target').forEach(el => el.classList.remove('drag-over-target'));
                targetLi.classList.add('drag-over-target');
            }
        }

        function handleDrop(event, targetListItem) {
            event.preventDefault();
            document.querySelectorAll('.drag-over-target').forEach(el => el.classList.remove('drag-over-target'));
            const droppedOnItemId = targetListItem.dataset.id;
            if (!draggedItemId || draggedItemId === droppedOnItemId) return;

            const draggedItemIndex = currentAmandaTasks.findIndex(t => t.id === draggedItemId);
            let targetItemIndex = currentAmandaTasks.findIndex(t => t.id === droppedOnItemId);

            if (draggedItemIndex === -1 || targetItemIndex === -1) return;

            const [draggedItem] = currentAmandaTasks.splice(draggedItemIndex, 1);
            
            // Re-find target index as splice might have shifted it if only one item between.
            targetItemIndex = currentAmandaTasks.findIndex(t => t.id === droppedOnItemId); 
            // If droppedOnItem was removed (shouldn't happen here), handle appropriately.
            // For now, assume it's still there.

            const rect = targetListItem.getBoundingClientRect();
            const isDroppingBefore = event.clientY < rect.top + rect.height / 2;

            if (isDroppingBefore) {
                currentAmandaTasks.splice(targetItemIndex, 0, draggedItem);
            } else {
                currentAmandaTasks.splice(targetItemIndex + 1, 0, draggedItem);
            }
            
            draggedItemId = null;
            saveTasksToStorage();
            renderTasks(); 
        }

        function handleDragEnd(event) {
            if (event.currentTarget) { // Ensure currentTarget exists
                event.currentTarget.classList.remove('dragging');
            }
            document.querySelectorAll('.drag-over-target').forEach(el => el.classList.remove('drag-over-target'));
            draggedItemId = null;
        }


        // Event Listeners
        addTaskButton.addEventListener('click', addNewTask);

        appContainer.addEventListener('click', (event) => {
            if (isEditMode) {
                if (event.target === appContainer) {
                    exitEditMode();
                }
            }
        });


        document.addEventListener('DOMContentLoaded', () => {
            loadTasksFromStorage();
            renderTasks();
        });
    })();
</script>
</body>
</html>