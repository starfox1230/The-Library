<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Anki True-Template Swipe Feed</title>
  <style>
    :root {
      --bg: #0f0f0f; /* Darker bg */
      --card-bg: #1c1c1e;
      --text: #e0e0e0; /* Lighter text */
      --accent: #00c8ff;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
    }
    header {
      text-align: center;
      padding: 1rem;
      background: var(--card-bg);
      border-bottom: 1px solid #333;
    }
    header h1 {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
    }
    #fileInput {
      margin-top: 0.5rem;
      padding: 0.5rem 0.8rem;
      background: #2c2c2e; /* Slightly lighter for input */
      color: var(--text);
      border: 1px solid #444;
      border-radius: 4px;
      cursor: pointer;
    }
    #fileInput:hover {
        background: #3a3a3c;
    }
    #feed {
      padding: 1rem 0;
      overflow-x: hidden; /* Prevent horizontal scroll from card content */
    }
    .card-container { /* Wrapper for each card including its style */
      position: relative; /* For absolute positioning of .card inside if needed for styles */
      margin: 1rem auto;
      max-width: 600px;
      border-radius: 8px;
      /* The .card itself will get background from Anki CSS or our default */
    }
    .card {
      position: relative; /* For absolute positioning of front/back */
      overflow: hidden;
      background: var(--card-bg); /* Default background if Anki CSS doesn't override */
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      /* Height will be set by JS */
    }
    .card .back,
    .card .front {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      padding: 1rem;
      white-space: pre-wrap; /* Preserve newlines from Anki fields */
      overflow-y: auto; /* Scroll if content overflows */
      word-wrap: break-word; /* Prevent long strings from breaking layout */
    }
    .card .back {
      /* Sits underneath, revealed by swiping front */
      background: var(--card-bg); /* Ensure back has a background */
    }
    .card .front {
      background: var(--card-bg); /* Ensure front has a background */
      touch-action: pan-y; /* Allow vertical scroll, handle horizontal swipe */
      user-select: none;
      transition: transform 0.3s ease;
      z-index: 10; /* Ensure front is on top */
    }
    /* Styling for images and audio from Anki content */
    .card img {
      max-width: 100%;
      height: auto;
      display: block; /* Prevents extra space below image */
      margin: 0.5em auto; /* Center images */
      border-radius: 4px;
    }
    .card audio {
      width: 100%;
      margin-top: 0.5em;
    }
    .message {
        text-align: center;
        padding: 1rem;
        color: #aaa;
    }
  </style>
  <!-- dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/sql-wasm.js"></script>
</head>
<body>
  <header>
    <h1>Anki True-Template Swipe Feed</h1>
    <input type="file" id="fileInput" accept=".apkg,.zip">
  </header>
  <main id="feed">
    <p class="message">Upload an .apkg/.zip file exported from Anki.</p>
  </main>

<script>
  // Global cache for media blob URLs
  const mediaBlobUrls = {};

  function clearMediaBlobUrls() {
    for (const key in mediaBlobUrls) {
      URL.revokeObjectURL(mediaBlobUrls[key]);
      delete mediaBlobUrls[key];
    }
  }

  async function getMediaURL(fileName, zip, mediaFileMap) {
    if (mediaBlobUrls[fileName]) return mediaBlobUrls[fileName];

    let actualFileNameInZip = fileName;
    // Check if fileName is a human-readable name that needs mapping to a numerical name
    const numericalName = Object.keys(mediaFileMap).find(key => mediaFileMap[key] === fileName);
    if (numericalName) {
      actualFileNameInZip = numericalName;
    }
    
    let fileInZip = zip.file(actualFileNameInZip);

    // Fallback: try common prefixes or if the name was already numerical
    if (!fileInZip) {
        const commonPrefixes = ["", "media/"];
        for (const prefix of commonPrefixes) {
            const potentialPath = prefix + actualFileNameInZip;
            if (zip.files[potentialPath]) {
                fileInZip = zip.file(potentialPath);
                break;
            }
        }
    }
    // Fallback for fileName if it was original and not in map, or if map is missing
    if (!fileInZip && fileName !== actualFileNameInZip) {
        fileInZip = zip.file(fileName);
    }


    if (fileInZip) {
      try {
        const blob = await fileInZip.async("blob");
        const url = URL.createObjectURL(blob);
        mediaBlobUrls[fileName] = url; // Cache by original requested name
        return url;
      } catch (error) {
        console.error(`Error loading media ${fileName} (as ${fileInZip.name}):`, error);
        return ""; // Or a placeholder URL
      }
    }
    console.warn(`Media file not found in zip: ${fileName} (searched for ${actualFileNameInZip})`);
    return ""; // Or a placeholder URL
  }

  async function renderAnkiTemplate(templateStr, fieldsData, modelFieldsArray, context, zip, mediaFileMap) {
    let output = templateStr;

    // Handle {{FrontSide}} for back templates
    if (context.isFront === false && context.frontContentForBack) {
      output = output.replace(/\{\{FrontSide\}\}/g, context.frontContentForBack);
    }

    // Handle conditional rendering: {{#FieldName}}...{{/FieldName}} and {{^FieldName}}...{{/FieldName}}
    // This is a simplified regex approach. A proper parser would be more robust.
    output = output.replace(/\{\{#(.+?)\}\}([\s\S]*?)\{\{\/\1\}\}/g, (match, fieldName, content) => {
      const fieldValue = fieldsData[fieldName.trim()];
      return (fieldValue && fieldValue.toString().trim() !== "") ? content : "";
    });
    output = output.replace(/\{\{\^(.+?)\}\}([\s\S]*?)\{\{\/\1\}\}/g, (match, fieldName, content) => {
      const fieldValue = fieldsData[fieldName.trim()];
      return (!fieldValue || fieldValue.toString().trim() === "") ? content : "";
    });

    // Handle simple field replacements: {{FieldName}}
    // Also handle {{edit:FieldName}} by showing field content, and {{cloze:FieldName}} similarly for simplicity
    modelFieldsArray.forEach(field => {
      const fieldName = field.name;
      const fieldValue = fieldsData[fieldName] || "";
      // Basic field replacement
      output = output.replace(new RegExp(`\\{\\{${fieldName}\\}\\}`, 'g'), fieldValue);
      // Handle {{edit:FieldName}} by just showing content
      output = output.replace(new RegExp(`\\{\\{edit:${fieldName}\\}\\}`, 'g'), fieldValue);
      // Simplified {{cloze:FieldName}} - just show content. Full cloze rendering is complex.
      // A more advanced version would parse {{c1::text}} syntax within fieldValue.
      output = output.replace(new RegExp(`\\{\\{cloze:${fieldName}\\}\\}`, 'g'), fieldValue);
    });
    
    // Handle {{Tags}}, {{Type}}, {{Deck}}, {{Card}}, {{Subdeck}} - simplified
    output = output.replace(/\{\{Tags\}\}/g, fieldsData.Tags || context.noteTags || "");
    output = output.replace(/\{\{Type\}\}/g, context.modelName || "");
    output = output.replace(/\{\{Deck\}\}/g, context.deckName || "");
    output = output.replace(/\{\{Card\}\}/g, context.cardTypeName || "");
    // Subdeck is harder without full deck hierarchy parsing.

    // Handle media (images and audio)
    // Images: <img src="filename.jpg">
    const imgRegex = /<img src="([^"]+?)">/gi;
    let imgMatch;
    const imgReplacements = [];
    while ((imgMatch = imgRegex.exec(output)) !== null) {
      imgReplacements.push({ placeholder: imgMatch[0], src: imgMatch[1] });
    }
    for (const rep of imgReplacements) {
      const mediaUrl = await getMediaURL(rep.src, zip, mediaFileMap);
      if (mediaUrl) {
        output = output.replace(rep.placeholder, `<img src="${mediaUrl}" alt="${rep.src}">`);
      } else {
        output = output.replace(rep.placeholder, `<img src="#" alt="${rep.src} (not found)">`);
      }
    }

    // Audio: [sound:filename.mp3]
    const soundRegex = /\[sound:([^\]]+?)\]/gi;
    let soundMatch;
    const soundReplacements = [];
    while ((soundMatch = soundRegex.exec(output)) !== null) {
      soundReplacements.push({ placeholder: soundMatch[0], src: soundMatch[1] });
    }
    for (const rep of soundReplacements) {
      const mediaUrl = await getMediaURL(rep.src, zip, mediaFileMap);
      if (mediaUrl) {
        output = output.replace(rep.placeholder, `<audio controls src="${mediaUrl}"></audio>`);
      } else {
        output = output.replace(rep.placeholder, `<span>[Audio: ${rep.src} (not found)]</span>`);
      }
    }
    return output;
  }


  initSqlJs({ locateFile: f => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/${f}` })
  .then(SQL => {
    const fileInput = document.getElementById('fileInput');
    const feed = document.getElementById('feed');

    fileInput.addEventListener('change', async e => {
      clearMediaBlobUrls(); // Clear previous media objects
      const file = e.target.files[0];
      if (!file) return;
      feed.innerHTML = '<p class="message">Loading deck...</p>';

      try {
        const fileData = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(fileData);

        console.log('ZIP files:', Object.keys(zip.files));

        const dbPath = Object.keys(zip.files).find(p => /collection\.anki21?$/i.test(p));
        if (!dbPath) {
          feed.innerHTML = `<p class="message error">Could not find <code>collection.anki2</code> or <code>collection.anki21</code> in your .apkg/.zip. <br>See console for a full directory listing.</p>`;
          return;
        }

        const dbFile = zip.file(dbPath);
        if (!dbFile) {
             feed.innerHTML = `<p class="message error">Error accessing database file: ${dbPath}</p>`;
             return;
        }
        const dbData = new Uint8Array(await dbFile.async('arraybuffer'));
        const db = new SQL.Database(dbData);

        // 1. Parse media map
        let mediaFileMap = {};
        const mediaMapFile = zip.file("media");
        if (mediaMapFile) {
          try {
            const mediaContent = await mediaMapFile.async("string");
            mediaFileMap = JSON.parse(mediaContent);
          } catch (err) {
            console.error("Error parsing 'media' file:", err);
            feed.innerHTML += '<p class="message" style="color:orange;">Warning: Could not parse "media" file. Media might not load correctly.</p>';
          }
        } else {
            console.warn("No 'media' file found in zip package.");
        }

        // 2. Get models (note types)
        const colQuery = db.exec("SELECT models, decks FROM col LIMIT 1");
        if (!colQuery || colQuery.length === 0 || !colQuery[0].values || colQuery[0].values.length === 0) {
            throw new Error("Failed to query 'col' table or 'col' table is empty.");
        }
        const modelsData = JSON.parse(colQuery[0].values[0][0]); // models is a JSON string
        const decksData = JSON.parse(colQuery[0].values[0][1]);  // decks is a JSON string

        // 3. Get notes
        const notesQuery = db.exec("SELECT id, mid, flds, tags FROM notes");
        const notesMap = {}; // nid -> { mid, fldsArray, tagsArray }
        if (notesQuery && notesQuery.length > 0 && notesQuery[0].values) {
            notesQuery[0].values.forEach(row => {
                notesMap[row[0]] = { // nid (note id)
                    mid: row[1].toString(), // model id
                    fldsArray: row[2].split('\x1f'), // field values
                    tagsArray: row[3].trim().split(' ').filter(t => t) // tags
                };
            });
        }
        
        // 4. Get cards
        const cardsQuery = db.exec("SELECT id, nid, did, ord FROM cards ORDER BY odid, ord, ivl"); // Better ordering
        const cards = [];
        if (cardsQuery && cardsQuery.length > 0 && cardsQuery[0].values) {
            cardsQuery[0].values.forEach(row => {
                cards.push({
                    id: row[0],    // card id
                    nid: row[1],   // note id
                    did: row[2],   // deck id
                    ord: row[3]    // template ordinal (0, 1, ...)
                });
            });
        }

        if (cards.length === 0) {
          feed.innerHTML = '<p class="message">No cards found in the deck.</p>';
          return;
        }

        feed.innerHTML = ''; // Clear "Loading..."

        // 5. Render cards
        for (const cardData of cards) {
          const note = notesMap[cardData.nid];
          if (!note) {
            console.warn(`Note not found for card id ${cardData.id}, nid ${cardData.nid}`);
            continue;
          }

          const model = modelsData[note.mid];
          if (!model) {
            console.warn(`Model not found for note (nid ${cardData.nid}), mid ${note.mid}`);
            continue;
          }

          const template = model.tmpls[cardData.ord];
          if (!template) {
            console.warn(`Template not found for card (cid ${cardData.id}), model "${model.name}", ord ${cardData.ord}`);
            continue;
          }

          const fieldsData = {};
          model.flds.forEach((fieldSchema, index) => {
            fieldsData[fieldSchema.name] = note.fldsArray[index] || "";
          });
          fieldsData.Tags = note.tagsArray.join(' ');


          const cardContainer = document.createElement('div');
          cardContainer.className = 'card-container';
          cardContainer.id = `card-container-${cardData.id}`;

          // Inject model-specific CSS
          if (model.css && model.css.trim() !== "") {
            const styleElement = document.createElement('style');
            // Basic scoping: Anki CSS often uses .card class. We target this card's ID.
            // A full CSS parser/scoper is complex. This assumes model.css is well-behaved.
            let scopedCss = model.css.replace(/\.card(?=[^a-zA-Z0-9\-])/g, `#${cardContainer.id} .card`);
            // Add scope for mobile specific styles
            scopedCss = scopedCss.replace(/\.mobile\s*\.card(?=[^a-zA-Z0-9\-])/g, `#${cardContainer.id} .card`); // if .mobile.card
            scopedCss = scopedCss.replace(/\.mobile(?=[^a-zA-Z0-9\-])/g, `#${cardContainer.id} .mobile-scope`); // if just .mobile

            styleElement.textContent = scopedCss;
            cardContainer.appendChild(styleElement);
          }
          
          const cardElement = document.createElement('div');
          cardElement.className = 'card mobile-scope'; // Add 'card' for Anki CSS and 'mobile-scope' for .mobile selectors
          // cardElement.id = `card-${cardData.id}`; // Not strictly needed if cardContainer has ID

          const frontDiv = document.createElement('div');
          frontDiv.className = 'front';
          const backDiv = document.createElement('div');
          backDiv.className = 'back';

          const deckName = decksData[cardData.did.toString()] ? decksData[cardData.did.toString()].name : "Unknown Deck";
          const renderContext = {
            isFront: true,
            noteTags: note.tagsArray.join(' '),
            modelName: model.name,
            deckName: deckName,
            cardTypeName: template.name,
            frontContentForBack: '' // Will be filled after front renders
          };
          
          const frontHTML = await renderAnkiTemplate(template.qfmt, fieldsData, model.flds, renderContext, zip, mediaFileMap);
          frontDiv.innerHTML = frontHTML;
          
          renderContext.isFront = false;
          renderContext.frontContentForBack = frontHTML; // Use the raw (but field-replaced) front HTML for {{FrontSide}}
          const backHTML = await renderAnkiTemplate(template.afmt, fieldsData, model.flds, renderContext, zip, mediaFileMap);
          backDiv.innerHTML = backHTML;

          cardElement.appendChild(backDiv); // Back first for z-index stacking
          cardElement.appendChild(frontDiv);
          cardContainer.appendChild(cardElement);
          feed.appendChild(cardContainer);

          // Dynamically set card height after content is potentially loaded (images are async)
          // A more robust solution would use new ResizeObserver or wait for images to load.
          // For now, measure scrollHeight.
          requestAnimationFrame(() => { // Ensure elements are in DOM and rendered for measurement
            const frontHeight = frontDiv.scrollHeight;
            const backHeight = backDiv.scrollHeight;
            cardElement.style.height = Math.max(frontHeight, backHeight, 150) + 'px'; // Min height 150px
          });


          // Swipe logic
          let startX = 0, currentX = 0, translateX = 0, isDragging = false;
          const swipeThreshold = cardElement.offsetWidth / 3.5;

          frontDiv.addEventListener('pointerdown', e => {
            if (e.button !== 0) return; // Only main click
            isDragging = true;
            startX = e.clientX;
            currentX = e.clientX; // Initialize currentX
            frontDiv.style.transition = 'none';
            frontDiv.setPointerCapture(e.pointerId);
          });

          frontDiv.addEventListener('pointermove', e => {
            if (!isDragging) return;
            currentX = e.clientX;
            const diffX = currentX - startX;
            
            // Only allow swiping left to reveal
            translateX = Math.min(0, diffX); 
            
            frontDiv.style.transform = `translateX(${translateX}px)`;
          });

          frontDiv.addEventListener('pointerup', e => {
            if (!isDragging) return;
            isDragging = false;
            frontDiv.style.transition = 'transform 0.3s ease';
            frontDiv.releasePointerCapture(e.pointerId);

            if (translateX < -swipeThreshold) {
              frontDiv.style.transform = 'translateX(-100%)'; // Reveal back
            } else {
              frontDiv.style.transform = 'translateX(0px)'; // Snap back
            }
          });
          
          // Click to flip for non-touch devices or if preferred
          frontDiv.addEventListener('click', e => {
            if (Math.abs(currentX - startX) > 10) return; // It was a drag, not a click
            
            const currentTransform = getComputedStyle(frontDiv).transform;
            const matrix = new DOMMatrixReadOnly(currentTransform);
            if (matrix.m41 < -10) { // If already swiped (e.g. -100%)
                 frontDiv.style.transform = 'translateX(0px)';
            } else {
                 frontDiv.style.transform = 'translateX(-100%)';
            }
          });
        } // End of card loop

        if (feed.children.length === 0 && cards.length > 0) {
             feed.innerHTML = '<p class="message">Finished processing, but no cards could be rendered. Check console for errors.</p>';
        }


      } catch (err) {
        console.error(err);
        feed.innerHTML = `<p class="message error">Error processing deck: ${err.message}<br>Check console for more details.</p>`;
      }
    });
  });
</script>
</body>
</html>