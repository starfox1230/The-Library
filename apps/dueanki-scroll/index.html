<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Anki True-Template Swipe Feed</title>
  <style>
    :root {
      --bg: #0f0f0f; /* Darker bg for better contrast with cards */
      --card-bg: #1c1c1e; /* Default card background */
      --text: #e0e0e0; /* Lighter default text */
      --accent: #00c8ff;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
    }
    header {
      text-align: center;
      padding: 1rem;
      background: var(--card-bg); /* Use card-bg for header */
      border-bottom: 1px solid #333; /* Subtle separator */
    }
    header h1 {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
    }
    #fileInput {
      margin-top: 0.5rem;
      padding: 0.5rem 0.8rem;
      background: #2c2c2e; /* Slightly lighter for input */
      color: var(--text);
      border: 1px solid #444;
      border-radius: 4px;
      cursor: pointer;
    }
    #fileInput:hover {
        background: #3a3a3c;
    }
    #feed {
      padding: 1rem 0;
      overflow-x: hidden; /* Prevent horizontal scroll from card content */
    }
    .card-container { /* Wrapper for each card including its style */
      position: relative;
      margin: 1rem auto;
      max-width: 600px; /* Max width for readability */
      border-radius: 8px;
      /* The .card-content-wrapper inside will get background from Anki CSS or our default */
    }
    .card { /* This is the structural swipeable card element */
      position: relative;
      overflow: hidden;
      background: var(--card-bg); /* Default background if Anki CSS doesn't override .card-content-wrapper */
      border-radius: 8px; /* Consistent rounded corners */
      box-shadow: 0 4px 12px rgba(0,0,0,0.4); /* Softer shadow */
      /* Height will be set by JS after content loading */
    }
    /* .card-content-wrapper is what Anki's .card CSS will target via scoping */
    .card .card-content-wrapper {
        /* This class will be added alongside .card if CSS scoping targets it.
           However, the main styling should come from Anki's CSS applied to #cardId .card-content-wrapper */
    }
    .card .back,
    .card .front {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      padding: 1rem; /* Default padding, Anki CSS might override */
      white-space: pre-wrap; /* Preserve newlines from Anki fields */
      overflow-y: auto; /* Scroll if content overflows */
      word-wrap: break-word; /* Prevent long strings from breaking layout */
      color: var(--text); /* Default text color, Anki CSS might override */
    }
    .card .back {
      background: var(--card-bg); /* Ensure back has a background, Anki CSS can override */
    }
    .card .front {
      background: var(--card-bg); /* Ensure front has a background, Anki CSS can override */
      touch-action: pan-y; /* Allow vertical scroll, handle horizontal swipe */
      user-select: none;
      transition: transform 0.3s ease;
      z-index: 10; /* Ensure front is on top */
    }

    /* Default styling for images and audio if not overridden by Anki CSS (scoped) */
    .card-container img { /* Target images within any card container */
      max-width: 100%;
      height: auto;
      display: block; 
      margin: 0.5em auto; 
      border-radius: 4px;
    }
    .card-container audio { /* Target audio within any card container */
      width: 100%;
      margin-top: 0.5em;
    }
    .message {
        text-align: center;
        padding: 1rem;
        color: #aaa;
    }
    .message.error {
        color: #ff6b6b; /* Error color */
    }
  </style>
  <!-- dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/sql-wasm.js"></script>
</head>
<body>
  <header>
    <h1>Anki True-Template Swipe Feed</h1>
    <input type="file" id="fileInput" accept=".apkg,.zip">
  </header>
  <main id="feed">
    <p class="message">Upload an .apkg/.zip file exported from Anki.</p>
  </main>

<script>
  // Global cache for media blob URLs, keyed by original filename
  const mediaBlobUrls = {};
  const MAX_CARDS_TO_DISPLAY = 100;

  function clearMediaBlobUrls() {
    for (const key in mediaBlobUrls) {
      URL.revokeObjectURL(mediaBlobUrls[key]);
      delete mediaBlobUrls[key];
    }
  }

  async function getMediaURL(originalFileName, zip, mediaFileMap) {
    if (mediaBlobUrls[originalFileName]) {
      return mediaBlobUrls[originalFileName];
    }

    let zipFileNameToTry = originalFileName;
    const mappedZipName = Object.keys(mediaFileMap).find(key => mediaFileMap[key] === originalFileName);
    if (mappedZipName) {
      zipFileNameToTry = mappedZipName;
    }
    
    let fileInZip;
    // Prioritize mapped name, then original name. Check root then common 'media/' prefix.
    const potentialPaths = [
      zipFileNameToTry, 
      originalFileName, 
      `media/${zipFileNameToTry}`,
      `media/${originalFileName}`
    ];

    for (const path of potentialPaths) {
        if (zip.files[path]) {
            fileInZip = zip.file(path);
            break;
        }
    }
    
    if (fileInZip) {
      try {
        const blob = await fileInZip.async("blob");
        const url = URL.createObjectURL(blob);
        mediaBlobUrls[originalFileName] = url; // Cache by original requested name
        return url;
      } catch (error) {
        console.error(`Error loading media ${originalFileName} (tried as ${fileInZip.name}):`, error);
        return "";
      }
    }
    console.warn(`Media file not found in zip: ${originalFileName} (tried variants including ${zipFileNameToTry})`);
    return "";
  }

  async function renderAnkiTemplate(templateStr, fieldsData, modelFieldsArray, context, zip, mediaFileMap) {
    let output = templateStr;

    if (context.isFront === false && typeof context.frontContentForBack === 'string') {
      output = output.replace(/\{\{FrontSide\}\}/gi, context.frontContentForBack);
    }
    
    output = output.replace(/\{\{#(.+?)\}\}([\s\S]*?)\{\{\/\1\}\}/gi, (match, fieldName, content) => {
      const fName = fieldName.trim();
      const fieldValue = fieldsData[fName];
      return (fieldValue && fieldValue.toString().trim() !== "") ? content : "";
    });
    output = output.replace(/\{\{\^(.+?)\}\}([\s\S]*?)\{\{\/\1\}\}/gi, (match, fieldName, content) => {
      const fName = fieldName.trim();
      const fieldValue = fieldsData[fName];
      return (!fieldValue || fieldValue.toString().trim() === "") ? content : "";
    });

    modelFieldsArray.forEach(field => {
      const fieldName = field.name;
      const fieldValue = fieldsData[fieldName] || "";
      const escapedFieldName = fieldName.replace(/([:\\^#\/\?\{\}])/g, "\\$1");
      
      output = output.replace(new RegExp(`\\{\\{${escapedFieldName}\\}\\}`, 'gi'), fieldValue);
      output = output.replace(new RegExp(`\\{\\{edit:${escapedFieldName}\\}\\}`, 'gi'), fieldValue);
      output = output.replace(new RegExp(`\\{\\{cloze:${escapedFieldName}\\}\\}`, 'gi'), fieldValue); // Basic cloze: show full content
      // Handle other common prefixes like hint:, type:, etc. by just showing the field content
      output = output.replace(new RegExp(`\\{\\{[^:]+?:${escapedFieldName}\\}\\}`, 'gi'), fieldValue);
    });
    
    output = output.replace(/\{\{Tags\}\}/gi, context.noteTags || "");
    output = output.replace(/\{\{Type\}\}/gi, context.modelName || "");
    output = output.replace(/\{\{Deck\}\}/gi, context.deckName || "");
    output = output.replace(/\{\{Card\}\}/gi, context.cardTypeName || "");
    output = output.replace(/\{\{Subdeck\}\}/gi, context.deckName || ""); // Simplification: Subdeck = Deck

    const imgRegex = /<img\s[^>]*src\s*=\s*['"]?([^'">\s]+)['"]?[^>]*>/gi;
    let imgMatch;
    const imgReplacements = [];
    while ((imgMatch = imgRegex.exec(output)) !== null) {
      imgReplacements.push({ placeholder: imgMatch[0], src: imgMatch[1], originalTag: imgMatch[0] });
    }
    for (const rep of imgReplacements) {
      const mediaUrl = await getMediaURL(rep.src, zip, mediaFileMap);
      let newImgTag = rep.originalTag;
      if (mediaUrl) {
        newImgTag = newImgTag.replace(new RegExp(rep.src.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "g"), mediaUrl);
      } else {
        if (!/alt=/i.test(newImgTag)) {
            newImgTag = newImgTag.replace(/<img/i, `<img alt="${rep.src} (not found)"`);
        }
      }
      output = output.replace(rep.placeholder, newImgTag);
    }

    const soundRegex = /\[sound:([^\]]+?)\]/gi;
    let soundMatch;
    const soundReplacements = [];
    while ((soundMatch = soundRegex.exec(output)) !== null) {
      const soundSrc = soundMatch[1].split(',')[0].trim(); // Get filename, ignore options
      soundReplacements.push({ placeholder: soundMatch[0], src: soundSrc });
    }
    for (const rep of soundReplacements) {
      const mediaUrl = await getMediaURL(rep.src, zip, mediaFileMap);
      if (mediaUrl) {
        output = output.replace(rep.placeholder, `<audio controls src="${mediaUrl}"></audio>`);
      } else {
        output = output.replace(rep.placeholder, `<span style="color:orange; font-style:italic;">[Audio: ${rep.src} (not found)]</span>`);
      }
    }
    return output;
  }


  initSqlJs({ locateFile: f => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/${f}` })
  .then(SQL => {
    const fileInput = document.getElementById('fileInput');
    const feed = document.getElementById('feed');

    fileInput.addEventListener('change', async e => {
      clearMediaBlobUrls();
      const file = e.target.files[0];
      if (!file) return;
      feed.innerHTML = '<p class="message">Loading deck...</p>';

      try {
        const fileData = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(fileData);
        const dbPath = Object.keys(zip.files).find(p => /collection\.anki21?$/i.test(p));

        if (!dbPath) {
          feed.innerHTML = `<p class="message error">Could not find <code>collection.anki2</code> or <code>collection.anki21</code>.</p>`;
          return;
        }
        const dbFile = zip.file(dbPath);
        if (!dbFile) throw new Error(`Database file ${dbPath} not found in zip.`);
        
        const dbData = new Uint8Array(await dbFile.async('arraybuffer'));
        const db = new SQL.Database(dbData);

        let mediaFileMap = {};
        const mediaMapFile = zip.file("media");
        if (mediaMapFile) {
          try {
            mediaFileMap = JSON.parse(await mediaMapFile.async("string"));
          } catch (err) {
            console.warn("Error parsing 'media' file:", err);
          }
        }

        const colQuery = db.exec("SELECT models, decks FROM col LIMIT 1");
        if (!colQuery?.[0]?.values?.[0]) throw new Error("Failed to query 'col' table.");
        const modelsData = JSON.parse(colQuery[0].values[0][0]);
        const decksData = JSON.parse(colQuery[0].values[0][1]);

        const notesQuery = db.exec("SELECT id, mid, flds, tags FROM notes");
        const notesMap = {};
        notesQuery?.[0]?.values?.forEach(row => {
            notesMap[row[0]] = { mid: row[1].toString(), fldsArray: row[2].split('\x1f'), tagsArray: row[3].trim().split(' ').filter(t => t) };
        });
        
        const cardsResult = db.exec("SELECT id, nid, did, ord FROM cards ORDER BY id");
        let allCards = cardsResult?.[0]?.values?.map(row => ({ id: row[0], nid: row[1], did: row[2], ord: row[3] })) || [];

        if (allCards.length === 0) {
          feed.innerHTML = '<p class="message">No cards found in the deck.</p>';
          return;
        }

        const cardsToDisplay = allCards.slice(0, MAX_CARDS_TO_DISPLAY);
        feed.innerHTML = ''; 
        if (allCards.length > MAX_CARDS_TO_DISPLAY) {
            feed.innerHTML = `<p class="message">Displaying ${MAX_CARDS_TO_DISPLAY} of ${allCards.length} cards.</p>`;
        }

        for (const cardData of cardsToDisplay) {
          const note = notesMap[cardData.nid];
          const model = modelsData[note?.mid];
          const template = model?.tmpls?.[cardData.ord];

          if (!note || !model || !template) {
            console.warn(`Skipping card id ${cardData.id}: missing note, model, or template.`);
            continue;
          }

          const fieldsData = {};
          model.flds.forEach((fieldSchema, index) => {
            fieldsData[fieldSchema.name] = note.fldsArray[index] || "";
          });

          const cardUniqueId = `card-container-${cardData.id}-${Date.now()}`;
          const cardContainer = document.createElement('div');
          cardContainer.className = 'card-container';
          cardContainer.id = cardUniqueId;

          if (model.css && model.css.trim() !== "") {
            const styleElement = document.createElement('style');
            let scopedCss = model.css;
            // Basic scoping for common Anki selectors.
            // Targets .card, .cloze, body (when at start of line, common in Anki CSS for card body)
            scopedCss = scopedCss.replace(/\.card(?=[^a-zA-Z0-9\-])/g, `#${cardUniqueId} .card-content-wrapper`);
            scopedCss = scopedCss.replace(/\.cloze(?=[^a-zA-Z0-9\-])/g, `#${cardUniqueId} .cloze`);
            scopedCss = scopedCss.replace(/^body\s*\{/gm, `#${cardUniqueId} .card-content-wrapper {`);
            // A more specific scope for .mobile .card if body itself might have .mobile
            scopedCss = scopedCss.replace(/\.mobile\s+\.card(?=[^a-zA-Z0-9\-])/g, `body.mobile #${cardUniqueId} .card-content-wrapper`);


            styleElement.textContent = scopedCss;
            cardContainer.appendChild(styleElement);
          }
          
          // The .card div is for structure/swipe, .card-content-wrapper is for Anki's CSS.
          const cardElement = document.createElement('div');
          cardElement.className = 'card card-content-wrapper'; 

          const frontDiv = document.createElement('div');
          frontDiv.className = 'front';
          const backDiv = document.createElement('div');
          backDiv.className = 'back';

          const deckName = decksData[cardData.did.toString()]?.name || "Unknown Deck";
          const renderContextBase = {
            noteTags: note.tagsArray.join(' '),
            modelName: model.name,
            deckName: deckName,
            cardTypeName: template.name,
          };
          
          // Render front for {{FrontSide}} (fields replaced, media placeholders)
          const preRenderedFrontForBack = await renderAnkiTemplate(
            template.qfmt, fieldsData, model.flds, 
            { ...renderContextBase, isFront: true }, // No zip/mediaMap here, rely on string replacement
            null, {} // Pass null zip and empty mediaMap for pre-render
          );

          // Fully render front HTML (with media)
          const frontHTML = await renderAnkiTemplate(
            template.qfmt, fieldsData, model.flds,
            { ...renderContextBase, isFront: true },
            zip, mediaFileMap
          );
          frontDiv.innerHTML = frontHTML;
          
          // Fully render back HTML (with media and {{FrontSide}})
          const backHTML = await renderAnkiTemplate(
            template.afmt, fieldsData, model.flds,
            { ...renderContextBase, isFront: false, frontContentForBack: preRenderedFrontForBack },
            zip, mediaFileMap
          );
          backDiv.innerHTML = backHTML;

          cardElement.appendChild(backDiv);
          cardElement.appendChild(frontDiv);
          cardContainer.appendChild(cardElement);
          feed.appendChild(cardContainer);

          const setHeight = () => {
            requestAnimationFrame(() => {
                const frontScrollHeight = frontDiv.scrollHeight;
                const backScrollHeight = backDiv.scrollHeight;
                cardElement.style.height = Math.max(frontScrollHeight, backScrollHeight, 120) + 'px'; // Min height 120px
            });
          };

          // Attempt to set height after images/audio might have loaded
          const mediaElements = Array.from(cardElement.querySelectorAll('img, audio'));
          if (mediaElements.length > 0) {
            let loadedCount = 0;
            mediaElements.forEach(el => {
              if (el.tagName === 'IMG') {
                if (el.complete) loadedCount++;
                else el.onload = el.onerror = () => { loadedCount++; if (loadedCount === mediaElements.length) setHeight(); };
              } else if (el.tagName === 'AUDIO') { // Audio metadata usually loads fast
                if (el.readyState >= 1) loadedCount++; // HAVE_METADATA
                else el.onloadedmetadata = el.onerror = () => { loadedCount++; if (loadedCount === mediaElements.length) setHeight(); };
              }
            });
            if (loadedCount === mediaElements.length) setHeight();
          } else {
            setHeight();
          }

          let startX = 0, currentX = 0, translateX = 0, isDragging = false;
          const swipeThreshold = cardElement.offsetWidth / 3.5; // Swipe 1/3.5 of card width

          frontDiv.addEventListener('pointerdown', e => {
            if (e.button !== 0) return;
            isDragging = true;
            startX = e.clientX; currentX = startX;
            frontDiv.style.transition = 'none';
            e.currentTarget.setPointerCapture(e.pointerId);
          });

          frontDiv.addEventListener('pointermove', e => {
            if (!isDragging) return;
            currentX = e.clientX;
            translateX = Math.min(0, currentX - startX); // Swipe left only
            frontDiv.style.transform = `translateX(${translateX}px)`;
          });

          const flipCard = (reveal) => {
            frontDiv.style.transition = 'transform 0.3s ease';
            frontDiv.style.transform = reveal ? 'translateX(-100%)' : 'translateX(0px)';
          };

          frontDiv.addEventListener('pointerup', e => {
            if (!isDragging) return;
            isDragging = false;
            e.currentTarget.releasePointerCapture(e.pointerId);
            flipCard(translateX < -swipeThreshold);
          });
          
          frontDiv.addEventListener('click', e => {
            if (Math.abs(currentX - startX) > 10) return; // Was a drag, not a click
            const matrix = new DOMMatrixReadOnly(getComputedStyle(frontDiv).transform);
            flipCard(matrix.m41 >= -10); // If mostly front, flip to back; else to front
          });
        }

        if (feed.children.length === (allCards.length > MAX_CARDS_TO_DISPLAY ? 1:0) && cardsToDisplay.length > 0) {
             feed.innerHTML += '<p class="message error">Finished processing, but no cards could be rendered. Check console.</p>';
        }

      } catch (err) {
        console.error("Fatal Error:", err);
        feed.innerHTML = `<p class="message error">Error processing deck: ${err.message}. Check console.</p>`;
      }
    });
  });
</script>
</body>
</html>