<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Matilda ‚Äî 100 Easy Lessons</title>
  <style>
    :root{
      --bg:#070812;
      --panel:rgba(255,255,255,.08);
      --panel2:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --shadow: 0 16px 40px rgba(0,0,0,.45);
      --ok:#34d399;
      --next:#8b5cf6;
    }
    html,body{
      height:100%; margin:0;
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(139,92,246,.35), transparent 60%),
        radial-gradient(900px 600px at 80% 15%, rgba(34,211,238,.25), transparent 55%),
        radial-gradient(900px 700px at 40% 80%, rgba(251,113,133,.18), transparent 60%),
        var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }
    #app{position:fixed; inset:0; display:flex; flex-direction:column;}
    #topbar{
      display:flex; gap:10px; align-items:center;
      padding:12px; z-index:5;
    }
    .chip{
      background:var(--panel);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      user-select:none;
    }
    .title{font-weight:900; letter-spacing:.2px}
    .sub{font-size:12px; color:var(--muted)}
    #progressWrap{flex:1; min-width:0;}
    .bar{
      height:12px; border-radius:999px;
      background:rgba(255,255,255,.10);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      margin-top:8px;
    }
    .bar > i{
      display:block; height:100%; width:0%;
      background:linear-gradient(90deg, rgba(34,211,238,.95), rgba(139,92,246,.95), rgba(251,113,133,.95));
      border-radius:999px;
      transition: width 420ms cubic-bezier(.2,.8,.2,1);
    }
    #canvasWrap{position:relative; flex:1; min-height:0;}
    canvas{display:block; width:100%; height:100%;}

    #dock{
      display:flex; gap:10px; padding:12px;
      justify-content:space-between; align-items:center; z-index:5;
    }
    .btn{
      border:none; cursor:pointer; color:var(--text);
      padding:14px 16px; border-radius:16px;
      background:linear-gradient(135deg, rgba(34,211,238,.25), rgba(139,92,246,.30));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      font-weight:950;
      min-width: 200px;
      user-select:none;
    }
    .btn.secondary{
      min-width:auto;
      background:rgba(255,255,255,.07);
      padding:14px 14px;
    }
    .btn:active{transform: translateY(1px);}

    /* Overlays */
    .overlay{position:fixed; inset:0; display:none; place-items:center; z-index:20;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .overlay.show{display:grid;}
    .modal{
      width:min(560px, calc(100vw - 28px));
      border-radius:24px;
      background:rgba(10,10,18,.78);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 26px 70px rgba(0,0,0,.6);
      padding:16px;
    }
    .modal h2{margin:4px 6px 6px; font-size:18px}
    .modal p{margin:0 6px 12px; color:var(--muted); font-size:13px; line-height:1.35}
    .actions{display:flex; gap:10px; justify-content:flex-end; padding:10px 6px 6px;}
    .mini{min-width:auto; padding:12px 14px; border-radius:14px;}
    .row{display:flex; gap:10px; padding:10px 6px; align-items:center; flex-wrap:wrap;}
    label{font-size:13px; color:var(--muted); font-weight:900}
    input[type="number"]{
      width:110px; padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.07);
      color:var(--text);
      font-weight:950;
      outline:none;
    }
    #toast{
      position:fixed; left:50%; bottom:90px; transform:translateX(-50%);
      padding:12px 14px; border-radius:999px;
      background:rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      font-weight:950;
      display:none; z-index:30;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      max-width: calc(100vw - 28px);
      text-align:center;
      user-select:none;
      white-space:nowrap;
    }
    #toast.show{display:block;}
  </style>
</head>
<body>
  <div id="app">
    <div id="topbar">
      <div class="chip">
        <div class="title">Matilda</div>
        <div class="sub">Teach Your Child to Read in 100 Easy Lessons</div>
      </div>

      <div class="chip" id="progressWrap" style="padding:10px 12px;">
        <div style="display:flex; justify-content:space-between; align-items:baseline; gap:10px;">
          <div class="title">Progress</div>
          <div class="sub"><span id="progressText">0 / 100</span></div>
        </div>
        <div class="bar"><i id="progressBar"></i></div>
      </div>

      <div class="chip">
        <div class="title">Lesson</div>
        <div class="sub"><span id="currentLessonText">1</span> / 100</div>
      </div>
    </div>

    <div id="canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div id="dock">
      <button class="btn" id="completeBtn" type="button">‚úÖ Complete Lesson</button>
      <button class="btn secondary" id="settingsBtn" type="button">‚öôÔ∏è</button>
    </div>
  </div>

  <div class="overlay" id="confirmOverlay">
    <div class="modal">
      <h2 id="confirmTitle">Complete lesson?</h2>
      <p id="confirmText">Did we finish Lesson 1?</p>
      <div class="actions">
        <button class="btn mini" id="confirmNo" type="button">Not yet</button>
        <button class="btn mini" id="confirmYes" type="button">Yes!</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="settingsOverlay">
    <div class="modal">
      <h2>Settings</h2>
      <p>Hold the gear for ~1 second to open (parent-only). Set where you are.</p>

      <div class="row">
        <label for="currentInput">Current lesson</label>
        <input id="currentInput" type="number" min="1" max="100" />
        <label for="completedInput">Completed up to</label>
        <input id="completedInput" type="number" min="0" max="100" />
      </div>

      <div class="actions">
        <button class="btn mini" id="settingsClose" type="button">Close</button>
        <button class="btn mini" id="settingsSave" type="button">Save</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <!-- Three.js non-module (more reliable on iOS/local files) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    /**************
     * State
     **************/
    const STORAGE_KEY = "matilda_100_easy_lessons_v1";
    const clamp = (n,min,max)=>Math.max(min, Math.min(max, n));

    function defaultState(){
      return { current: 1, completedUpTo: 0 };
    }
    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return defaultState();
        const s = JSON.parse(raw);
        return {
          current: clamp(Number(s.current||1), 1, 100),
          completedUpTo: clamp(Number(s.completedUpTo||0), 0, 100)
        };
      }catch{
        return defaultState();
      }
    }
    function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
    let state = loadState();

    /**************
     * UI
     **************/
    const $ = (id)=>document.getElementById(id);
    const progressText = $("progressText");
    const progressBar = $("progressBar");
    const currentLessonText = $("currentLessonText");
    const completeBtn = $("completeBtn");

    const confirmOverlay = $("confirmOverlay");
    const confirmText = $("confirmText");
    const confirmNo = $("confirmNo");
    const confirmYes = $("confirmYes");

    const settingsBtn = $("settingsBtn");
    const settingsOverlay = $("settingsOverlay");
    const settingsClose = $("settingsClose");
    const settingsSave = $("settingsSave");
    const currentInput = $("currentInput");
    const completedInput = $("completedInput");

    const toast = $("toast");
    let toastTimer=null;
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer=setTimeout(()=>toast.classList.remove("show"), 1100);
    }

    function updateUI(){
      progressText.textContent = `${state.completedUpTo} / 100`;
      progressBar.style.width = `${(state.completedUpTo/100)*100}%`;
      currentLessonText.textContent = String(state.current);
      completeBtn.textContent = (state.completedUpTo>=100) ? "üéâ Finished! (Lesson 100)" : "‚úÖ Complete Lesson";
    }

    completeBtn.onclick = ()=>{
      const cur = state.current;
      confirmText.textContent = `Did we finish Lesson ${cur}?`;
      confirmOverlay.classList.add("show");
    };
    confirmNo.onclick = ()=>confirmOverlay.classList.remove("show");
    confirmYes.onclick = ()=>{
      confirmOverlay.classList.remove("show");
      completeCurrentLesson();
    };

    function completeCurrentLesson(){
      const cur = state.current;
      state.completedUpTo = Math.max(state.completedUpTo, cur);
      state.current = clamp(cur+1, 1, 100);
      saveState();
      updateUI();
      refreshNodeStyles();
      hopToLesson(state.current, true);
      if(state.completedUpTo>=100) showToast("Goal reached!");
      else if(cur % 10 === 0) showToast(`‚≠ê Lesson ${cur}!`);
      else showToast("Nice work!");
    }

    // Parent-only settings hold (~1s)
    let holdTimer=null;
    function startHold(){
      holdTimer=setTimeout(()=>{
        currentInput.value = state.current;
        completedInput.value = state.completedUpTo;
        settingsOverlay.classList.add("show");
        showToast("Settings");
      }, 900);
    }
    function endHold(){
      if(holdTimer){
        clearTimeout(holdTimer);
        holdTimer=null;
        showToast("Hold to open");
      }
    }
    settingsBtn.addEventListener("touchstart",(e)=>{e.preventDefault(); startHold();},{passive:false});
    settingsBtn.addEventListener("touchend",(e)=>{e.preventDefault(); endHold();},{passive:false});
    settingsBtn.addEventListener("mousedown",(e)=>{e.preventDefault(); startHold();});
    settingsBtn.addEventListener("mouseup",(e)=>{e.preventDefault(); endHold();});
    settingsBtn.addEventListener("mouseleave",()=>{ if(holdTimer){clearTimeout(holdTimer); holdTimer=null;} });

    settingsClose.onclick = ()=>settingsOverlay.classList.remove("show");
    settingsOverlay.onclick = (e)=>{ if(e.target===settingsOverlay) settingsOverlay.classList.remove("show"); };
    settingsSave.onclick = ()=>{
      state.current = clamp(Number(currentInput.value||1), 1, 100);
      state.completedUpTo = clamp(Number(completedInput.value||0), 0, 100);
      saveState();
      updateUI();
      settingsOverlay.classList.remove("show");
      refreshNodeStyles();
      hopToLesson(state.current, false);
      showToast("Saved");
    };

    /**************
     * Three.js scene
     **************/
    const canvas = $("c");
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 500);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const key = new THREE.DirectionalLight(0xffffff, 1.25); key.position.set(8, 12, 6); scene.add(key);
    const rim = new THREE.DirectionalLight(0x88ccff, 0.6); rim.position.set(-10, 7, -8); scene.add(rim);

    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(260,260),
      new THREE.MeshStandardMaterial({color:0x0b0c18, roughness:0.95, metalness:0.0, emissive:0x0b0c18, emissiveIntensity:0.85})
    );
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -1.35;
    scene.add(floor);

    // Sparkles
    const sparkleGeo = new THREE.BufferGeometry();
    const sparkleCount = 800;
    const sparklePos = new Float32Array(sparkleCount*3);
    for(let i=0;i<sparkleCount;i++){
      const r = 34*Math.random();
      const a = Math.random()*Math.PI*2;
      sparklePos[i*3+0] = Math.cos(a)*r + (Math.random()-0.5)*8;
      sparklePos[i*3+1] = Math.random()*11 + 0.5;
      sparklePos[i*3+2] = Math.sin(a)*r + (Math.random()-0.5)*8;
    }
    sparkleGeo.setAttribute("position", new THREE.BufferAttribute(sparklePos,3));
    const sparkles = new THREE.Points(sparkleGeo, new THREE.PointsMaterial({color:0xffffff, size:0.06, transparent:true, opacity:0.5}));
    scene.add(sparkles);

    // Path
    const pathGroup = new THREE.Group();
    scene.add(pathGroup);

    const nodes = [];     // {idx, disc, ring, pos}
    const pickables = []; // discs for raycast

    // Bigger spacing: helix-ish path around a gentle spiral
    // This gives ‚Äúnice spacing‚Äù and lets you rotate around and see the path.
    function nodePosition(i){
      const t = (i-1)/99;                 // 0..1
      const turns = 1.55;                 // how much it wraps
      const ang = t * Math.PI * 2 * turns;
      const radius = 10.5 + t*7.0;        // spiral outward
      const y = (t - 0.5) * 2.4;          // gentle vertical variation
      return new THREE.Vector3(Math.cos(ang)*radius, y, Math.sin(ang)*radius);
    }

    const nodeBaseMat = new THREE.MeshStandardMaterial({color:0x1b1f3a, roughness:0.35, metalness:0.25});
    const nodeDoneMat = new THREE.MeshStandardMaterial({color:0x34d399, roughness:0.25, metalness:0.2, emissive:0x133d35, emissiveIntensity:0.95});
    const nodeNextMat = new THREE.MeshStandardMaterial({color:0x8b5cf6, roughness:0.22, metalness:0.3, emissive:0x2a0f6a, emissiveIntensity:1.25});

    const ringGeo = new THREE.TorusGeometry(0.86, 0.10, 12, 64);

    function rebuildPath(){
      while(pathGroup.children.length) pathGroup.remove(pathGroup.children[0]);
      nodes.length = 0;
      pickables.length = 0;

      for(let i=1;i<=100;i++){
        const pos = nodePosition(i);

        const disc = new THREE.Mesh(new THREE.CylinderGeometry(0.92,0.92,0.24,40), nodeBaseMat);
        disc.position.copy(pos);
        disc.userData.idx = i;
        pathGroup.add(disc);
        pickables.push(disc);

        const ring = new THREE.Mesh(ringGeo, nodeBaseMat);
        ring.position.copy(pos);
        ring.rotation.x = Math.PI/2;
        ring.userData.idx = i;
        pathGroup.add(ring);

        nodes.push({idx:i, disc, ring, pos});
      }
      refreshNodeStyles();
    }

    function refreshNodeStyles(){
      const done = state.completedUpTo;
      const next = clamp(done+1, 1, 100);

      // show a roomy window so it feels like you can ‚Äúlook around‚Äù
      const cur = state.current;
      const lo = cur - 18;
      const hi = cur + 22;

      for(const n of nodes){
        const i = n.idx;
        let mat = nodeBaseMat;
        if(i <= done) mat = nodeDoneMat;
        else if(i === next) mat = nodeNextMat;

        n.disc.material = mat;
        n.ring.material = mat;

        const far = (i < lo || i > hi);
        const s = far ? 0.65 : 1.0;
        n.disc.scale.setScalar(s);
        n.ring.scale.setScalar(s);

        // keep more visible than before; only hide very far away
        const tooFar = (i < cur - 40 || i > cur + 44);
        n.disc.visible = !tooFar;
        n.ring.visible = !tooFar;
      }
    }

    // Ball
    const ball = new THREE.Mesh(
      new THREE.SphereGeometry(0.65, 44, 44),
      new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.16, metalness:0.25, emissive:0x22104a, emissiveIntensity:0.5})
    );
    scene.add(ball);

    const ballRing = new THREE.Mesh(
      new THREE.TorusGeometry(0.85,0.07,12,64),
      new THREE.MeshStandardMaterial({color:0x22d3ee, emissive:0x22d3ee, emissiveIntensity:1.45, roughness:0.35, metalness:0.0})
    );
    ballRing.rotation.x = Math.PI/2;
    scene.add(ballRing);

    function setBallAtLesson(idx){
      const p = nodes[idx-1]?.pos;
      if(!p) return;
      ball.position.set(p.x, p.y + 1.05, p.z);
      ballRing.position.set(p.x, p.y + 1.05, p.z);
    }

    // Confetti burst
    const burstCount = 260;
    const burstGeo = new THREE.BufferGeometry();
    const burstPos = new Float32Array(burstCount*3);
    const burstVel = new Float32Array(burstCount*3);
    for(let i=0;i<burstCount;i++){
      burstPos[i*3+1] = -999;
      burstVel[i*3+0] = (Math.random()-0.5)*8;
      burstVel[i*3+1] = Math.random()*10 + 6;
      burstVel[i*3+2] = (Math.random()-0.5)*8;
    }
    burstGeo.setAttribute("position", new THREE.BufferAttribute(burstPos,3));
    const burstMat = new THREE.PointsMaterial({color:0xffffff, size:0.12, transparent:true, opacity:0.92});
    const burst = new THREE.Points(burstGeo, burstMat);
    scene.add(burst);

    let burstActive=false, burstT=0;
    function triggerBurst(at){
      burstActive=true; burstT=0;
      const posAttr = burst.geometry.getAttribute("position");
      for(let i=0;i<burstCount;i++){
        posAttr.array[i*3+0] = at.x;
        posAttr.array[i*3+1] = at.y + 0.3;
        posAttr.array[i*3+2] = at.z;
        burstVel[i*3+0] = (Math.random()-0.5)*8;
        burstVel[i*3+1] = Math.random()*10 + 6;
        burstVel[i*3+2] = (Math.random()-0.5)*8;
      }
      posAttr.needsUpdate = true;
      burstMat.opacity = 0.95;
    }

    // Camera orbit controls (simple, touch-friendly)
    // Drag to rotate, pinch to zoom, two-finger drag to pan (basic).
    const orbit = {
      yaw: 0.8,
      pitch: 0.35,
      dist: 26,
      target: new THREE.Vector3(0,0,0),
      vyaw: 0,
      vpitch: 0
    };

    function focusTargetOnLesson(idx, snap){
      const p = nodes[idx-1]?.pos;
      if(!p) return;
      orbit.target.copy(p);
      if(snap){
        orbit.yaw = 0.8;
        orbit.pitch = 0.35;
        orbit.dist = 26;
      }
    }

    function updateCamera(dt){
      // inertia
      orbit.vyaw *= Math.pow(0.02, dt);
      orbit.vpitch *= Math.pow(0.02, dt);
      orbit.yaw += orbit.vyaw;
      orbit.pitch = clamp(orbit.pitch + orbit.vpitch, -0.25, 1.2);

      const cp = Math.cos(orbit.pitch);
      const sp = Math.sin(orbit.pitch);
      const cy = Math.cos(orbit.yaw);
      const sy = Math.sin(orbit.yaw);

      const x = orbit.target.x + orbit.dist * (cp * sy);
      const y = orbit.target.y + orbit.dist * (sp) + 6.0;
      const z = orbit.target.z + orbit.dist * (cp * cy);

      camera.position.lerp(new THREE.Vector3(x,y,z), 1 - Math.pow(0.001, dt));
      camera.lookAt(orbit.target);
    }

    // Hop animation
    let hopAnim=null;
    function hopToLesson(idx, withBurst){
      const p = nodes[idx-1]?.pos;
      if(!p) return;
      const from = ball.position.clone();
      const to = new THREE.Vector3(p.x, p.y + 1.05, p.z);
      const dist = from.distanceTo(to);
      const duration = clamp(0.50 + dist*0.02, 0.50, 0.95);
      hopAnim = {from, to, t:0, duration, burst:withBurst};
      focusTargetOnLesson(idx, false);
    }

    /**************
     * Picking nodes
     **************/
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function pick(ev){
      const rect = canvas.getBoundingClientRect();
      const cx = (ev.touches ? ev.touches[0].clientX : ev.clientX);
      const cy = (ev.touches ? ev.touches[0].clientY : ev.clientY);
      const x = cx - rect.left;
      const y = cy - rect.top;

      pointer.x = (x / rect.width) * 2 - 1;
      pointer.y = -(y / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(pickables.filter(o=>o.visible), false);
      if(!hits.length) return;

      const idx = hits[0].object.userData.idx;
      if(!idx) return;

      const next = clamp(state.completedUpTo + 1, 1, 100);
      if(idx === next || idx <= state.completedUpTo){
        state.current = idx;
        saveState();
        updateUI();
        refreshNodeStyles();
        hopToLesson(idx, false);
        showToast(idx === next ? `Go to Lesson ${idx}` : `Review Lesson ${idx}`);
      }else{
        showToast("Finish the next one first");
      }
    }

    canvas.addEventListener("mousedown", pick);
    canvas.addEventListener("touchstart", (e)=>{ e.preventDefault(); pick(e); }, {passive:false});

    /**************
     * Orbit interaction
     **************/
    let isDragging=false;
    let lastX=0, lastY=0;
    let activeTouches=0;
    let pinchStartDist=0;
    let distStart=0;

    function touchDist(t0,t1){
      const dx = t0.clientX - t1.clientX;
      const dy = t0.clientY - t1.clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }

    canvas.addEventListener("mousedown", (e)=>{
      isDragging=true; lastX=e.clientX; lastY=e.clientY;
    });
    window.addEventListener("mouseup", ()=>{isDragging=false;});
    window.addEventListener("mousemove", (e)=>{
      if(!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX=e.clientX; lastY=e.clientY;
      orbit.vyaw += dx * 0.004;
      orbit.vpitch += -dy * 0.0032;
    });

    canvas.addEventListener("wheel", (e)=>{
      e.preventDefault();
      orbit.dist = clamp(orbit.dist + e.deltaY*0.02, 14, 54);
    }, {passive:false});

    canvas.addEventListener("touchstart", (e)=>{
      activeTouches = e.touches.length;
      if(activeTouches===1){
        isDragging=true;
        lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;
      }else if(activeTouches===2){
        isDragging=false;
        pinchStartDist = touchDist(e.touches[0], e.touches[1]);
        distStart = orbit.dist;
      }
    }, {passive:true});

    canvas.addEventListener("touchmove", (e)=>{
      if(e.touches.length===1 && isDragging){
        const dx = e.touches[0].clientX - lastX;
        const dy = e.touches[0].clientY - lastY;
        lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;
        orbit.vyaw += dx * 0.004;
        orbit.vpitch += -dy * 0.0032;
      }else if(e.touches.length===2){
        const d = touchDist(e.touches[0], e.touches[1]);
        const ratio = pinchStartDist / Math.max(40, d);
        orbit.dist = clamp(distStart * ratio, 14, 54);
      }
    }, {passive:true});

    canvas.addEventListener("touchend", ()=>{
      isDragging=false;
      activeTouches=0;
    }, {passive:true});

    /**************
     * Resize + init
     **************/
    function resize(){
      const w = canvas.clientWidth || window.innerWidth;
      const h = canvas.clientHeight || window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);

    function init(){
      resize();
      camera.position.set(0, 18, 28);
      rebuildPath();
      updateUI();
      setBallAtLesson(state.current);
      focusTargetOnLesson(state.current, true);
      requestAnimationFrame(tick);
    }
    setTimeout(init, 0);

    /**************
     * Loop
     **************/
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      sparkles.rotation.y += dt*0.08;

      // Ball hop / idle bounce
      if(hopAnim){
        hopAnim.t += dt;
        const u = clamp(hopAnim.t / hopAnim.duration, 0, 1);
        const e = u < 0.5 ? 4*u*u*u : 1 - Math.pow(-2*u + 2, 3)/2;
        const arc = Math.sin(u*Math.PI) * 2.2;

        const p = hopAnim.from.clone().lerp(hopAnim.to, e);
        p.y += arc;

        const squash = 1 - Math.sin(u*Math.PI) * 0.22;
        const stretch = 1 + Math.sin(u*Math.PI) * 0.28;
        ball.scale.set(stretch, squash, stretch);

        ball.position.copy(p);
        ballRing.position.copy(p);
        ballRing.rotation.z = now*0.001;

        if(u>=1){
          ball.scale.set(1,1,1);
          ball.position.copy(hopAnim.to);
          ballRing.position.copy(hopAnim.to);
          if(hopAnim.burst) triggerBurst(ball.position);
          hopAnim=null;
        }
      }else{
        const t = now*0.001;
        ball.position.y = (nodes[state.current-1]?.pos?.y ?? 0) + 1.05 + Math.sin(t*2.2)*0.10;
        ballRing.position.set(ball.position.x, (nodes[state.current-1]?.pos?.y ?? 0) + 1.05, ball.position.z);
        ballRing.rotation.z = t*0.9;
      }

      // Confetti
      if(burstActive){
        burstT += dt;
        const posAttr = burst.geometry.getAttribute("position");
        const g = -16.0;
        for(let i=0;i<burstCount;i++){
          posAttr.array[i*3+0] += burstVel[i*3+0]*dt;
          posAttr.array[i*3+1] += burstVel[i*3+1]*dt;
          posAttr.array[i*3+2] += burstVel[i*3+2]*dt;
          burstVel[i*3+1] += g*dt;
        }
        posAttr.needsUpdate = true;
        burstMat.opacity = Math.max(0, 0.95 - burstT*0.55);
        if(burstT > 1.6){
          burstActive=false;
          for(let i=0;i<burstCount;i++) posAttr.array[i*3+1] = -999;
          posAttr.needsUpdate = true;
        }
      }

      updateCamera(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
  </script>
</body>
</html>
