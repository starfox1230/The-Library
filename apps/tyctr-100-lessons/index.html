<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Matilda Lesson Hopper</title>
  <style>
    :root{
      --bg:#070812;
      --panel:rgba(255,255,255,.08);
      --panel2:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --accent:#8b5cf6;
      --accent2:#22d3ee;
      --danger:#fb7185;
      --ok:#34d399;
      --shadow: 0 16px 40px rgba(0,0,0,.45);
      --radius: 18px;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 700px at 20% 10%, rgba(139,92,246,.35), transparent 60%),
                                         radial-gradient(900px 600px at 80% 15%, rgba(34,211,238,.25), transparent 55%),
                                         radial-gradient(900px 700px at 40% 80%, rgba(251,113,133,.18), transparent 60%),
                                         var(--bg);
      color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }
    #app{position:fixed; inset:0; display:flex; flex-direction:column;}
    #topbar{
      display:flex; gap:12px; align-items:center; padding:12px 12px 10px;
      position:relative; z-index:5;
    }
    .chip{
      background:var(--panel); border:1px solid rgba(255,255,255,.10);
      border-radius:999px; padding:10px 12px; display:flex; align-items:center; gap:10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .chip .title{font-weight:700; letter-spacing:.2px}
    .chip .sub{font-size:12px; color:var(--muted)}
    #progressWrap{flex:1; min-width:0;}
    .bar{
      height:12px; border-radius:999px;
      background:rgba(255,255,255,.10);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
    }
    .bar > i{
      display:block; height:100%; width:0%;
      background:linear-gradient(90deg, rgba(34,211,238,.95), rgba(139,92,246,.95), rgba(251,113,133,.95));
      box-shadow:0 0 18px rgba(139,92,246,.35);
      border-radius:999px;
      transition: width 420ms cubic-bezier(.2,.8,.2,1);
    }
    .seg{
      display:flex; gap:6px;
    }
    .seg button{
      appearance:none; border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:999px;
      font-weight:700;
      cursor:pointer;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .seg button.active{
      background:linear-gradient(135deg, rgba(34,211,238,.22), rgba(139,92,246,.25));
      border-color:rgba(34,211,238,.35);
    }
    #canvasWrap{position:relative; flex:1; min-height:0;}
    canvas{display:block; width:100%; height:100%;}
    #dock{
      position:relative; z-index:5;
      display:flex; gap:10px; padding:12px;
      justify-content:space-between; align-items:center;
    }
    .btn{
      border:none; cursor:pointer; color:var(--text);
      padding:14px 16px; border-radius:16px;
      background:linear-gradient(135deg, rgba(34,211,238,.25), rgba(139,92,246,.30));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      font-weight:800;
      letter-spacing:.2px;
      min-width: 160px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:flex; align-items:center; justify-content:center; gap:10px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.secondary{
      min-width:auto;
      padding:14px 14px;
      background:rgba(255,255,255,.07);
      font-weight:800;
    }
    .btn:active{transform: translateY(1px);}

    /* Modal */
    .overlay{position:fixed; inset:0; display:none; place-items:center; z-index:20;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .overlay.show{display:grid;}
    .modal{
      width:min(560px, calc(100vw - 28px));
      border-radius:24px;
      background:rgba(10,10,18,.78);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 26px 70px rgba(0,0,0,.6);
      padding:16px;
    }
    .modal h2{margin:4px 6px 6px; font-size:18px}
    .modal p{margin:0 6px 12px; color:var(--muted); font-size:13px; line-height:1.35}
    .row{display:flex; gap:10px; padding:10px 6px; align-items:center; flex-wrap:wrap;}
    label{font-size:13px; color:var(--muted); font-weight:700}
    input[type="number"]{
      width:92px; padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.07);
      color:var(--text);
      font-weight:800;
      outline:none;
    }
    .modal .actions{display:flex; gap:10px; justify-content:flex-end; padding:10px 6px 6px;}
    .mini{
      min-width:auto; padding:12px 14px; border-radius:14px;
      background:rgba(255,255,255,.08);
    }
    .danger{
      background:linear-gradient(135deg, rgba(251,113,133,.22), rgba(139,92,246,.18));
      border:1px solid rgba(251,113,133,.28);
    }

    /* Toast */
    #toast{
      position:fixed; left:50%; bottom:90px; transform:translateX(-50%);
      padding:12px 14px; border-radius:999px;
      background:rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      font-weight:800;
      display:none;
      z-index:30;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      max-width: calc(100vw - 28px);
      text-align:center;
      user-select:none;
    }
    #toast.show{display:block; animation: pop 220ms ease-out;}
    @keyframes pop { from { transform:translateX(-50%) translateY(6px); opacity:0 } to { transform:translateX(-50%) translateY(0); opacity:1 } }

    /* Parent-only hold hint */
    .hint{
      font-size:12px; color:rgba(255,255,255,.55); margin-left:6px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="topbar">
      <div class="chip">
        <div>
          <div class="title" id="seriesTitle">Easy Lessons</div>
          <div class="sub" id="seriesSub">Lesson <span id="currentLessonText">1</span> / 100</div>
        </div>
      </div>

      <div class="chip" id="progressWrap">
        <div style="width:100%">
          <div style="display:flex; justify-content:space-between; align-items:baseline; gap:10px;">
            <div class="title">Overall</div>
            <div class="sub"><span id="overallText">0 / 200</span></div>
          </div>
          <div class="bar" style="margin-top:8px;"><i id="overallBar"></i></div>
        </div>
      </div>

      <div class="seg chip" style="padding:6px;">
        <button id="btnEasy" class="active" type="button">Easy</button>
        <button id="btnTCR" type="button">Teacher</button>
      </div>
    </div>

    <div id="canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div id="dock">
      <button class="btn" id="completeBtn" type="button">‚úÖ Complete Lesson</button>
      <button class="btn secondary" id="settingsBtn" type="button" aria-label="Settings">‚öôÔ∏è</button>
    </div>
  </div>

  <!-- Confirm complete -->
  <div class="overlay" id="confirmOverlay">
    <div class="modal">
      <h2 id="confirmTitle">Complete lesson?</h2>
      <p id="confirmText">Did we finish Lesson 1?</p>
      <div class="actions">
        <button class="btn mini" id="confirmNo" type="button">Not yet</button>
        <button class="btn mini" id="confirmYes" type="button">Yes!</button>
      </div>
    </div>
  </div>

  <!-- Settings (parent hold to open) -->
  <div class="overlay" id="settingsOverlay">
    <div class="modal">
      <h2>Settings</h2>
      <p>Set where you are. This is parent-only.</p>

      <div class="row">
        <label for="easyCurrent">Easy current</label>
        <input id="easyCurrent" type="number" min="1" max="100" />
        <label for="easyCompleted">Easy completed up to</label>
        <input id="easyCompleted" type="number" min="0" max="100" />
      </div>

      <div class="row">
        <label for="tcrCurrent">Teacher current</label>
        <input id="tcrCurrent" type="number" min="1" max="100" />
        <label for="tcrCompleted">Teacher completed up to</label>
        <input id="tcrCompleted" type="number" min="0" max="100" />
      </div>

      <div class="row">
        <button class="btn mini danger" id="resetBtn" type="button">Reset all</button>
        <span class="hint">Tip: reset is instant.</span>
      </div>

      <div class="actions">
        <button class="btn mini" id="settingsClose" type="button">Close</button>
        <button class="btn mini" id="settingsSave" type="button">Save</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <!-- Three.js -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    /**************
     * Data + State
     **************/
    const STORAGE_KEY = "matildaLessonHopper_v1";

    const defaultState = () => ({
      easy: { current: 1, completedUpTo: 0 },
      teacher: { current: 1, completedUpTo: 0 },
      activeSeries: "easy"
    });

    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return defaultState();
        const s = JSON.parse(raw);
        // basic hardening
        for (const k of ["easy","teacher"]) {
          s[k] ??= {};
          s[k].current = clamp(Number(s[k].current ?? 1), 1, 100);
          s[k].completedUpTo = clamp(Number(s[k].completedUpTo ?? 0), 0, 100);
        }
        s.activeSeries = (s.activeSeries === "teacher") ? "teacher" : "easy";
        return s;
      }catch{
        return defaultState();
      }
    }

    function saveState(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    let state = loadState();

    function seriesKey(){ return state.activeSeries; }
    function seriesLabel(){ return (seriesKey() === "easy") ? "Easy Lessons" : "Teacher-Child Read"; }
    function seriesShort(){ return (seriesKey() === "easy") ? "Easy" : "Teacher"; }
    function currentLesson(){ return state[seriesKey()].current; }
    function completedUpTo(){ return state[seriesKey()].completedUpTo; }
    function overallCompleted(){
      return state.easy.completedUpTo + state.teacher.completedUpTo;
    }
    function unlocked(){
      return state.easy.completedUpTo >= 100 && state.teacher.completedUpTo >= 100;
    }

    /**************
     * UI
     **************/
    const $ = (id) => document.getElementById(id);
    const seriesTitleEl = $("seriesTitle");
    const seriesSubEl = $("seriesSub");
    const currentLessonTextEl = $("currentLessonText");
    const overallTextEl = $("overallText");
    const overallBarEl = $("overallBar");

    const btnEasy = $("btnEasy");
    const btnTCR = $("btnTCR");
    const completeBtn = $("completeBtn");

    const confirmOverlay = $("confirmOverlay");
    const confirmTitle = $("confirmTitle");
    const confirmText = $("confirmText");
    const confirmNo = $("confirmNo");
    const confirmYes = $("confirmYes");

    const settingsBtn = $("settingsBtn");
    const settingsOverlay = $("settingsOverlay");
    const settingsClose = $("settingsClose");
    const settingsSave = $("settingsSave");
    const resetBtn = $("resetBtn");

    const easyCurrent = $("easyCurrent");
    const easyCompleted = $("easyCompleted");
    const tcrCurrent = $("tcrCurrent");
    const tcrCompleted = $("tcrCompleted");

    const toast = $("toast");
    let toastTimer = null;
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toast.classList.remove("show"), 1200);
    }

    function updateUI(){
      seriesTitleEl.textContent = seriesLabel();
      currentLessonTextEl.textContent = String(currentLesson());
      seriesSubEl.innerHTML = `Lesson <span id="currentLessonText">${currentLesson()}</span> / 100`;

      const oc = overallCompleted();
      overallTextEl.textContent = `${oc} / 200`;
      overallBarEl.style.width = `${(oc/200)*100}%`;

      btnEasy.classList.toggle("active", seriesKey()==="easy");
      btnTCR.classList.toggle("active", seriesKey()==="teacher");

      // If finished, make complete button celebrate but still usable
      if(unlocked()){
        completeBtn.textContent = "üéâ Trampoline Unlocked!";
      }else{
        completeBtn.textContent = "‚úÖ Complete Lesson";
      }
    }

    btnEasy.addEventListener("click", () => {
      state.activeSeries = "easy";
      saveState();
      updateUI();
      focusOnCurrent(true);
      refreshNodeStyles();
    });
    btnTCR.addEventListener("click", () => {
      state.activeSeries = "teacher";
      saveState();
      updateUI();
      focusOnCurrent(true);
      refreshNodeStyles();
    });

    completeBtn.addEventListener("click", () => {
      const cur = currentLesson();
      confirmTitle.textContent = (unlocked() ? "All done!" : "Complete lesson?");
      confirmText.textContent = `Did we finish Lesson ${cur} (${seriesShort()})?`;
      confirmOverlay.classList.add("show");
    });

    confirmNo.addEventListener("click", ()=> confirmOverlay.classList.remove("show"));
    confirmYes.addEventListener("click", ()=>{
      confirmOverlay.classList.remove("show");
      completeCurrentLesson();
    });

    function completeCurrentLesson(){
      const key = seriesKey();
      const cur = state[key].current;

      // mark completed up to at least current
      state[key].completedUpTo = Math.max(state[key].completedUpTo, cur);

      // advance current if possible
      const next = clamp(cur + 1, 1, 100);
      state[key].current = next;

      saveState();
      updateUI();

      // bounce to next node (if within range)
      hopToLesson(next, true);

      if(unlocked()){
        showToast("Trampoline Time unlocked!");
      }else if(cur % 10 === 0){
        showToast(`‚≠ê Level ${cur}!`);
      }else{
        showToast("Nice work!");
      }
      refreshNodeStyles();
    }

    /**************
     * Settings (hold)
     **************/
    let holdTimer = null;
    let holdStart = 0;

    function openSettings(){
      // populate fields
      easyCurrent.value = String(state.easy.current);
      easyCompleted.value = String(state.easy.completedUpTo);
      tcrCurrent.value = String(state.teacher.current);
      tcrCompleted.value = String(state.teacher.completedUpTo);
      settingsOverlay.classList.add("show");
    }

    function closeSettings(){
      settingsOverlay.classList.remove("show");
    }

    function startHold(){
      holdStart = performance.now();
      holdTimer = setTimeout(()=> {
        showToast("Parent settings");
        openSettings();
      }, 900); // hold ~0.9s
    }
    function endHold(){
      clearTimeout(holdTimer);
      const held = performance.now() - holdStart;
      if(held < 900){
        showToast("Hold to open settings");
      }
    }

    settingsBtn.addEventListener("touchstart", (e)=>{ e.preventDefault(); startHold(); }, {passive:false});
    settingsBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); endHold(); }, {passive:false});
    settingsBtn.addEventListener("mousedown", (e)=>{ e.preventDefault(); startHold(); });
    settingsBtn.addEventListener("mouseup", (e)=>{ e.preventDefault(); endHold(); });
    settingsBtn.addEventListener("mouseleave", ()=> clearTimeout(holdTimer));

    settingsClose.addEventListener("click", closeSettings);
    settingsOverlay.addEventListener("click", (e)=>{ if(e.target === settingsOverlay) closeSettings(); });

    settingsSave.addEventListener("click", ()=>{
      const ec = clamp(Number(easyCurrent.value||1), 1, 100);
      const ecomp = clamp(Number(easyCompleted.value||0), 0, 100);
      const tc = clamp(Number(tcrCurrent.value||1), 1, 100);
      const tcomp = clamp(Number(tcrCompleted.value||0), 0, 100);

      state.easy.current = ec;
      state.easy.completedUpTo = ecomp;

      state.teacher.current = tc;
      state.teacher.completedUpTo = tcomp;

      saveState();
      updateUI();
      closeSettings();

      focusOnCurrent(true);
      refreshNodeStyles();
      showToast("Saved");
    });

    resetBtn.addEventListener("click", ()=>{
      state = defaultState();
      saveState();
      updateUI();
      closeSettings();
      rebuildPath();
      showToast("Reset");
    });

    /**************
     * Three.js Scene
     **************/
    const canvas = $("c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.08;

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 200);
    camera.position.set(0, 9.5, 16);

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.55);
    scene.add(ambient);

    const key = new THREE.DirectionalLight(0xffffff, 1.25);
    key.position.set(8, 12, 6);
    scene.add(key);

    const rim = new THREE.DirectionalLight(0x88ccff, 0.65);
    rim.position.set(-10, 7, -8);
    scene.add(rim);

    // Floor glow plane
    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x0b0c18,
      roughness: 0.9,
      metalness: 0.0,
      emissive: 0x0b0c18,
      emissiveIntensity: 0.7
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -1.2;
    scene.add(floor);

    // Sparkles (points)
    const sparkleCount = 900;
    const sparkleGeo = new THREE.BufferGeometry();
    const sparklePos = new Float32Array(sparkleCount*3);
    for(let i=0;i<sparkleCount;i++){
      const r = 30 * Math.random();
      const a = Math.random() * Math.PI * 2;
      sparklePos[i*3+0] = Math.cos(a)*r + (Math.random()-0.5)*6;
      sparklePos[i*3+1] = Math.random()*10 + 0.5;
      sparklePos[i*3+2] = Math.sin(a)*r + (Math.random()-0.5)*6;
    }
    sparkleGeo.setAttribute("position", new THREE.BufferAttribute(sparklePos, 3));
    const sparkleMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.06,
      transparent:true,
      opacity:0.5
    });
    const sparkles = new THREE.Points(sparkleGeo, sparkleMat);
    scene.add(sparkles);

    // Path group
    const pathGroup = new THREE.Group();
    scene.add(pathGroup);

    // Nodes and labels
    const nodes = []; // {mesh, idx, worldPos}
    const nodeHit = []; // for raycast
    const nodeBaseMat = new THREE.MeshStandardMaterial({ color: 0x1b1f3a, roughness: 0.35, metalness: 0.25 });
    const nodeDoneMat = new THREE.MeshStandardMaterial({ color: 0x2ee6b6, roughness: 0.25, metalness: 0.2, emissive: 0x133d35, emissiveIntensity: 0.8 });
    const nodeNextMat = new THREE.MeshStandardMaterial({ color: 0x7c3aed, roughness: 0.22, metalness: 0.3, emissive: 0x2a0f6a, emissiveIntensity: 1.1 });

    const ringGeo = new THREE.TorusGeometry(0.78, 0.08, 12, 48);

    // Ball (bouncy)
    const ball = new THREE.Mesh(
      new THREE.SphereGeometry(0.6, 40, 40),
      new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.18,
        metalness: 0.25,
        emissive: 0x22104a,
        emissiveIntensity: 0.45
      })
    );
    ball.castShadow = false;
    ball.position.set(0, 0.9, 0);
    scene.add(ball);

    // Ball glow ring
    const ballRing = new THREE.Mesh(
      new THREE.TorusGeometry(0.75, 0.06, 12, 48),
      new THREE.MeshStandardMaterial({ color: 0x22d3ee, emissive: 0x22d3ee, emissiveIntensity: 1.4, roughness: 0.35, metalness: 0.0 })
    );
    ballRing.rotation.x = Math.PI/2;
    ballRing.position.copy(ball.position);
    scene.add(ballRing);

    // Trampoline reward object (hidden until unlock)
    const trampGroup = new THREE.Group();
    trampGroup.visible = false;
    scene.add(trampGroup);

    const trampBase = new THREE.Mesh(
      new THREE.CylinderGeometry(3.6, 3.6, 0.35, 48),
      new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 0.55, metalness: 0.2, emissive: 0x0b1022, emissiveIntensity: 0.9 })
    );
    trampBase.position.set(0, -0.55, 0);
    trampGroup.add(trampBase);

    const trampTop = new THREE.Mesh(
      new THREE.CylinderGeometry(3.3, 3.3, 0.12, 48),
      new THREE.MeshStandardMaterial({ color: 0x22d3ee, roughness: 0.15, metalness: 0.05, emissive: 0x22d3ee, emissiveIntensity: 0.55 })
    );
    trampTop.position.set(0, -0.32, 0);
    trampGroup.add(trampTop);

    // Confetti burst particles (simple)
    const burstCount = 260;
    const burstGeo = new THREE.BufferGeometry();
    const burstPos = new Float32Array(burstCount*3);
    const burstVel = new Float32Array(burstCount*3);
    for(let i=0;i<burstCount;i++){
      burstPos[i*3+0] = 0;
      burstPos[i*3+1] = -999;
      burstPos[i*3+2] = 0;
      // random velocity
      burstVel[i*3+0] = (Math.random()-0.5)*8;
      burstVel[i*3+1] = Math.random()*10 + 6;
      burstVel[i*3+2] = (Math.random()-0.5)*8;
    }
    burstGeo.setAttribute("position", new THREE.BufferAttribute(burstPos,3));
    const burstMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.12, transparent:true, opacity:0.9 });
    const burst = new THREE.Points(burstGeo, burstMat);
    scene.add(burst);
    let burstActive = false;
    let burstT = 0;

    function triggerBurst(at){
      burstActive = true;
      burstT = 0;
      const posAttr = burst.geometry.getAttribute("position");
      for(let i=0;i<burstCount;i++){
        posAttr.array[i*3+0] = at.x;
        posAttr.array[i*3+1] = at.y + 0.3;
        posAttr.array[i*3+2] = at.z;
        // tweak vel each time
        burstVel[i*3+0] = (Math.random()-0.5)*8;
        burstVel[i*3+1] = Math.random()*10 + 6;
        burstVel[i*3+2] = (Math.random()-0.5)*8;
      }
      posAttr.needsUpdate = true;
      burstMat.opacity = 0.95;
    }

    // Build path (curved, 100 nodes)
    function nodePosition(i){
      // i: 1..100
      const t = (i-1)/99;                // 0..1
      const angle = t * Math.PI * 1.85;  // curve
      const radius = 10.5;
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius;
      // add gentle wiggle to feel playful
      const w = Math.sin(t * Math.PI * 6) * 0.55;
      return new THREE.Vector3(x + w, 0, z);
    }

    function clearGroup(g){
      while(g.children.length){
        const c = g.children.pop();
        if(c.geometry) c.geometry.dispose?.();
        if(c.material){
          if(Array.isArray(c.material)) c.material.forEach(m=>m.dispose?.());
          else c.material.dispose?.();
        }
      }
    }

    function rebuildPath(){
      clearGroup(pathGroup);
      nodes.length = 0;
      nodeHit.length = 0;

      // Only show a window around current to keep it readable.
      // We'll still create 100 nodes but fade far ones in styling logic.
      for(let i=1;i<=100;i++){
        const pos = nodePosition(i);

        // base disc
        const disc = new THREE.Mesh(
          new THREE.CylinderGeometry(0.82, 0.82, 0.22, 32),
          nodeBaseMat
        );
        disc.position.copy(pos);
        disc.position.y = -0.05;
        disc.userData = { idx: i };
        pathGroup.add(disc);
        nodeHit.push(disc);

        // glow ring
        const ring = new THREE.Mesh(ringGeo, nodeBaseMat);
        ring.position.copy(pos);
        ring.position.y = 0.10;
        ring.rotation.x = Math.PI/2;
        ring.userData = { idx: i, isRing:true, disc };
        pathGroup.add(ring);

        nodes.push({ disc, ring, idx: i, worldPos: pos.clone() });
      }

      refreshNodeStyles();
      placeBallAtLesson(currentLesson(), false);
      focusOnCurrent(true);
    }

    function refreshNodeStyles(){
      const cur = currentLesson();
      const done = completedUpTo();
      const next = clamp(done + 1, 1, 100);

      // camera window around current
      const lo = cur - 10;
      const hi = cur + 14;

      for(const n of nodes){
        const i = n.idx;

        // material assignment
        let matDisc = nodeBaseMat;
        let matRing = nodeBaseMat;

        if(i <= done){
          matDisc = nodeDoneMat;
          matRing = nodeDoneMat;
        } else if(i === next){
          matDisc = nodeNextMat;
          matRing = nodeNextMat;
        }

        n.disc.material = matDisc;
        n.ring.material = matRing;

        // fade far nodes
        const dist = (i < lo || i > hi);
        const s = dist ? 0.55 : 1.0;
        n.disc.scale.setScalar(s);
        n.ring.scale.setScalar(s);

        // dim far nodes by lowering emissive intensity
        if(n.disc.material === nodeNextMat){
          n.disc.material.emissiveIntensity = dist ? 0.45 : 1.1;
          n.ring.material.emissiveIntensity = dist ? 0.45 : 1.1;
        } else if(n.disc.material === nodeDoneMat){
          n.disc.material.emissiveIntensity = dist ? 0.35 : 0.8;
          n.ring.material.emissiveIntensity = dist ? 0.35 : 0.8;
        } else {
          // base has no emissive; scale appearance with opacity via color-ish
        }

        // hide really far
        const tooFar = (i < cur - 24 || i > cur + 28);
        n.disc.visible = !tooFar;
        n.ring.visible = !tooFar;
      }

      // trampoline mode
      trampGroup.visible = unlocked();
    }

    // Animation: hop ball from current to target
    let hopAnim = null; // {from,to,t,duration}
    function placeBallAtLesson(idx, withBurst){
      const p = nodes[idx-1]?.worldPos;
      if(!p) return;
      ball.position.set(p.x, 0.9, p.z);
      ballRing.position.copy(ball.position);
      if(withBurst) triggerBurst(ball.position);
    }

    function hopToLesson(idx, withBurst){
      const p = nodes[idx-1]?.worldPos;
      if(!p) return;
      const from = ball.position.clone();
      const to = new THREE.Vector3(p.x, 0.9, p.z);
      const dist = from.distanceTo(to);
      const duration = clamp(0.45 + dist*0.03, 0.45, 0.9);

      hopAnim = { from, to, t: 0, duration, withBurst };
      if(withBurst) triggerBurst(to);
    }

    function focusOnCurrent(snap){
      const idx = currentLesson();
      const p = nodes[idx-1]?.worldPos;
      if(!p) return;

      // place camera to follow around the curve
      // offset is behind/above
      const camTarget = p.clone();
      const camPos = p.clone().add(new THREE.Vector3(0, 9.5, 16));
      // rotate around based on tangent-ish
      const prev = nodes[Math.max(0, idx-2)]?.worldPos ?? p;
      const dir = p.clone().sub(prev).normalize();
      const side = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();
      camPos.add(side.multiplyScalar(6));

      if(snap){
        camera.position.copy(camPos);
        camera.lookAt(camTarget);
        camera.userData.target = camTarget;
        camera.userData.camPos = camPos;
      }else{
        camera.userData.target = camTarget;
        camera.userData.camPos = camPos;
      }
    }

    // Tap nodes to hop (only allow hopping to next available)
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function onPointerDown(ev){
      const rect = canvas.getBoundingClientRect();
      const x = (("clientX" in ev) ? ev.clientX : ev.touches[0].clientX) - rect.left;
      const y = (("clientY" in ev) ? ev.clientY : ev.touches[0].clientY) - rect.top;

      pointer.x = (x / rect.width) * 2 - 1;
      pointer.y = -(y / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(nodeHit.filter(o=>o.visible), true);
      if(!hits.length) return;

      const hit = hits[0].object;
      const idx = hit.userData.idx;
      if(!idx) return;

      const done = completedUpTo();
      const next = clamp(done + 1, 1, 100);

      if(idx === next){
        // move current to next (without marking complete)
        state[seriesKey()].current = idx;
        saveState();
        updateUI();
        hopToLesson(idx, false);
        focusOnCurrent(false);
        refreshNodeStyles();
        showToast(`Go to Lesson ${idx}`);
      }else if(idx <= done){
        // optional: allow visiting completed nodes
        state[seriesKey()].current = idx;
        saveState();
        updateUI();
        hopToLesson(idx, false);
        focusOnCurrent(false);
        refreshNodeStyles();
        showToast(`Review Lesson ${idx}`);
      }else{
        showToast("Finish the next one first");
      }
    }

    canvas.addEventListener("mousedown", onPointerDown);
    canvas.addEventListener("touchstart", (e)=>{ e.preventDefault(); onPointerDown(e); }, {passive:false});

    /**************
     * Resize
     **************/
    function resize(){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    new ResizeObserver(resize).observe(canvas);

    /**************
     * Main loop
     **************/
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      // sparkles drift
      sparkles.rotation.y += dt * 0.08;

      // camera smooth follow
      if(camera.userData.camPos){
        camera.position.lerp(camera.userData.camPos, 1 - Math.pow(0.001, dt));
      }
      if(camera.userData.target){
        const t = camera.userData.target;
        const currentLook = new THREE.Vector3();
        camera.getWorldDirection(currentLook);
        camera.lookAt(t);
      }

      // hop animation
      if(hopAnim){
        hopAnim.t += dt;
        const u = clamp(hopAnim.t / hopAnim.duration, 0, 1);

        // ease in-out
        const e = u < 0.5 ? 4*u*u*u : 1 - Math.pow(-2*u + 2, 3)/2;

        // arc height
        const h = Math.sin(u*Math.PI) * 2.1;

        const p = hopAnim.from.clone().lerp(hopAnim.to, e);
        p.y += h;

        // squash/stretch
        const squash = 1 - Math.sin(u*Math.PI) * 0.22;
        const stretch = 1 + Math.sin(u*Math.PI) * 0.28;
        ball.scale.set(stretch, squash, stretch);

        ball.position.copy(p);
        ballRing.position.copy(p);
        ballRing.position.y = 0.9;

        if(u >= 1){
          // landing bounce
          ball.scale.set(1,1,1);
          ball.position.copy(hopAnim.to);
          ballRing.position.copy(ball.position);
          if(hopAnim.withBurst) triggerBurst(ball.position);
          hopAnim = null;
        }
      }else{
        // idle bounce
        const t = now*0.001;
        ball.position.y = 0.9 + Math.sin(t*2.2)*0.10;
        ballRing.position.copy(ball.position);
        ballRing.rotation.z = t*0.9;
      }

      // confetti burst update
      if(burstActive){
        burstT += dt;
        const posAttr = burst.geometry.getAttribute("position");
        const g = -16.0;

        for(let i=0;i<burstCount;i++){
          posAttr.array[i*3+0] += burstVel[i*3+0] * dt;
          posAttr.array[i*3+1] += burstVel[i*3+1] * dt;
          posAttr.array[i*3+2] += burstVel[i*3+2] * dt;
          burstVel[i*3+1] += g * dt;
        }
        posAttr.needsUpdate = true;

        burstMat.opacity = Math.max(0, 0.95 - burstT*0.55);
        if(burstT > 1.6){
          burstActive = false;
          // hide
          for(let i=0;i<burstCount;i++) posAttr.array[i*3+1] = -999;
          posAttr.needsUpdate = true;
        }
      }

      // trampoline animation
      if(unlocked()){
        const t = now*0.001;
        trampTop.material.emissiveIntensity = 0.45 + Math.sin(t*2.0)*0.12;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    /**************
     * Init
     **************/
    function rebuildAll(){
      updateUI();
      rebuildPath();
      resize();
      requestAnimationFrame(tick);
    }

    function placeBallAtCurrentSnap(){
      placeBallAtLesson(currentLesson(), false);
      focusOnCurrent(true);
    }

    function hopToLessonAndFocus(idx){
      hopToLesson(idx, false);
      focusOnCurrent(false);
    }

    // helper used by UI
    function hopToLesson(idx, withBurst){
      const p = nodes[idx-1]?.worldPos;
      if(!p) return;
      const from = ball.position.clone();
      const to = new THREE.Vector3(p.x, 0.9, p.z);
      const dist = from.distanceTo(to);
      const duration = clamp(0.45 + dist*0.03, 0.45, 0.9);
      hopAnim = { from, to, t: 0, duration, withBurst };
    }

    // override earlier reference (needed for complete flow)
    window.hopToLesson = hopToLesson;

    // Put ball at current immediately
    function focusOnCurrent(snap){
      const idx = currentLesson();
      const p = nodes[idx-1]?.worldPos;
      if(!p) return;

      const prev = nodes[Math.max(0, idx-2)]?.worldPos ?? p;
      const dir = p.clone().sub(prev).normalize();
      const side = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();

      const camTarget = p.clone();
      const camPos = p.clone().add(new THREE.Vector3(0, 9.5, 16)).add(side.multiplyScalar(6));

      if(snap){
        camera.position.copy(camPos);
        camera.lookAt(camTarget);
      }
      camera.userData.target = camTarget;
      camera.userData.camPos = camPos;
    }

    function rebuildPath(){
      clearGroup(pathGroup);
      nodes.length = 0;
      nodeHit.length = 0;

      for(let i=1;i<=100;i++){
        const pos = nodePosition(i);

        const disc = new THREE.Mesh(
          new THREE.CylinderGeometry(0.82, 0.82, 0.22, 32),
          nodeBaseMat
        );
        disc.position.copy(pos);
        disc.position.y = -0.05;
        disc.userData = { idx: i };
        pathGroup.add(disc);
        nodeHit.push(disc);

        const ring = new THREE.Mesh(ringGeo, nodeBaseMat);
        ring.position.copy(pos);
        ring.position.y = 0.10;
        ring.rotation.x = Math.PI/2;
        ring.userData = { idx: i, isRing:true, disc };
        pathGroup.add(ring);

        nodes.push({ disc, ring, idx: i, worldPos: pos.clone() });
      }

      refreshNodeStyles();
      placeBallAtLesson(currentLesson(), false);
      focusOnCurrent(true);
    }

    // initial build
    rebuildAll();
  </script>
</body>
</html>