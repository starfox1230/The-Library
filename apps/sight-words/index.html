
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Sight Words Quiz Deluxe - Mini-Games Edition</title>
  <!-- Google Font + Animate.css -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.fog.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.waves.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.birds.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.cells.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.clouds.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.dots.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.rings.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.halo.min.js"></script>
  <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/progressbar.js/1.1.0/progressbar.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
  <style>
    :root {
      --brand: #26c6da;
      --brand-light: #80deea;
      --brand-dark: #00acc1;
      --bg: #f4f6f8;
      --fg: #333;
      --btn-bg: #fff;
      --btn-border: #ddd;
      --btn-radius: 16px;
      --transition: 0.2s ease-in-out;
      --correct-bg: #a5d6a7;
      --incorrect-bg: #ef9a9a;
      --selected-border-color: #007bff; /* Blue for selection */
      --shadow-color: rgba(0,0,0,0.1);
      --pastel-green-bg: #c9e4c5;
    }
    *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;overflow:hidden;font-family:'Poppins',sans-serif;color:var(--fg);
    -webkit-tap-highlight-color:transparent;touch-action:manipulation;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
}
    body { background-color: var(--bg); }
    #confetti-canvas{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1000}

    .top-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: auto;
      min-height: 70px;
      display: flex;
      align-items: flex-start; /* Align to top for vertical stack */
      justify-content: space-between;
      padding: 0 0 0 16px;
      z-index: 50;
    }

    #score {
      font-size: 1.1rem;
      font-weight: 600;
      background-color: rgba(255,255,255,0.7);
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 2px 4px var(--shadow-color);
      margin-top: 10px; /* Align with top of buttons */
    }
    #timer-wrapper {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      top: 5px;
    }
    #circular-timer { width: 100%; height: 100%; }

    /* RHS Vertical Controls Container (Restored) */
    #controls-RHS-container {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.3rem;
      padding-top: 10px;
      padding-right: 10px; /* Space from the edge */
    }

    /* Shared styles for top bar control buttons */
    #word-list-open-btn,
    #toggle-minigames-btn,
    #toggle-background-btn {
        padding: 0.4rem 0.8rem;
        font-size: 0.8rem;
        font-weight: 600;
        background-color: var(--btn-bg);
        border: 2px solid var(--btn-border);
        border-radius: var(--btn-radius);
        cursor: pointer;
        box-shadow: 0 2px 4px var(--shadow-color);
        text-align: center;
        line-height: 1.2;
        width: 165px; /* Consistent width */
    }
    
    #word-list-open-btn {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    #word-list-open-btn .badge {
        background-color: var(--brand);
        color: white;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 0.8em;
    }
    
    #toggle-minigames-btn.active-minigame-toggle,
    #toggle-background-btn.active-animated-bg {
        background-color: var(--brand-light);
        color: var(--brand-dark);
        border-color: var(--brand-dark);
    }
    
    /* Word List Modal (New) */
    .word-list-modal-overlay {
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.6);
        z-index: 950;
        justify-content: center;
        align-items: center;
        padding: 1rem;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
    }
    .word-list-modal-overlay.visible { display: flex; }

    .word-list-modal-content {
        background-color: var(--bg);
        width: 100%;
        height: 100%;
        max-width: 500px;
        max-height: 95vh;
        border-radius: 16px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    .word-list-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.5rem;
        border-bottom: 1px solid #eee;
        flex-shrink: 0;
    }
    .word-list-modal-header h2 { color: var(--brand-dark); }
    .word-list-modal-close-btn {
        font-size: 2rem;
        font-weight: 300;
        background: none;
        border: none;
        cursor: pointer;
        color: #888;
        line-height: 1;
    }
    .word-list-summary {
        padding: 0.5rem 1.5rem 1rem;
        border-bottom: 1px solid #eee;
        font-size: 0.9rem;
        background-color: #fff;
        flex-shrink: 0;
    }
    .word-list-summary p { margin: 0.25rem 0; color: #555;}

    .word-list-tree {
        flex-grow: 1;
        overflow-y: auto;
        padding: 1rem;
    }
    .word-list-tree details { margin-bottom: 0.5rem; }
    .word-list-tree summary {
        font-size: 1.1rem;
        font-weight: 600;
        padding: 0.75rem 1rem;
        background-color: white;
        border: 1px solid var(--btn-border);
        border-radius: 12px;
        cursor: pointer;
        list-style: none; /* remove default arrow */
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .word-list-tree summary::before {
        content: '▸';
        margin-right: 0.75rem;
        transition: transform 0.2s;
    }
    .word-list-tree details[open] > summary::before {
        transform: rotate(90deg);
    }
    .bank-count { font-size: 0.8em; font-weight: 400; color: #777; }
    
    .level-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 1rem; /* Padding on container for easier spacing */
        margin: 0.5rem 0 0.5rem 0.5rem;
        background: #fdfdfd;
        border-radius: 10px;
        border: 1px solid #eee;
        min-height: 48px; /* Touch target size */
    }
    .level-item label {
        display: flex;
        align-items: center;
        flex-grow: 1;
        cursor: pointer;
        padding: 0.5rem 0; /* Vertical padding inside label */
        font-size: 1rem;
    }
    .level-item input[type="checkbox"] {
        margin-right: 1rem;
        width: 20px;
        height: 20px;
        accent-color: var(--brand);
    }
    .level-word-count { font-size: 0.85em; color: #888; margin-left: 6px; }

    .edit-level-btn {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: var(--brand-dark);
        padding: 0.5rem;
        border-radius: 50%;
        line-height: 1;
        transition: background-color 0.2s;
    }
    .edit-level-btn:hover { background-color: #e0f7fa; }

    .word-list-modal-footer {
        padding: 1rem;
        border-top: 1px solid #eee;
        background: #fff;
        text-align: center;
        flex-shrink: 0;
    }
    #word-list-save-btn {
        width: 100%;
        padding: 0.9rem;
        font-size: 1.1rem;
        font-weight: 600;
        color: white;
        background-color: var(--brand);
        border: none;
        border-radius: 12px;
        cursor: pointer;
    }

    #quiz-container{ display:flex;justify-content:center;align-items:center; min-height: 30vh; padding:1rem; margin-top: 80px; /* Increased to clear taller top-bar */ height: calc(100vh - 80px - 70px); }
    #listen-pick-word-area { display: flex; justify-content: center; align-items: center; width: 100%; }
    #read-pick-sound-area { display: none; flex-direction: column; justify-content: center; align-items: center; width: 100%; gap: 1.5rem; }
    .word-display-box { background: var(--btn-bg); border: 3px solid var(--brand-dark); border-radius: var(--btn-radius); padding: 1.5rem 2rem; font-size: 2.5rem; font-weight: 600; color: var(--fg); min-width: 200px; text-align: center; box-shadow: 0 4px 8px var(--shadow-color); }
    #sound-choices-container { display: flex; justify-content: center; gap: 1rem; }

    .choice-btn{ flex:1; min-width: 120px; max-width: 200px; margin:0 .75rem;padding:1.2rem; font-size:1.8rem; font-weight: 600; background:var(--btn-bg);border:2px solid var(--btn-border);border-radius:var(--btn-radius); transition:background var(--transition),transform var(--transition), box-shadow var(--transition), border-color var(--transition); touch-action:manipulation; cursor:pointer; box-shadow: 0 4px 6px var(--shadow-color); }
    .choice-btn:hover { transform: translateY(-3px); box-shadow: 0 6px 10px var(--shadow-color); }
    .choice-btn:active{transform:scale(0.96); box-shadow: 0 2px 4px var(--shadow-color);}
    .choice-btn.correct { background-color: var(--correct-bg) !important; border-color: green !important; }
    .choice-btn.incorrect { background-color: var(--incorrect-bg) !important; border-color: darkred !important; }

    .sound-btn { font-size: 2rem !important; padding: 1rem 1.5rem !important; }
    .sound-btn-selected {
        border-color: var(--selected-border-color) !important;
        box-shadow: 0 0 0 3px var(--selected-border-color), 0 4px 6px var(--shadow-color) !important;
    }

    #submit-answer-btn { padding: 0.8rem 2rem; font-size: 1.2rem; font-weight: 600; color: white; background-color: var(--brand); border: none; border-radius: var(--btn-radius); cursor: pointer; transition: background-color var(--transition), transform var(--transition); box-shadow: 0 4px 6px var(--shadow-color); }
    #submit-answer-btn:hover { background-color: var(--brand-dark); transform: translateY(-2px); }
    #submit-answer-btn:active { transform: scale(0.98); }
    #submit-answer-btn:disabled { background-color: #ccc; cursor: not-allowed; box-shadow: none; }

    #controls{ position: fixed; bottom: 0; left: 0; width: 100%; display:flex;justify-content:space-around; align-items:center; padding:0.5rem 1rem; height: 70px; background-color: rgba(255,255,255,0.3); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); z-index: 50; }
    #timer-display{ padding:.6rem 1rem;background:var(--btn-bg);border:2px solid var(--btn-border);border-radius:var(--btn-radius); font-weight:600;cursor:pointer; box-shadow: 0 2px 4px var(--shadow-color); font-size: 0.9rem; }
    #listen-btn, #mode-toggle-btn { font-size:1.5rem; background:none;border:none;cursor:pointer;outline:none; padding: 0.5rem; transition: transform 0.2s; color: var(--brand-dark); font-weight: 600; }
    #mode-toggle-btn { font-size: 0.9rem; padding: 0.6rem 0.8rem; background-color: var(--btn-bg); border: 2px solid var(--btn-border); border-radius: var(--btn-radius); box-shadow: 0 2px 4px var(--shadow-color); }
    #listen-btn:active, #mode-toggle-btn:active {transform: scale(0.9);}
    #timer-select{ position:absolute;bottom: calc(70px + 0.5rem); right:1rem;font-size:1rem;padding:.3rem .5rem;display:none; border-radius: 8px; border: 1px solid var(--btn-border); box-shadow: 0 2px 5px var(--shadow-color); }
    #mascot-container { position: fixed; bottom: 1rem; left: 1rem; width: 100px; height: 100px; z-index: 5; pointer-events: none; }
    #mascot-container lottie-player { width: 100%; height: 100%; }
    .floating-effect { position: fixed; padding: 0.5rem 1rem; color: white; border-radius: 20px; font-weight: bold; font-size: 1.2em; z-index: 1200; pointer-events: none; text-align: center; }
    .floating-score { background: rgba(76, 175, 80, 0.9); }
    .floating-message { background: var(--brand); }


    /* Word Customization Modal Styles */
    #word-customization-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 1000; justify-content: center; align-items: center; padding: 1rem; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
    #word-customization-modal.visible { display: flex; }
    .modal-content { background-color: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); width: 90%; max-width: 700px; max-height: 90vh; display: flex; flex-direction: column; }

    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
    #modal-title { margin-top: 0; margin-bottom: 0; color: var(--brand-dark); font-size: 1.2rem; flex-grow: 1; }
    #modal-level-selector-label { font-size: 0.9rem; margin-right: 0.5rem;}
    #modal-level-selector { padding: 0.3rem 0.5rem; border-radius: 6px; border: 1px solid var(--btn-border); font-size: 0.9rem; }

    #modal-search-input { width: 100%; padding: 0.6rem; margin-bottom: 1rem; border: 1px solid #ccc; border-radius: 8px; font-size: 1rem; }

    #modal-word-list { overflow-y: auto; flex-grow: 1; border: 1px solid #eee; border-radius: 8px; padding: 0.5rem; margin-bottom: 1rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 0.5rem; }
    .modal-word-item { display: flex; align-items: center; padding: 0.5rem; border-radius: 6px; background-color: #f9f9f9; cursor: pointer; transition: background-color 0.2s; }
    .modal-word-item:hover { background-color: #e9e9e9; }
    .modal-word-item input[type="checkbox"] { margin-right: 0.75rem; width: 18px; height: 18px; accent-color: var(--brand); }
    .modal-word-item label { flex-grow: 1; user-select: none; }
    .modal-word-item.custom-word label { font-style: italic; color: var(--brand-dark); }


    #modal-add-custom-word-btn { width: calc(100% - 1rem); margin: 0.5rem 0.5rem 1rem 0.5rem; padding: 0.7rem; background-color: var(--brand-light); color: var(--brand-dark); border: 1px dashed var(--brand-dark); border-radius: 8px; cursor: pointer; font-weight: 600; }
    #modal-add-custom-word-btn:hover { background-color: var(--brand); color: white; }

    .modal-actions { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 0.5rem; padding-top: 1rem; border-top: 1px solid #eee; }
    .modal-actions button { padding: 0.6rem 1rem; font-size: 0.9rem; border-radius: 8px; border: none; cursor: pointer; background-color: var(--brand); color: white; transition: background-color 0.2s; min-width: 100px; }
    .modal-actions button:hover { background-color: var(--brand-dark); }
    .modal-actions button#modal-close-btn { background-color: #aaa; }
    .modal-actions button#modal-close-btn:hover { background-color: #888; }
    .modal-actions .io-buttons { display: flex; gap: 0.5rem; }
    .modal-actions .io-buttons button { background-color: #78909c; font-size: 0.8rem; padding: 0.5rem 0.8rem; min-width: auto;}
    .modal-actions .io-buttons button:hover { background-color: #546e7a; }
    #upload-file-input { display: none; }


    .hidden { display: none !important; }

    /* Mini-Game Area Styles (content injected by JS) */
    #minigame-area {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(100, 150, 220, 0.95); /* Slightly more opaque */
        z-index: 900; display: none; justify-content: center; align-items: center;
        flex-direction: column; overflow: hidden; color: white; font-size: 1.5rem;
    }
    #minigame-area.active { display: flex; }
    .minigame-info-bar {
        position: absolute; top: 20px; left: 20px; right: 20px; display: flex;
        justify-content: space-between; align-items: center; padding: 10px;
        background-color: rgba(0,0,0,0.2); border-radius: 8px; font-size: 1.2rem;
    }
    .minigame-score { font-weight: bold; }
    .minigame-timer-bar-container {
        height: 20px; flex-grow: 1; margin: 0 20px;
        background-color: rgba(255,255,255,0.3); border-radius: 10px; overflow: hidden;
    }
    .minigame-timer-bar {
        height: 100%; width: 100%; background-color: var(--brand-light);
        transition: width 0.2s linear;
    }
     .minigame-timer-text { font-weight: bold; margin-left:10px; min-width:80px; text-align: right;}


    /* Balloon Pop Specific - from previous code */
    .balloon {
        width: 60px; height: 80px;
        border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        position: absolute; cursor: pointer; user-select: none;
        display: flex; justify-content: center; align-items: flex-end;
        padding-bottom: 5px;
    }
    .balloon::after {
        content: ''; position: absolute; bottom: -15px; left: 50%;
        transform: translateX(-50%); width: 2px; height: 20px;
        background-color: rgba(255,255,255,0.7);
    }
    .balloon-rising { animation: riseAnimation 5s linear forwards; }
    @keyframes riseAnimation {
        from { transform: translateY(0); }
        to { transform: translateY(-110vh); }
    }

    /* Bounce Party Specific - from previous code */
    .bounce-ball {
        width: 50px; height: 50px; background-color: var(--brand);
        border-radius: 50%; position: absolute; cursor: pointer;
        box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }
    .animate__fadeOutCustom { animation-duration: 0.3s; }
    .animate__fadeInCustom { animation-duration: 0.3s; }

    /* Generic Modal Styles */
    .generic-modal-overlay {
        display: none; /* Hidden by default */
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.6);
        z-index: 2000; /* Higher than other modals */
        justify-content: center;
        align-items: center;
        padding: 1rem;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
    }
    .generic-modal-overlay.visible {
        display: flex;
    }
    .generic-modal-content {
        background-color: white;
        padding: 1.5rem 2rem;
        border-radius: 12px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        width: 90%;
        max-width: 500px;
        text-align: center;
    }
    .generic-modal-content h3 {
        margin-top: 0;
        margin-bottom: 1rem;
        color: var(--brand-dark);
    }
    .generic-modal-content p {
        margin-bottom: 1.5rem;
    }
    .generic-modal-actions {
        display: flex;
        justify-content: center;
        gap: 1rem;
        flex-wrap: wrap;
    }
    .generic-modal-actions button {
        padding: 0.7rem 1.5rem;
        font-size: 1rem;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        background-color: var(--brand);
        color: white;
        font-weight: 600;
    }
    .generic-modal-actions button:hover {
        background-color: var(--brand-dark);
    }
    .generic-modal-actions .cancel-btn {
        background-color: #aaa;
    }
    .generic-modal-actions .cancel-btn:hover {
        background-color: #888;
    }
    /* Add this new CSS style rule */
    .helper-link {
        display: block;
        margin-bottom: 0.75rem;
        font-size: 0.9rem;
        color: var(--brand-dark);
        text-decoration: none;
        transition: color 0.2s;
    }
    .helper-link:hover {
        text-decoration: underline;
        color: var(--brand);
    }
    #paste-json-textarea {
        width: 100%;
        height: 200px;
        margin-bottom: 1rem;
        padding: 0.5rem;
        border: 1px solid #ccc;
        border-radius: 8px;
        font-family: monospace;
        font-size: 0.9rem;
        resize: vertical;
    }

  </style>
</head>
<body>
<canvas id="confetti-canvas"></canvas>

  <div class="top-bar">
    <div id="score">Score: <span id="score-val">0</span></div>
    <div id="timer-wrapper"><div id="circular-timer"></div></div>
    <div id="controls-RHS-container">
        <button id="word-list-open-btn">
            <span>Word List</span>
            <span class="badge" id="word-count-badge">0</span>
        </button>
        <button id="toggle-minigames-btn">Mini-Games: Off</button>
        <button id="toggle-background-btn">Background: Animated</button>
    </div>
  </div>
  
  <div id="word-list-modal" class="word-list-modal-overlay">
    <div class="word-list-modal-content">
      <div class="word-list-modal-header">
        <h2>Word List</h2>
        <button id="word-list-close-btn" class="word-list-modal-close-btn">&times;</button>
      </div>
      <div class="word-list-summary">
        <p id="word-list-summary-text">You've selected: ...</p>
        <p>Total Active Words: <strong id="word-list-total-count">0</strong></p>
      </div>
      <div class="word-list-tree" id="word-list-tree-container">
        <!-- Dynamically populated by JS -->
      </div>
      <div class="word-list-modal-footer">
        <button id="word-list-save-btn">Save & Close</button>
      </div>
    </div>
  </div>


  <div id="word-customization-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="modal-title">Customize Words</h2>
            <div>
                <label for="modal-level-selector" id="modal-level-selector-label">Level:</label>
                <select id="modal-level-selector">
                    <!-- Options populated by JS if not 'custom' list -->
                </select>
            </div>
        </div>
        <input type="search" id="modal-search-input" placeholder="Search or type new word...">
        <div id="modal-word-list">
            <!-- Filtered words with checkboxes will appear here -->
        </div>
        <button id="modal-add-custom-word-btn" class="hidden">Add "<span id="modal-add-custom-word-term"></span>" to Custom List</button>
        <div class="modal-actions">
            <button id="modal-save-btn">Save & Use</button>
            <button id="modal-select-all-btn">Select All Visible</button>
            <button id="modal-deselect-all-btn">Deselect All Visible</button>
            <div class="io-buttons">
                <button id="modal-download-btn">Download Data</button>
                <input type="file" id="upload-file-input" accept=".json">
                <button id="modal-upload-btn">Upload Data</button>
            </div>
            <button id="modal-close-btn">Close</button>
        </div>
    </div>
  </div>


  <!-- START: New Modals for Upload Flow -->
  <div id="upload-choice-modal" class="generic-modal-overlay">
    <div class="generic-modal-content">
      <h3>How would you like to upload data?</h3>
      <div class="generic-modal-actions">
        <button id="upload-choice-file-btn">Choose File</button>
        <button id="upload-choice-paste-btn">Paste JSON</button>
        <button id="upload-choice-cancel-btn" class="cancel-btn">Cancel</button>
      </div>
    </div>
  </div>
  
  <div id="paste-json-modal" class="generic-modal-overlay">
    <div class="generic-modal-content">
      <a href="https://chatgpt.com/g/g-684dd5b88fbc8191acfbaf28341615c5-sight-word-helper" target="_blank" rel="noopener noreferrer" class="helper-link">Generate JSON from picture or text</a>
      <h3>Paste your JSON data</h3>
      <textarea id="paste-json-textarea" placeholder="Paste the content of your .json file here..."></textarea>
      <div class="generic-modal-actions">
        <button id="paste-json-process-btn">Process Data</button>
        <button id="paste-json-cancel-btn" class="cancel-btn">Cancel</button>
      </div>
    </div>
  </div>
  
  <div id="upload-conflict-modal" class="generic-modal-overlay">
    <div class="generic-modal-content">
      <h3 id="upload-conflict-title">Custom Word Conflict</h3>
      <p id="upload-conflict-message">You have existing custom words. How would you like to handle the custom words from the uploaded data?</p>
      <div class="generic-modal-actions">
        <button id="upload-conflict-merge-btn">Merge</button>
        <button id="upload-conflict-replace-btn">Replace</button>
        <button id="upload-conflict-cancel-btn" class="cancel-btn">Cancel Upload</button>
      </div>
    </div>
  </div>
  <!-- END: New Modals for Upload Flow -->


  <div id="quiz-container" class="animate__animated">
    <div id="listen-pick-word-area">
      <button id="choice0" class="choice-btn"></button>
      <button id="choice1" class="choice-btn"></button>
    </div>
    <div id="read-pick-sound-area">
      <div id="word-to-read" class="word-display-box"></div>
      <div id="sound-choices-container">
        <button id="soundChoice0" class="choice-btn sound-btn">🔊</button>
        <button id="soundChoice1" class="choice-btn sound-btn">🔊</button>
      </div>
      <button id="submit-answer-btn" disabled>Submit Answer</button>
    </div>
  </div>

  <div id="minigame-area">
      <!-- Mini-game content will be injected here by JS -->
  </div>

  <div id="controls"> <div id="timer-display">10s ⏱️</div> <button id="mode-toggle-btn">Mode: Listen</button> <button id="listen-btn">🔊</button> </div>
  <select id="timer-select"></select>
  <div id="mascot-container"> <lottie-player src="https://lottie.host/449f9829-8f92-4a63-85a2-def249781a91/p021aHdt2x.json" background="transparent" speed="1" loop autoplay></lottie-player> </div>

  <script>
    // --- WEB AUDIO API (UNCHANGED) ---
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)(); if (audioCtx) { window.addEventListener('pointerdown', () => { if (audioCtx.state === 'suspended') audioCtx.resume(); }, { once: true }); } function playOsc({ type='sine', freq=440, dur=0.3, modFreq, modIndex, vol=1 }) { if (!audioCtx) return; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime); if (modFreq && modIndex) { const mod = audioCtx.createOscillator(); const mGain = audioCtx.createGain(); mod.frequency.setValueAtTime(modFreq, audioCtx.currentTime); mGain.gain.setValueAtTime(modIndex, audioCtx.currentTime); mod.connect(mGain).connect(osc.frequency); mod.start(audioCtx.currentTime); mod.stop(audioCtx.currentTime + dur); } osc.connect(gain); gain.connect(audioCtx.destination); gain.gain.setValueAtTime(vol, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur); osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime + dur); } function playBell() { if (!audioCtx) return; playOsc({ type:'sine', freq:660, dur:0.3, vol: 0.6 }); setTimeout(() => playOsc({ type:'sine', freq:880, dur:0.3, vol: 0.6 }), 120); } function playBuzz() { if (!audioCtx) return; playOsc({ type:'square', freq:150, dur:0.4, vol: 0.4 }); }
    const pronunciationMap = { "I": "I." };

    // --- DATA LAYER (UNCHANGED) ---
    const WORD_BANK = {
        dolch: {
            A: ["a","all","am","and","away","be","big","blue","but","can","come", "did","down","find","for","funny","go","good","he","help","here","I", "in","is","it","like","little","look","make","me","my","no","not", "on","one","play","ran","red","run","said","see","so","that","the", "three","to","two","up","was","we","what","where","yellow","yes","you"],
            B: ["after","again","any","are","as","at","ate","black","brown","by","came","could","do","eat","every","four","from","get","give","going","had","have","her","him","how","into","let","must","new","now","of","our","out","please","pretty","ride","round","saw","say","she","some","soon","thank","there","they","this","too","under","want","well","went","white","who","will","with"],
            C: ["an","ask","been","best","buy","cold","does","don't","first","five","fly","found","gave","goes","green","has","his","its","jump","just","know","live","made","many","may","off","old","once","open","or","over","own","pull","put","read","right","sit","sleep","stop","take","tell","them","then","these","think","those","use","very","walk","warm","wash","were","when","why","your"],
            D: ["about","always","around","because","before","better","both","bring","call","carry","clean","cut","done","draw","drink","eight","fall","far","fast","full","got","grow","hold","hot","hurt","if","keep","kind","laugh","light","long","much","myself","never","only","pick","seven","shall","show","sing","six","small","start","ten","their","today","together","try","upon","us","which","wish","work","would","write"]
        },
        fry: {
          "1-100": ["a","about","all","am","an","and","are","as","at","be","been","but","by","called","can","come","could","day","did","do","down","each","find","first","for","from","get","go","had","has","have","he","her","him","his","how","I","if","in","into","is","it","its","like","long","look","made","make","many","may","more","my","no","not","now","number","of","on","one","or","other","out","part","people","said","see","she","so","some","than","that","the","their","them","then","there","these","they","this","time","to","two","up","use","was","water","way","we","were","what","when","which","who","will","with","words","would","write","you","your"],
          "101-200": ["after","again","air","also","America","animal","another","answer","any","around","ask","away","back","because","before","big","boy","came","change","different","does","end","even","follow","form","found","give","good","great","hand","help","here","home","house","just","kind","know","land","large","learn","letter","line","little","live","man","me","means","men","most","mother","move","much","must","name","need","new","off","old","only","our","over","page","picture","place","play","point","put","read","right","same","say","sentence","set","should","show","small","sound","spell","still","study","such","take","tell","things","think","three","through","too","try","turn","us","very","want","well","went","where","why","work","world","years"],
          "201-300": ["above","add","almost","along","always","began","begin","being","below","between","book","both","car","carry","children","city","close","country","cut","don’t","earth","eat","enough","every","example","eyes","face","family","far","father","feet","few","food","four","girl","got","group","grow","hard","head","hear","high","idea","important","Indian","it’s","keep","last","late","leave","left","let","life","light","list","might","mile","miss","mountains","near","never","next","night","often","once","open","own","paper","plant","real","river","run","saw","school","sea","second","seem","side","something","sometimes","song","soon","start","state","stop","story","talk","those","thought","together","took","tree","under","until","walk","watch","while","white","without","young"],
          "301-400": ["across","against","area","become","best","better","birds","black","body","certain","cold","color","complete","covered","cried","didn’t","dog","door","draw","during","early","easy","ever","fall","farm","fast","field","figure","fire","fish","five","friends","ground","happened","heard","himself","hold","horse","hours","however","hundred","I’ll","king","knew","listen","low","map","mark","measure","money","morning","music","north","notice","numeral","order","passed","pattern","piece","plan","problem","products","pulled","questions","reached","red","remember","rock","room","seen","several","ship","short","since","sing","slowly","south","space","stand","step","sun","sure","table","today","told","top","toward","town","travel","true","unit","upon","usually","voice","vowel","war","waves","whole","wind","wood"],
          "401-500": ["able","ago","among","ball","base","became","behind","boat","box","bread","bring","brought","building","built","cannot","carefully","check","circle","class","clear","common","contain","correct","course","dark","decided","deep","done","dry","English","equation","explain","fact","feel","filled","finally","fine","fly","force","front","full","game","gave","government","green","half","heat","heavy","hot","inches","include","inside","island","known","language","less","machine","material","minutes","note","nothing","noun","object","ocean","oh","pair","person","plane","power","produce","quickly","ran","rest","road","round","rule","scientists","shape","shown","six","size","special","stars","stay","stood","street","strong","surface","system","ten","though","thousands","understand","verb","wait","warm","week","wheels","yes","yet"],
          "501-600": ["anything","arms","beautiful","believe","beside","bill","blue","brother","can’t","cause","cells","center","clothes","dance","describe","developed","difference","direction","discovered","distance","divided","drive","drop","edge","eggs","energy","Europe","exercise","farmers","felt","finished","flowers","forest","general","gone","grass","happy","heart","held","instruments","interest","job","kept","lay","legs","length","love","main","matter","meet","members","million","mind","months","moon","paint","paragraph","past","perhaps","picked","present","probably","race","rain","raised","ready","reason","record","region","represent","return","root","sat","shall","sign","simple","site","sky","soft","square","store","subject","suddenly","sum","summer","syllables","teacher","test","third","train","wall","weather","west","whether","wide","wild","window","winter","wish","written"],
          "601-700": ["act","Africa","age","already","although","amount","angle","appear","baby","bear","beat","bed","bottom","bright","broken","build","buy","care","case","cat","century","consonant","copy","couldn’t","count","cross","dictionary","died","dress","either","everyone","everything","exactly","factors","fight","fingers","floor","fraction","free","French","gold","hair","hill","hole","hope","ice","instead","iron","jumped","killed","lake","laughed","lead","let’s","lot","melody","metal","method","middle","milk","moment","nation","natural","outside","per","phrase","poor","possible","pounds","pushed","quiet","quite","remain","result","ride","rolled","sail","scale","section","sleep","smiled","snow","soil","solve","someone","son","speak","speed","spring","stone","surprise","tall","temperature","themselves","tiny","trip","type","village","within","wonder"],
          "701-800": ["alone","art","bad","bank","bit","break","brown","burning","business","captain","catch","caught","cents","child","choose","clean","climbed","cloud","coast","continued","control","cool","cost","decimal","desert","design","direct","drawing","ears","east","else","engine","England","equal","experiment","express","feeling","fell","flow","foot","garden","gas","glass","God","grew","history","human","hunting","increase","information","itself","joined","key","lady","law","least","lost","maybe","mouth","party","pay","period","plains","please","practice","president","received","report","ring","rise","row","save","seeds","sent","separate","serve","shouted","single","skin","statement","stick","straight","strange","students","suppose","symbols","team","touch","trouble","uncle","valley","visit","wear","whose","wire","woman","wrote","yard","you’re","yourself"],
          "801-900": ["addition","army","bell","belong","block","blood","blow","board","bones","branches","cattle","chief","compare","compound","consider","cook","corner","crops","crowd","current","doctor","dollars","eight","electric","elements","enjoy","entered","except","exciting","expect","famous","fit","flat","fruit","fun","guess","hat","hit","indicate","industry","insects","interesting","Japanese","lie","lifted","loud","major","mall","meat","mine","modern","movement","necessary","observe","park","particular","planets","poem","pole","position","process","property","provide","rather","rhythm","rich","safe","sand","science","sell","send","sense","seven","sharp","shoulder","sight","silent","soldiers","spot","spread","stream","string","suggested","supply","swim","terms","thick","thin","thus","tied","tone","trade","tube","value","wash","wasn’t","weight","wife","wings","won’t"],
          "901-1000": ["action","actually","adjective","afraid","agreed","ahead","allow","apple","arrived","born","bought","British","capital","chance","chart","church","column","company","conditions","corn","cotton","cows","create","dead","deal","death","details","determine","difficult","division","doesn’t","effect","entire","especially","evening","experience","factories","fair","fear","fig","forward","France","fresh","Greek","gun","hoe","huge","isn’t","led","level","located","march","match","molecules","northern","nose","office","opposite","oxygen","plural","prepared","pretty","printed","radio","repeated","rope","rose","score","seat","settled","shoes","shop","similar","sir","sister","smell","solution","southern","steel","stretched","substances","suffix","sugar","tools","total","track","triangle","truck","underline","various","view","Washington","we’ll","western","win","women","workers","wouldn’t","wrong","yellow"]
        },
        custom: []
    };

    let selectionState = {}; // The single source of truth for word selections
    let words = []; // Current words for the quiz

    // --- IMPORT/EXPORT & DATA HELPERS (UNCHANGED) ---
    function downloadWordData() {
        const dataToExport = {
            wordSelectionState: selectionState,
            customBank: WORD_BANK.custom,
            userIndividualWordSelections: {}
        };
        Object.keys(WORD_BANK).forEach(listKey => {
            if (listKey !== 'custom' && WORD_BANK[listKey] && typeof WORD_BANK[listKey] === 'object') {
                dataToExport.userIndividualWordSelections[listKey] = {};
                Object.keys(WORD_BANK[listKey]).forEach(levelKey => {
                    const selection = JSON.parse(localStorage.getItem(`${listKey}_${levelKey}_userSelections`) || 'null');
                    if (selection) { dataToExport.userIndividualWordSelections[listKey][levelKey] = selection; }
                });
            }
        });
        const jsonString = JSON.stringify(dataToExport, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = `sight-words-quiz-data-${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a); a.click();
        setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
        showFloatingMessage("Word data downloaded!", "var(--brand-light)", "var(--fg)");
    }
    async function processImportedData(importedData) {
        try {
            if (!importedData || typeof importedData.customBank === 'undefined') { showFloatingMessage("Invalid file format.", "var(--incorrect-bg)"); return; }
            const existingCustomWords = WORD_BANK.custom.length > 0;
            const incomingCustomWords = importedData.customBank.length > 0;
            let action = 'merge';
            if (existingCustomWords && incomingCustomWords) {
                try { action = await promptConflictResolution(); } catch (error) { showFloatingMessage("Upload cancelled.", "var(--brand-dark)"); return; }
            }
            if (action === 'merge' && incomingCustomWords) { WORD_BANK.custom = Array.from(new Set([...WORD_BANK.custom, ...importedData.customBank])).sort(); }
            else if (action === 'replace') { WORD_BANK.custom = [...new Set(importedData.customBank)].sort(); }
            localStorage.setItem('customBank', JSON.stringify(WORD_BANK.custom));
            if (importedData.userIndividualWordSelections) {
                Object.keys(importedData.userIndividualWordSelections).forEach(listKey => {
                    if (WORD_BANK[listKey]) { Object.keys(importedData.userIndividualWordSelections[listKey]).forEach(levelKey => { if (WORD_BANK[listKey][levelKey]) { localStorage.setItem(`${listKey}_${levelKey}_userSelections`, JSON.stringify(importedData.userIndividualWordSelections[listKey][levelKey])); } }); }
                });
            }
            if (importedData.wordSelectionState) {
                selectionState = importedData.wordSelectionState;
                localStorage.setItem('wordSelectionState', JSON.stringify(selectionState));
            } else if (importedData.activeWordList && importedData.selectedLevels) {
                selectionState = {};
                Object.keys(WORD_BANK).forEach(listKey => {
                    selectionState[listKey] = {};
                    if (listKey === 'custom') { selectionState.custom.all = importedData.activeWordList === 'custom'; }
                    else { Object.keys(WORD_BANK[listKey]).forEach(levelKey => { selectionState[listKey][levelKey] = (importedData.activeWordList === listKey && importedData.selectedLevels.includes(levelKey)); }); }
                });
                localStorage.setItem('wordSelectionState', JSON.stringify(selectionState));
            }
            showFloatingMessage("Word data imported successfully!", "var(--correct-bg)");
            updateQuizWordsFromSelectionState(); closeWordCustomizationModal();
        } catch (error) { console.error("Error processing imported data:", error); showFloatingMessage("Error processing data. Check console.", "var(--incorrect-bg)"); }
    }
    function triggerFileUpload() { document.getElementById('upload-file-input').click(); }
    async function handleFileUpload(event) { const file = event.target.files[0]; if (!file) return; event.target.value = null; try { const fileContent = await file.text(); const importedData = JSON.parse(fileContent); await processImportedData(importedData); } catch (error) { console.error("Error reading or parsing file:", error); showFloatingMessage("Could not read or parse the file.", "var(--incorrect-bg)"); } }
    function promptConflictResolution() { return new Promise((resolve, reject) => { const modal = document.getElementById('upload-conflict-modal'); const mergeBtn = document.getElementById('upload-conflict-merge-btn'); const replaceBtn = document.getElementById('upload-conflict-replace-btn'); const cancelBtn = document.getElementById('upload-conflict-cancel-btn'); const cleanup = () => { modal.classList.remove('visible'); mergeBtn.replaceWith(mergeBtn.cloneNode(true)); replaceBtn.replaceWith(replaceBtn.cloneNode(true)); cancelBtn.replaceWith(cancelBtn.cloneNode(true)); }; const onMerge = () => { cleanup(); resolve('merge'); }; const onReplace = () => { cleanup(); resolve('replace'); }; const onCancel = () => { cleanup(); reject(new Error('User cancelled upload.')); }; mergeBtn.addEventListener('click', onMerge, { once: true }); replaceBtn.addEventListener('click', onReplace, { once: true }); cancelBtn.addEventListener('click', onCancel, { once: true }); modal.classList.add('visible'); }); }

    // --- VANTA.JS DYNAMIC BACKGROUNDS (UNCHANGED) ---
    let vantaEffect = null; const vantaElement = document.body; let vantaBackgroundKeys = []; let currentBackgroundKey = null; const baseGlobalParams = { mouseControls: true, touchControls: true, gyroControls: false, minHeight: 200.00, minWidth: 200.00, scale: 1.00, scaleMobile: 1.00, }; const effectConfigurations = { "FOG_Soft_Blue": { effect: "FOG", params: { highlightColor: 0x80deea, midtoneColor: 0x26c6da, lowlightColor: 0x00acc1, baseColor: 0xf4f6f8, blurFactor: 0.6, zoom: 1.2, speed: 1.0 }}, "WAVES_Ocean": { effect: "WAVES", params: { color: 0x005577, shininess: 30, waveHeight: 15, waveSpeed: 0.8, zoom: 1.0 }}, "BIRDS_Day_Sky": { effect: "BIRDS", params: { backgroundColor: 0x87ceeb, color1: 0x444444, color2: 0x666666, birdSize: 1.0, wingSpan: 20.00, speedLimit: 3.00, separation: 20.00, alignment: 20.00, cohesion: 20.00, quantity: 4 }}, "NET_Cyber_Grid": { effect: "NET", params: { color: 0x00ffff, backgroundColor: 0x000022, points: 10.00, maxDistance: 20.00, spacing: 15.00, showDots: true }}, "CELLS_Bio_Blue": { effect: "CELLS", params: { color1: 0x2196f3, color2: 0x90caf9, size: 3.0, speed: 1.0 }}, "CLOUDS_Sunny_Day": { effect: "CLOUDS", params: { skyColor: 0x68b8d7, cloudColor: 0xadc1de, cloudShadowColor: 0x183550, sunColor: 0xff9919, sunGlareColor: 0xff6633, sunlightColor: 0xff9933, speed: 1.0 }}, "DOTS_Starfield": { effect: "DOTS", params: { color: 0xffffff, color2: 0xdddddd, backgroundColor: 0x000011, size: 3.00, spacing: 30.00, showLines: false }}, "RINGS_Golden_Aura": { effect: "RINGS", params: { backgroundColor: 0x110022, color: 0xffd700, strength: 2.00 }}, "HALO_Gentle_Sun": { effect: "HALO", params: { baseColor: 0xffe082, backgroundColor: 0xfff8e1, amplitudeFactor: 0.5, size: 1.0 }}, "FOG_Mystic_Purple": { effect: "FOG", params: { highlightColor: 0xff00ff, midtoneColor: 0xaa00aa, lowlightColor: 0x550055, baseColor: 0x300030, blurFactor: 0.7, zoom: 1.0, speed: 0.8 }}, "WAVES_Lava": { effect: "WAVES", params: { color: 0xff3300, shininess: 10, waveHeight: 25, waveSpeed: 0.4, zoom: 0.75 }}, "BIRDS_Sunset": { effect: "BIRDS", params: { backgroundColor: 0xffa07a, color1: 0x5d4037, color2: 0x000000, birdSize: 1.2, wingSpan: 25.00, quantity: 3, speedLimit: 2.00 }}, "NET_Golden_Web": { effect: "NET", params: { color: 0xffd700, backgroundColor: 0x301934, points: 8.00, maxDistance: 25.00, spacing: 20.00, showDots: true }}, "CELLS_Pulsing_Red": { effect: "CELLS", params: { color1: 0xf44336, color2: 0xffcdd2, size: 4.5, speed: 0.5 }}, "CLOUDS_Evening_Sky": { effect: "CLOUDS", params: { skyColor: 0x334d5c, cloudColor: 0x8e8e8e, cloudShadowColor: 0x2e2e2e, sunColor: 0xf57c00, sunGlareColor: 0xffb74d, sunlightColor: 0xffa726, speed: 0.6 }}, "DOTS_Colorful_Grid": { effect: "DOTS", params: { color: 0xff00ff, color2: 0x00ff00, backgroundColor: 0x222222, size: 5.00, spacing: 25.00, showLines: true }}, "RINGS_Blue_Energy": { effect: "RINGS", params: { backgroundColor: 0x001020, color: 0x00aaff, strength: 3.50 }}, "HALO_Deep_Space": { effect: "HALO", params: { baseColor: 0x7e57c2, backgroundColor: 0x1a001a, amplitudeFactor: 1.5, size: 1.2, xOffset: 0.2, yOffset: 0.1 }} };
    function applyVantaEffect(configKey) { if (vantaEffect) { try { vantaEffect.destroy(); } catch (e) { console.error("Err destroy vanta:", e); } vantaEffect = null; } if (!configKey) { currentBackgroundKey = null; return; } const config = effectConfigurations[configKey]; if (!config || typeof VANTA === 'undefined' || typeof VANTA[config.effect] !== 'function') { console.error(`Vanta effect ${configKey} error.`); currentBackgroundKey = null; return; } const finalParams = { el: vantaElement, ...baseGlobalParams, ...config.params }; try { vantaEffect = VANTA[config.effect](finalParams); currentBackgroundKey = configKey; document.body.style.backgroundColor = ''; } catch (error) { console.error(`Err init Vanta '${config.effect}':`, error); vantaEffect = null; currentBackgroundKey = null; } }
    const pastelBackgroundColors = [ "#c9e4c5", "#f9e6cf", "#d4e9f7", "#fde8f2", "#e6e6fa", "#fffacd", ]; let currentPastelBgIndex = 0;
    function updateBackgroundState() { const shouldAnimate = animatedBackgroundsEnabled && !PREFERS_REDUCED_MOTION; if (toggleBackgroundBtn) { toggleBackgroundBtn.textContent = `Background: ${animatedBackgroundsEnabled ? 'Animated' : 'Static'}`; toggleBackgroundBtn.classList.toggle('active-animated-bg', animatedBackgroundsEnabled); } if (shouldAnimate) { document.body.style.backgroundColor = ''; let keyToApply = currentBackgroundKey; if (!keyToApply || !effectConfigurations[keyToApply]) { if (vantaBackgroundKeys && vantaBackgroundKeys.length > 0) { keyToApply = vantaBackgroundKeys[0]; } else { keyToApply = null; } } if (keyToApply) { applyVantaEffect(keyToApply); } else { if (vantaEffect) applyVantaEffect(null); document.body.style.backgroundColor = pastelBackgroundColors[currentPastelBgIndex % pastelBackgroundColors.length]; } } else { if (vantaEffect) { applyVantaEffect(null); } const staticBgColor = pastelBackgroundColors[currentPastelBgIndex % pastelBackgroundColors.length]; document.body.style.backgroundColor = staticBgColor; } }

    // --- Timer Globals (UNCHANGED) ---
    let isTimerPaused    = false; let remainingMs = 0; let timerStartTs = 0; let onDoneCallback;

    // --- UI REFERENCES ---
    const wordChoiceBtns = [document.getElementById('choice0'), document.getElementById('choice1')];
    const scoreVal   = document.getElementById('score-val');
    const timerDisp  = document.getElementById('timer-display');
    const timerSel   = document.getElementById('timer-select');
    const listenBtn  = document.getElementById('listen-btn');
    const quizCont   = document.getElementById('quiz-container');
    const controlsBar = document.getElementById('controls');
    const modeToggleBtn = document.getElementById('mode-toggle-btn');
    const listenPickWordArea = document.getElementById('listen-pick-word-area');
    const readPickSoundArea = document.getElementById('read-pick-sound-area');
    const wordToReadDisplay = document.getElementById('word-to-read');
    const soundChoiceBtns = [document.getElementById('soundChoice0'), document.getElementById('soundChoice1')];
    const submitAnswerBtn = document.getElementById('submit-answer-btn');
    const confettiCanvas = document.getElementById('confetti-canvas');
    const myConfetti = confetti.create(confettiCanvas, { resize: true, useWorker: true });

    // Word List Modal UI Refs (NEW)
    const wordListOpenBtn = document.getElementById('word-list-open-btn');
    const wordCountBadge = document.getElementById('word-count-badge');
    const wordListModal = document.getElementById('word-list-modal');
    const wordListCloseBtn = document.getElementById('word-list-close-btn');
    const wordListSaveBtn = document.getElementById('word-list-save-btn');
    const wordListSummaryText = document.getElementById('word-list-summary-text');
    const wordListTotalCount = document.getElementById('word-list-total-count');
    const wordListTreeContainer = document.getElementById('word-list-tree-container');
    const bankDisplayNames = { dolch: "Dolch Sight Words", fry: "Fry Sight Words", custom: "My Custom Words" };

    const wordCustomizationModal = document.getElementById('word-customization-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalLevelSelector = document.getElementById('modal-level-selector');
    const modalLevelSelectorLabel = document.getElementById('modal-level-selector-label');
    const modalSearchInput = document.getElementById('modal-search-input');
    const modalWordList = document.getElementById('modal-word-list');
    const modalAddCustomWordBtn = document.getElementById('modal-add-custom-word-btn');
    const modalAddCustomWordTerm = document.getElementById('modal-add-custom-word-term');
    const modalSaveBtn = document.getElementById('modal-save-btn');
    const modalSelectAllBtn = document.getElementById('modal-select-all-btn');
    const modalDeselectAllBtn = document.getElementById('modal-deselect-all-btn');
    const modalDownloadBtn = document.getElementById('modal-download-btn');
    const modalUploadBtn = document.getElementById('modal-upload-btn');
    const uploadFileInput = document.getElementById('upload-file-input');
    const modalCloseBtn = document.getElementById('modal-close-btn');

    const uploadChoiceModal = document.getElementById('upload-choice-modal');
    const pasteJsonModal = document.getElementById('paste-json-modal');

    const miniGameArea = document.getElementById('minigame-area');
    const toggleMiniGamesBtn = document.getElementById('toggle-minigames-btn');
    const toggleBackgroundBtn = document.getElementById('toggle-background-btn');

    // --- GAME STATE ---
    let circleTimerInstance;
    let questionTimeoutId;
    let questionAnsweredThisTurn = false;
    let score = 0;
    let timeLimit = 20;
    let currentCorrectWord = "";
    let currentStreak = 0;
    const streakThresholds = {3: "Streak x3!", 5: "Super Streak x5!", 10: "AMAZING x10!"};
    let currentGameMode = localStorage.getItem('sightWordsGameMode') || 'listenAndPickWord';
    let selectedSoundButton = null;
    let currentModalListContext = 'dolch';
    let currentModalLevelContext = 'A';    
    let tempSelectionState = {}; // For non-destructive editing in the modal
    let miniGamesEnabled = localStorage.getItem('miniGamesEnabled') === 'true';
    let isMiniGameActive = false;
    let availableMiniGames = []; 
    let currentMiniGameIdx = 0;
    let animatedBackgroundsEnabled = localStorage.getItem('animatedBackgroundsEnabled') !== 'true';
    let PREFERS_REDUCED_MOTION = window.matchMedia('(prefers-reduced-motion: reduce)').matches;


    // ---- INITIALIZATION & STATE HYDRATION (REWRITTEN) ----
    function hydrateFromStorage() {
        try {
            const storedCustomBank = localStorage.getItem('customBank');
            if (storedCustomBank) { WORD_BANK.custom = JSON.parse(storedCustomBank); }
        } catch (e) { console.error("Error parsing customBank from localStorage:", e); WORD_BANK.custom = []; }
        
        const storedSelectionState = localStorage.getItem('wordSelectionState');
        if (storedSelectionState) {
            try { selectionState = JSON.parse(storedSelectionState); } 
            catch (e) { console.error("Error parsing selectionState, creating default.", e); createDefaultSelectionState(); }
        } else {
            const oldActiveList = localStorage.getItem('activeWordList');
            const oldSelectedLevels = JSON.parse(localStorage.getItem('selectedLevels') || 'null');
            
            if (oldActiveList && oldSelectedLevels) {
                console.log("Migrating from old word list format...");
                selectionState = {};
                Object.keys(WORD_BANK).forEach(listKey => {
                    selectionState[listKey] = {};
                    if (listKey === 'custom') { selectionState.custom.all = (oldActiveList === 'custom'); } 
                    else { Object.keys(WORD_BANK[listKey]).forEach(levelKey => { selectionState[listKey][levelKey] = (oldActiveList === listKey && oldSelectedLevels.includes(levelKey)); }); }
                });
                localStorage.removeItem('activeWordList');
                localStorage.removeItem('selectedLevels');
            } else { createDefaultSelectionState(); }
            localStorage.setItem('wordSelectionState', JSON.stringify(selectionState));
        }

        miniGamesEnabled = localStorage.getItem('miniGamesEnabled') === 'true';
        const raw = localStorage.getItem('animatedBackgroundsEnabled');
        animatedBackgroundsEnabled = (raw === 'true');
        currentGameMode = localStorage.getItem('sightWordsGameMode') || 'listenAndPickWord';
        const storedTimeLimit = localStorage.getItem('quizTimeLimit');
        if (storedTimeLimit !== null && !isNaN(parseInt(storedTimeLimit))) { timeLimit = parseInt(storedTimeLimit); }
        updateQuizWordsFromSelectionState();
    }

    function createDefaultSelectionState() {
        selectionState = {};
        Object.keys(WORD_BANK).forEach(listKey => {
            selectionState[listKey] = {};
            if (listKey === 'custom') {
                selectionState.custom.all = true;
            } else {
                const levelKeys = Object.keys(WORD_BANK[listKey]);
                levelKeys.forEach((levelKey, index) => {
                    selectionState[listKey][levelKey] = (listKey === 'dolch' && index === 0);
                });
            }
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
      vantaBackgroundKeys = Object.keys(effectConfigurations);
      hydrateFromStorage();

      const initialScoreTier = Math.floor(score / 10);
      if (vantaBackgroundKeys.length > 0) { currentBackgroundKey = vantaBackgroundKeys[initialScoreTier % vantaBackgroundKeys.length]; }
      else { currentBackgroundKey = null; }
      currentPastelBgIndex = initialScoreTier % pastelBackgroundColors.length;
      updateBackgroundState();

      if (toggleBackgroundBtn) {
          toggleBackgroundBtn.addEventListener('click', () => {
              animatedBackgroundsEnabled = !animatedBackgroundsEnabled;
              localStorage.setItem('animatedBackgroundsEnabled', animatedBackgroundsEnabled.toString());
              updateBackgroundState();
          });
      }

      const mediaQueryReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
      mediaQueryReducedMotion.addEventListener('change', (event) => {
          PREFERS_REDUCED_MOTION = event.matches;
          updateBackgroundState();
      });
      
      initWordListModal();
      initMiniGameSystem();
      updateModeUI();
      initCircularTimer();

      for(let i=0;i<=30;i++){ let o = document.createElement('option'); o.value = i; o.textContent = i+'s' + (i === 0 ? ' (Untimed)' : ''); timerSel.append(o); }
      timerSel.value = timeLimit;
      timerDisp.textContent = timeLimit > 0 ? timeLimit+'s ⏱️' : 'Untimed ⏱️';

      modalSaveBtn.addEventListener('click', saveWordCustomizationModal);
      modalCloseBtn.addEventListener('click', closeWordCustomizationModal);
      modalSelectAllBtn.addEventListener('click', () => toggleAllModalWords(true));
      modalDeselectAllBtn.addEventListener('click', () => toggleAllModalWords(false));
      modalSearchInput.addEventListener('input', populateModalWordList);
      modalLevelSelector.addEventListener('change', (e) => {
          if (currentModalListContext !== 'custom') {
            currentModalLevelContext = e.target.value;
            modalTitle.textContent = `Customize: ${currentModalListContext.charAt(0).toUpperCase() + currentModalListContext.slice(1)} - ${(currentModalListContext === 'dolch' ? "Level " : "")}${currentModalLevelContext}`;
            populateModalWordList();
          }
      });
      modalAddCustomWordBtn.addEventListener('click', handleAddCustomWordFromModal);
      modalDownloadBtn.addEventListener('click', downloadWordData);
      
      modalUploadBtn.addEventListener('click', () => uploadChoiceModal.classList.add('visible'));
      uploadFileInput.addEventListener('change', handleFileUpload);
      
      document.getElementById('upload-choice-cancel-btn').addEventListener('click', () => uploadChoiceModal.classList.remove('visible'));
      document.getElementById('upload-choice-file-btn').addEventListener('click', () => { uploadChoiceModal.classList.remove('visible'); triggerFileUpload(); });
      document.getElementById('upload-choice-paste-btn').addEventListener('click', () => { uploadChoiceModal.classList.remove('visible'); pasteJsonModal.classList.add('visible'); document.getElementById('paste-json-textarea').value = ''; });
      document.getElementById('paste-json-cancel-btn').addEventListener('click', () => pasteJsonModal.classList.remove('visible'));
      document.getElementById('paste-json-process-btn').addEventListener('click', async () => {
          const jsonText = document.getElementById('paste-json-textarea').value;
          if (!jsonText.trim()) { showFloatingMessage("Text box is empty.", "var(--incorrect-bg)"); return; }
          try { const importedData = JSON.parse(jsonText); pasteJsonModal.classList.remove('visible'); await processImportedData(importedData); }
          catch (error) { showFloatingMessage("Invalid JSON. Please check the text.", "var(--incorrect-bg)"); }
      });
    });

    // --- Speak helper (UNCHANGED)---
    function speak(txt, rate = 0.9, pitch = 1.1){ if('speechSynthesis' in window){ speechSynthesis.cancel(); let textToSpeak = pronunciationMap[txt] || String(txt); let u = new SpeechSynthesisUtterance(textToSpeak); u.rate = rate; u.pitch = pitch; speechSynthesis.speak(u); } }
    function getRandomColor() { const r = Math.floor(Math.random() * 200); const g = Math.floor(Math.random() * 200); const b = Math.floor(Math.random() * 200); return `rgb(${r},${g},${b})`; }


    // ******************************************************
    // *    MINI-GAME OBJECT DEFINITIONS (UNCHANGED)        *
    // ******************************************************
    const CatchTheStarGame = { name: "Catch the Star", score: 0, gameTimerId: null, starIntervalId: null, timerIntervalId: null, animationFrameId: null, container: null, onCompleteCallback: null, duration: 20000, starsOnScreen: [], elements: {}, hoopElement: null, isHoopingActive: false, hoopRadius: 50, starVisualRadius: 20, hoopPosition: { x: 0, y: 0 }, boundOnPointerDown: null, boundOnPointerMove: null, boundOnPointerUp: null, boundGameLoop: null, start: function(containerElement, onComplete) { this.container = containerElement; this.onCompleteCallback = onComplete; this.score = 0; this.starsOnScreen = []; this.container.innerHTML = ''; speak("Catch the stars in your hoop!"); const infoBar = document.createElement('div'); infoBar.className = 'minigame-info-bar'; this.elements.scoreDisplay = document.createElement('div'); this.elements.scoreDisplay.className = 'minigame-score'; infoBar.appendChild(this.elements.scoreDisplay); this.updateScoreDisplay(); const timerContainer = document.createElement('div'); timerContainer.className = 'minigame-timer-bar-container'; this.elements.timerBar = document.createElement('div'); this.elements.timerBar.className = 'minigame-timer-bar'; timerContainer.appendChild(this.elements.timerBar); infoBar.appendChild(timerContainer); this.container.appendChild(infoBar); let timeLeft = this.duration; this.elements.timerBar.style.width = '100%'; this.timerIntervalId = setInterval(() => { timeLeft -= 100; const progress = Math.max(0, (timeLeft / this.duration) * 100); this.elements.timerBar.style.width = `${progress}%`; if (timeLeft <= 0) clearInterval(this.timerIntervalId); }, 100); this.hoopElement = document.createElement('div'); this.hoopElement.style.position = 'absolute'; this.hoopElement.style.width = `${this.hoopRadius * 2}px`; this.hoopElement.style.height = `${this.hoopRadius * 2}px`; this.hoopElement.style.border = '3px dashed white'; this.hoopElement.style.borderRadius = '50%'; this.hoopElement.style.boxSizing = 'border-box'; this.hoopElement.style.display = 'none'; this.hoopElement.style.pointerEvents = 'none'; this.container.appendChild(this.hoopElement); this.boundOnPointerDown = this.onPointerDown.bind(this); this.boundOnPointerMove = this.onPointerMove.bind(this); this.boundOnPointerUp = this.onPointerUp.bind(this); this.boundGameLoop = this.gameLoop.bind(this); this.container.addEventListener('pointerdown', this.boundOnPointerDown); window.addEventListener('pointermove', this.boundOnPointerMove); window.addEventListener('pointerup', this.boundOnPointerUp); window.addEventListener('pointercancel', this.boundOnPointerUp); this.starIntervalId = setInterval(() => this.spawnStar(), 800); this.gameTimerId = setTimeout(() => this.endGame(), this.duration); this.animationFrameId = requestAnimationFrame(this.boundGameLoop); }, onPointerDown: function(event) { if (event.target !== this.container && !this.container.contains(event.target)) { let el = event.target; let isInsideContainer = false; while(el) { if (el === this.container) { isInsideContainer = true; break; } el = el.parentElement; } if(!isInsideContainer) return; } event.preventDefault(); this.isHoopingActive = true; this.updateHoopDisplay(event); this.hoopElement.style.display = 'block'; }, onPointerMove: function(event) { if (this.isHoopingActive) { event.preventDefault(); this.updateHoopDisplay(event); } }, onPointerUp: function(event) { if (this.isHoopingActive) { this.isHoopingActive = false; this.hoopElement.style.display = 'none'; } }, updateHoopDisplay: function(event) { if (!this.container) return; const rect = this.container.getBoundingClientRect(); this.hoopPosition.x = event.clientX - rect.left; this.hoopPosition.y = event.clientY - rect.top; this.hoopElement.style.left = `${this.hoopPosition.x - this.hoopRadius}px`; this.hoopElement.style.top = `${this.hoopPosition.y - this.hoopRadius}px`; }, gameLoop: function() { if (this.isHoopingActive) { this.checkHoopCollisions(); } this.animationFrameId = requestAnimationFrame(this.boundGameLoop); }, checkHoopCollisions: function() { if (!this.isHoopingActive || this.starsOnScreen.length === 0) return; for (let i = this.starsOnScreen.length - 1; i >= 0; i--) { const starData = this.starsOnScreen[i]; const starElement = starData.element; if (!starElement.parentNode) { this.starsOnScreen.splice(i, 1); continue; } const starCenterX = starElement.offsetLeft + starElement.offsetWidth / 2; const starCenterY = starElement.offsetTop + starElement.offsetHeight / 2; const dx = this.hoopPosition.x - starCenterX; const dy = this.hoopPosition.y - starCenterY; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < this.hoopRadius + this.starVisualRadius) { this._processStarCatch(starData, i); } } }, spawnStar: function() { if (!this.container || this.starsOnScreen.length > 12) return; const star = document.createElement('div'); star.style.position = 'absolute'; star.style.width = '40px'; star.style.height = '40px'; star.style.left = `${Math.random() * (this.container.clientWidth - 40)}px`; star.style.top = `-40px`; star.style.fontSize = '2.2rem'; star.style.userSelect = 'none'; star.style.transition = 'top 1.9s linear, transform 0.3s ease-out'; star.textContent = '⭐'; this.container.appendChild(star); const starData = { element: star, removeTimeoutId: null }; this.starsOnScreen.push(starData); setTimeout(() => { if (star.parentNode) { star.style.top = `${this.container.clientHeight}px`; } }, 30); starData.removeTimeoutId = setTimeout(() => { const index = this.starsOnScreen.indexOf(starData); if (index !== -1) { if (star.parentNode) { star.remove(); } this.starsOnScreen.splice(index, 1); } }, 1900); }, _processStarCatch: function(starData, starArrayIndex) { const starElement = starData.element; clearTimeout(starData.removeTimeoutId); playBell(); const rect = starElement.getBoundingClientRect(); const x = (rect.left + rect.right) / 2 / window.innerWidth; const y = (rect.top + rect.bottom) / 2 / window.innerHeight; myConfetti({ particleCount: 25, spread: 45, origin: { x: x, y: y }, scalar: 0.6 }); this.score++; speak(this.score, 1.2, 1.3); this.updateScoreDisplay(); starElement.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out'; starElement.style.transform = 'scale(0.1)'; starElement.style.opacity = '0'; setTimeout(() => { if (starElement.parentNode) { starElement.remove(); } }, 300); if (starArrayIndex !== undefined && starArrayIndex < this.starsOnScreen.length && this.starsOnScreen[starArrayIndex] === starData) { this.starsOnScreen.splice(starArrayIndex, 1); } else { const index = this.starsOnScreen.indexOf(starData); if (index !== -1) this.starsOnScreen.splice(index, 1); } }, updateScoreDisplay: function() { if(this.elements.scoreDisplay) this.elements.scoreDisplay.textContent = `Stars: ${this.score}`; }, endGame: function() { const canCallPrimaryCallback = !!this.onCompleteCallback; clearInterval(this.starIntervalId); this.starIntervalId = null; clearInterval(this.timerIntervalId); this.timerIntervalId = null; clearTimeout(this.gameTimerId); this.gameTimerId = null; if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; } if (this.container) { this.container.removeEventListener('pointerdown', this.boundOnPointerDown); } window.removeEventListener('pointermove', this.boundOnPointerMove); window.removeEventListener('pointerup', this.boundOnPointerUp); window.removeEventListener('pointercancel', this.boundOnPointerUp); this.starsOnScreen.forEach(starData => { clearTimeout(starData.removeTimeoutId); if (starData.element.parentNode) { starData.element.remove(); } }); this.starsOnScreen = []; if (this.hoopElement && this.hoopElement.parentNode) { this.hoopElement.remove(); } this.hoopElement = null; this.isHoopingActive = false; if (canCallPrimaryCallback) { speak(`Congratulations! You caught ${this.score} stars!`); const callbackToExecute = this.onCompleteCallback; this.onCompleteCallback = null; if (callbackToExecute) { callbackToExecute(this.score); } } }, destroy: function() { this.endGame(); if (this.container) { this.container.innerHTML = ''; } this.container = null; this.elements = {}; this.onCompleteCallback = null; } };
    const BalloonPopGame = { name: "Balloon Pop", score: 0, gameTimerId: null, timerIntervalId: null, balloonIntervalId: null, container: null, onCompleteCallback: null, duration: 20000, balloonsOnScreen: [], elements: {}, forgivingTapRadius: 70, boundForgivingTapHandler: null, start: function(containerElement, onComplete) { this.container = containerElement; this.onCompleteCallback = onComplete; this.score = 0; this.balloonsOnScreen = []; this.container.innerHTML = ''; speak("Tap as many balloons as you can before time runs out!"); const infoBar = document.createElement('div'); infoBar.className = 'minigame-info-bar'; this.elements.scoreDisplay = document.createElement('div'); this.elements.scoreDisplay.className = 'minigame-score'; infoBar.appendChild(this.elements.scoreDisplay); this.updateScoreDisplay(); const timerContainer = document.createElement('div'); timerContainer.className = 'minigame-timer-bar-container'; this.elements.timerBar = document.createElement('div'); this.elements.timerBar.className = 'minigame-timer-bar'; timerContainer.appendChild(this.elements.timerBar); infoBar.appendChild(timerContainer); this.container.appendChild(infoBar); let timeLeft = this.duration; this.elements.timerBar.style.width = '100%'; this.timerIntervalId = setInterval(() => { timeLeft -= 100; const progress = Math.max(0, (timeLeft / this.duration) * 100); this.elements.timerBar.style.width = `${progress}%`; if (timeLeft <= 0) clearInterval(this.timerIntervalId); }, 100); this.balloonIntervalId = setInterval(() => this.spawnBalloon(), 700); this.gameTimerId = setTimeout(() => this.endGame(), this.duration); this.boundForgivingTapHandler = this._handleForgivingTap.bind(this); this.container.addEventListener('pointerdown', this.boundForgivingTapHandler); }, _handleForgivingTap: function(event) { if (!this.container) return; const clickX = event.clientX; const clickY = event.clientY; for (let i = this.balloonsOnScreen.length - 1; i >= 0; i--) { const balloonElement = this.balloonsOnScreen[i]; if (!balloonElement || !balloonElement.parentNode) { if (this.balloonsOnScreen[i] === balloonElement) { this.balloonsOnScreen.splice(i, 1); } continue; } const balloonRect = balloonElement.getBoundingClientRect(); const balloonViewportCenterX = balloonRect.left + balloonRect.width / 2; const balloonViewportCenterY = balloonRect.top + balloonRect.height / 2; const distance = Math.sqrt( Math.pow(clickX - balloonViewportCenterX, 2) + Math.pow(clickY - balloonViewportCenterY, 2) ); if (distance <= this.forgivingTapRadius) { this.popBalloon(balloonElement); } } }, spawnBalloon: function() { if (!this.container || this.balloonsOnScreen.length > 15) return; const balloon = document.createElement('div'); balloon.className = 'balloon'; balloon.style.backgroundColor = getRandomColor(); balloon.style.left = `${Math.random() * (this.container.clientWidth - parseFloat(getComputedStyle(balloon).width || '60'))}px`; balloon.style.bottom = '-100px'; this.container.appendChild(balloon); this.balloonsOnScreen.push(balloon); balloon.classList.add('balloon-rising'); balloon.addEventListener('animationend', () => { const index = this.balloonsOnScreen.indexOf(balloon); if (index > -1) { this.balloonsOnScreen.splice(index, 1); } if (balloon.parentNode) { balloon.remove(); } }, { once: true }); }, popBalloon: function(balloonElement) { const index = this.balloonsOnScreen.indexOf(balloonElement); if (index === -1) return; playBell(); const rect = balloonElement.getBoundingClientRect(); const confettiX = (rect.left + rect.right) / 2 / window.innerWidth; const confettiY = (rect.top + rect.bottom) / 2 / window.innerHeight; myConfetti({ particleCount: 30, spread: 50, origin: { x: confettiX, y: confettiY }, scalar: 0.7 }); this.score++; speak(this.score, 1.2, 1.3); this.updateScoreDisplay(); if (balloonElement.parentNode) { balloonElement.remove(); } this.balloonsOnScreen.splice(index, 1); }, updateScoreDisplay: function() { if(this.elements.scoreDisplay) this.elements.scoreDisplay.textContent = `Popped: ${this.score}`; }, endGame: function() { const canCallPrimaryCallback = !!this.onCompleteCallback; clearInterval(this.balloonIntervalId); this.balloonIntervalId = null; clearInterval(this.timerIntervalId); this.timerIntervalId = null; clearTimeout(this.gameTimerId); this.gameTimerId = null; if (this.boundForgivingTapHandler && this.container) { this.container.removeEventListener('pointerdown', this.boundForgivingTapHandler); } this.balloonsOnScreen.forEach(b => { if (b.parentNode) b.remove(); }); this.balloonsOnScreen = []; if (canCallPrimaryCallback) { speak(`You popped ${this.score} balloons!`); const callbackToExecute = this.onCompleteCallback; this.onCompleteCallback = null; if(callbackToExecute) callbackToExecute(this.score); } }, destroy: function() { this.endGame(); this.boundForgivingTapHandler = null; if (this.container) { this.container.innerHTML = ''; } this.container = null; this.elements = {}; this.onCompleteCallback = null; } };
    const HoopBounceGame = { name: "Hoop Bounce", score: 0, gameTimerId: null, timerDisplayIntervalId: null, animationFrameId: null, container: null, onCompleteCallback: null, duration: 20000, elements: {}, hoopElement: null, isHoopActive: false, hoopRadius: 55, hoopEffectiveRadius: 50, hoopBorderThickness: 5, hoopPosition: { x: 0, y: 0 }, ballElement: null, ballRadius: 15, ballPosition: { x: 100, y: 100 }, ballVelocity: { x: 2, y: 1 }, gravity: 0.28, wallRestitution: 0.65, maxSpeed: 17, strongUpwardBounceForce: 13.5, maxHorizontalSpeedFromHoop: 7.5, boundOnPointerDown: null, boundOnPointerMove: null, boundOnPointerUp: null, boundGameLoop: null, start: function(containerElement, onComplete) { this.container = containerElement; this.onCompleteCallback = onComplete; this.score = 0; this.container.innerHTML = ''; speak("Keepy Uppy!"); const infoBar = document.createElement('div'); infoBar.className = 'minigame-info-bar'; this.elements.scoreDisplay = document.createElement('div'); this.elements.scoreDisplay.className = 'minigame-score'; infoBar.appendChild(this.elements.scoreDisplay); this.updateScoreDisplay(); this.elements.timerText = document.createElement('div'); this.elements.timerText.className = 'minigame-timer-text'; infoBar.appendChild(this.elements.timerText); this.container.appendChild(infoBar); this.hoopElement = document.createElement('div'); this.hoopElement.style.cssText = `position: absolute; width: ${this.hoopRadius * 2}px; height: ${this.hoopRadius * 2}px; border: ${this.hoopBorderThickness}px solid white; border-radius: 50%; box-sizing: border-box; display: none; pointer-events: none; opacity: 0.8;`; this.container.appendChild(this.hoopElement); this.ballElement = document.createElement('div'); this.ballElement.className = 'bounce-ball'; this.ballElement.style.cssText = `width: ${this.ballRadius * 2}px; height: ${this.ballRadius * 2}px; background-color: var(--brand-light); border-radius: 50%; position: absolute;`; this.container.appendChild(this.ballElement); this.ballPosition.x = this.container.clientWidth / 2; this.ballPosition.y = this.ballRadius + 50; this.ballVelocity.x = (Math.random() - 0.5) * 4; this.ballVelocity.y = 1; this.updateBallElementPosition(); this.boundOnPointerDown = this.onPointerDown.bind(this); this.boundOnPointerMove = this.onPointerMove.bind(this); this.boundOnPointerUp = this.onPointerUp.bind(this); this.boundGameLoop = this.gameLoop.bind(this); this.container.addEventListener('pointerdown', this.boundOnPointerDown); window.addEventListener('pointermove', this.boundOnPointerMove); window.addEventListener('pointerup', this.boundOnPointerUp); window.addEventListener('pointercancel', this.boundOnPointerUp); let timeLeftSeconds = this.duration / 1000; this.elements.timerText.textContent = `Time: ${timeLeftSeconds}s`; this.timerDisplayIntervalId = setInterval(() => { timeLeftSeconds--; this.elements.timerText.textContent = `Time: ${Math.max(0, timeLeftSeconds)}s`; if (timeLeftSeconds <= 0) clearInterval(this.timerDisplayIntervalId); }, 1000); this.gameTimerId = setTimeout(() => this.endGame(), this.duration); this.animationFrameId = requestAnimationFrame(this.boundGameLoop); }, onPointerDown: function(event) { let el = event.target; let isInsideContainer = false; while(el) { if (el === this.container) { isInsideContainer = true; break; } el = el.parentElement; } if(!isInsideContainer && event.target !== this.container) return; event.preventDefault(); this.isHoopActive = true; this.updateHoopElementPosition(event); this.hoopElement.style.display = 'block'; }, onPointerMove: function(event) { if (this.isHoopActive) { event.preventDefault(); this.updateHoopElementPosition(event); } }, onPointerUp: function(event) { if (this.isHoopActive) { this.isHoopActive = false; this.hoopElement.style.display = 'none'; } }, updateHoopElementPosition: function(event) { if (!this.container) return; const rect = this.container.getBoundingClientRect(); this.hoopPosition.x = event.clientX - rect.left; this.hoopPosition.y = event.clientY - rect.top; this.hoopElement.style.left = `${this.hoopPosition.x - this.hoopRadius}px`; this.hoopElement.style.top = `${this.hoopPosition.y - this.hoopRadius}px`; }, updateBallElementPosition: function() { if (!this.ballElement) return; this.ballElement.style.left = `${this.ballPosition.x - this.ballRadius}px`; this.ballElement.style.top = `${this.ballPosition.y - this.ballRadius}px`; }, gameLoop: function() { if (!this.container || !this.ballElement) { cancelAnimationFrame(this.animationFrameId); return; } this.applyPhysics(); this.checkWallCollisions(); if (this.isHoopActive) { this.checkHoopCollision(); } this.limitSpeed(); this.updateBallElementPosition(); this.animationFrameId = requestAnimationFrame(this.boundGameLoop); }, applyPhysics: function() { this.ballVelocity.y += this.gravity; this.ballPosition.x += this.ballVelocity.x; this.ballPosition.y += this.ballVelocity.y; }, limitSpeed: function() { const speed = Math.sqrt(this.ballVelocity.x * this.ballVelocity.x + this.ballVelocity.y * this.ballVelocity.y); if (speed > this.maxSpeed) { const factor = this.maxSpeed / speed; this.ballVelocity.x *= factor; this.ballVelocity.y *= factor; } }, checkWallCollisions: function() { const restitution = this.wallRestitution; if (this.ballPosition.x - this.ballRadius < 0) { this.ballPosition.x = this.ballRadius; this.ballVelocity.x *= -restitution; } if (this.ballPosition.x + this.ballRadius > this.container.clientWidth) { this.ballPosition.x = this.container.clientWidth - this.ballRadius; this.ballVelocity.x *= -restitution; } if (this.ballPosition.y - this.ballRadius < 0) { this.ballPosition.y = this.ballRadius; this.ballVelocity.y *= -restitution; } if (this.ballPosition.y + this.ballRadius > this.container.clientHeight) { this.ballPosition.y = this.container.clientHeight - this.ballRadius; this.ballVelocity.y *= -restitution; } }, checkHoopCollision: function() { const dx = this.ballPosition.x - this.hoopPosition.x; const dy = this.ballPosition.y - this.hoopPosition.y; const distance = Math.sqrt(dx * dx + dy * dy); const collisionDistance = this.hoopEffectiveRadius + this.ballRadius; if (distance < collisionDistance && distance > 0) { const normalX = dx / distance; const normalY = dy / distance; const velocityAlongNormal = this.ballVelocity.x * normalX + this.ballVelocity.y * normalY; if (velocityAlongNormal < 0) { this.ballVelocity.y = -this.strongUpwardBounceForce; const relativeHitX = this.ballPosition.x - this.hoopPosition.x; let normalizedHitX = Math.max(-1, Math.min(1, relativeHitX / this.hoopEffectiveRadius)); this.ballVelocity.x = normalizedHitX * this.maxHorizontalSpeedFromHoop; if (Math.abs(this.ballVelocity.x) < 0.5 && Math.abs(normalizedHitX) > 0.05) { this.ballVelocity.x = Math.sign(normalizedHitX) * 0.5; } const overlap = collisionDistance - distance; if (overlap > 0) { this.ballPosition.x += overlap * normalX * 1.05; this.ballPosition.y += overlap * normalY * 1.05; } this.score++; this.updateScoreDisplay(); playBell(); const ballRect = this.ballElement.getBoundingClientRect(); const confettiX = (ballRect.left + ballRect.right) / 2 / window.innerWidth; const confettiY = (ballRect.top + ballRect.bottom) / 2 / window.innerHeight; myConfetti({ particleCount: 25, spread: 45, origin: { x: confettiX, y: confettiY }, scalar: 0.6 }); speak(this.score, 1.4, 1.5); } } }, updateScoreDisplay: function() { if(this.elements.scoreDisplay) this.elements.scoreDisplay.textContent = `Bounces: ${this.score}`; }, endGame: function() { const canCallPrimaryCallback = !!this.onCompleteCallback; cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; clearInterval(this.timerDisplayIntervalId); this.timerDisplayIntervalId = null; clearTimeout(this.gameTimerId); this.gameTimerId = null; if (this.container) this.container.removeEventListener('pointerdown', this.boundOnPointerDown); window.removeEventListener('pointermove', this.boundOnPointerMove); window.removeEventListener('pointerup', this.boundOnPointerUp); window.removeEventListener('pointercancel', this.boundOnPointerUp); if (this.hoopElement && this.hoopElement.parentNode) this.hoopElement.remove(); this.hoopElement = null; if (this.ballElement && this.ballElement.parentNode) this.ballElement.remove(); this.ballElement = null; this.isHoopActive = false; if (canCallPrimaryCallback) { speak(`Congratulations! You bounced the ball ${this.score} times!`); const callbackToExecute = this.onCompleteCallback; this.onCompleteCallback = null; if (callbackToExecute) callbackToExecute(this.score); } }, destroy: function() { this.endGame(); if (this.container) { this.container.innerHTML = ''; } this.container = null; this.elements = {}; this.onCompleteCallback = null; } };

    // --- MINI-GAME SYSTEM (UNCHANGED) ---
    function initMiniGameSystem() { availableMiniGames.push(BalloonPopGame, HoopBounceGame, CatchTheStarGame); toggleMiniGamesBtn.textContent = `Mini-Games: ${miniGamesEnabled ? 'On' : 'Off'}`; toggleMiniGamesBtn.classList.toggle('active-minigame-toggle', miniGamesEnabled); toggleMiniGamesBtn.addEventListener('click', () => { miniGamesEnabled = !miniGamesEnabled; localStorage.setItem('miniGamesEnabled', miniGamesEnabled.toString()); toggleMiniGamesBtn.textContent = `Mini-Games: ${miniGamesEnabled ? 'On' : 'Off'}`; toggleMiniGamesBtn.classList.toggle('active-minigame-toggle', miniGamesEnabled); }); }
    function triggerMiniGame() { if (availableMiniGames.length === 0) { console.warn("No mini-games available!"); resumeQuizAfterMiniGame(undefined); return; } isMiniGameActive = true; if (animatedBackgroundsEnabled && !PREFERS_REDUCED_MOTION && vantaEffect) { applyVantaEffect(null); } miniGameArea.classList.add('active'); miniGameArea.setAttribute('tabindex', '-1'); miniGameArea.focus(); const gameToPlay = availableMiniGames[currentMiniGameIdx]; currentMiniGameIdx = (currentMiniGameIdx + 1) % availableMiniGames.length; gameToPlay.start(miniGameArea, (miniGameScore) => { gameToPlay.destroy(); miniGameArea.classList.remove('active'); resumeQuizAfterMiniGame(miniGameScore); }); }
    function resumeQuizAfterMiniGame(miniGameScore) { setTimeout(() => { isMiniGameActive = false; updateBackgroundState(); quizCont.style.display = 'flex'; controlsBar.style.display = 'flex'; if (typeof gsap === 'undefined') { quizCont.style.opacity = '0'; controlsBar.style.opacity = '0'; } quizCont.classList.add('animate__animated', 'animate__fadeInCustom'); controlsBar.classList.add('animate__animated', 'animate__fadeInCustom'); let animationHandled = false; const animationEndHandler = () => { if (animationHandled) return; animationHandled = true; quizCont.classList.remove('animate__animated', 'animate__fadeInCustom'); controlsBar.classList.remove('animate__animated', 'animate__fadeInCustom'); if (typeof gsap === 'undefined') { quizCont.style.opacity = '1'; controlsBar.style.opacity = '1'; } if (miniGameScore !== undefined && miniGameScore !== null) { showFloatingMessage(`Mini-Game: ${miniGameScore} points!`, 'var(--brand-light)', 'var(--fg)'); } setTimeout(nextQ, 300); }; if (typeof gsap !== 'undefined') { gsap.fromTo([quizCont, controlsBar], {opacity: 0}, {opacity: 1, duration: 0.3, onComplete: animationEndHandler}); } else { quizCont.style.transition = 'opacity 0.3s ease-in-out'; controlsBar.style.transition = 'opacity 0.3s ease-in-out'; void quizCont.offsetWidth; quizCont.style.opacity = '1'; controlsBar.style.opacity = '1'; quizCont.addEventListener('transitionend', function onTransitionEnd(event) { if (event.propertyName === 'opacity') { animationEndHandler(); quizCont.removeEventListener('transitionend', onTransitionEnd); quizCont.style.transition = ''; controlsBar.style.transition = ''; } }, { once: false }); setTimeout(() => { if (!animationHandled) { animationEndHandler(); } }, 350); } }, 4000); }


    // --- UI & GAME LOGIC (UNCHANGED) ---
    function updateModeUI() { if (currentGameMode === 'listenAndPickWord') { listenPickWordArea.style.display = 'flex'; readPickSoundArea.style.display = 'none'; modeToggleBtn.textContent = 'Mode: Listen'; listenBtn.innerHTML = '🔊'; } else { listenPickWordArea.style.display = 'none'; readPickSoundArea.style.display = 'flex'; modeToggleBtn.textContent = 'Mode: Read'; listenBtn.innerHTML = '📖'; if(submitAnswerBtn) submitAnswerBtn.disabled = true; } }
    modeToggleBtn.addEventListener('click', () => { currentGameMode = (currentGameMode === 'listenAndPickWord') ? 'readAndPickSound' : 'listenAndPickWord'; localStorage.setItem('sightWordsGameMode', currentGameMode); updateModeUI(); clearTimeout(questionTimeoutId); resetQuestionState(); setTimeout(nextQ, 100); });
    function resetQuestionState() { questionAnsweredThisTurn = false; selectedSoundButton = null; soundChoiceBtns.forEach(btn => btn.classList.remove('sound-btn-selected', 'correct', 'incorrect')); wordChoiceBtns.forEach(btn => btn.classList.remove('correct', 'incorrect')); if (submitAnswerBtn) submitAnswerBtn.disabled = true; }
    function initCircularTimer() { const timerContainer = document.getElementById('circular-timer'); if (!timerContainer) return; circleTimerInstance = new ProgressBar.Circle(timerContainer, { strokeWidth: 10, easing: 'linear', color: 'var(--brand)', trailColor: 'rgba(224, 224, 224, 0.5)', trailWidth: 10, svgStyle: { width: '100%', height: '100%' }, text: { style: { color: 'var(--fg)', position: 'absolute', left: '50%', top: '50%', padding: 0, margin: 0, transform: { prefix: true, value: 'translate(-50%, -50%)' }, fontSize: '1.4em', fontWeight: '600', }, autoStyleContainer: false }, step: function(state, circle) { if (timeLimit > 0) { const timeLeft = Math.ceil(timeLimit * (1 - circle.value())); circle.setText(timeLeft > 0 ? timeLeft : '0'); if (timeLeft <= timeLimit * 0.3) circle.path.setAttribute('stroke', '#f44336'); else if (timeLeft <= timeLimit * 0.6) circle.path.setAttribute('stroke', '#ff9800'); else circle.path.setAttribute('stroke', 'var(--brand)'); } else { circle.setText('∞'); circle.path.setAttribute('stroke', 'var(--brand)'); } } }); }
    function startCountdown(cb) { clearTimeout(questionTimeoutId); onDoneCallback = cb; remainingMs = timeLimit * 1000; timerStartTs = Date.now(); if (circleTimerInstance) { circleTimerInstance.set(0); if (timeLimit > 0) circleTimerInstance.animate(1, { duration: remainingMs }); } if (timeLimit > 0) questionTimeoutId = setTimeout(cb, remainingMs); isTimerPaused = false; }
    function toggleTimer() { if (timeLimit <= 0) return; if (!isTimerPaused) { clearTimeout(questionTimeoutId); if (circleTimerInstance) circleTimerInstance.stop(); remainingMs -= (Date.now() - timerStartTs); } else { timerStartTs = Date.now(); if (circleTimerInstance && timeLimit > 0) circleTimerInstance.animate(1, { duration: remainingMs }); if (timeLimit > 0) questionTimeoutId = setTimeout(onDoneCallback, remainingMs); } isTimerPaused = !isTimerPaused; }
    const timerWrapper = document.getElementById('timer-wrapper');
    timerWrapper.addEventListener('click', e => { if (!isMiniGameActive) toggleTimer(); });
    timerDisp.addEventListener('click',()=>{ if (!isMiniGameActive) { timerSel.style.display = timerSel.style.display==='block'?'none':'block'; timerSel.value = timeLimit; } });
    timerSel.addEventListener('change',()=>{ timeLimit = +timerSel.value; localStorage.setItem('quizTimeLimit', timeLimit.toString()); timerDisp.textContent = timeLimit > 0 ? timeLimit+'s ⏱️' : 'Untimed ⏱️'; timerSel.style.display='none'; if (circleTimerInstance) { circleTimerInstance.set(0); circleTimerInstance.setText(timeLimit > 0 ? timeLimit : '∞'); } if(!questionAnsweredThisTurn) startCountdown(onDoneCallback); });
    function nextQ(){
        resetQuestionState();
        quizCont.classList.remove('animate__fadeInCustom', 'animate__zoomIn');
        void quizCont.offsetWidth;
        quizCont.classList.add('animate__zoomIn');
        [...wordChoiceBtns, ...soundChoiceBtns].forEach(btn => btn.style.display = '');
        if(submitAnswerBtn) submitAnswerBtn.style.display = '';
        wordToReadDisplay.style.display = '';

        if (words.length === 0) {
            console.error("No words available for the quiz! Check list/level/word selections.");
            wordToReadDisplay.textContent = "No Words!";
            showFloatingMessage("Please select word lists via the 'Word List' button!", "var(--brand-dark)");
            listenPickWordArea.style.display = 'none';
            readPickSoundArea.style.display = 'flex';
            soundChoiceBtns.forEach(btn => btn.style.display = 'none');
            if (submitAnswerBtn) submitAnswerBtn.style.display = 'none';
            wordChoiceBtns.forEach(btn => btn.style.display = 'none');
            clearTimeout(questionTimeoutId);
            if(circleTimerInstance) { circleTimerInstance.set(0); circleTimerInstance.stop(); }
            return;
        }
        currentCorrectWord = words[Math.floor(Math.random()*words.length)];
        let distractorWord;
        if (words.length > 1) {
            do { distractorWord = words[Math.floor(Math.random()*words.length)]; } while(distractorWord === currentCorrectWord);
        } else {
            const allPossibleWords = [];
            Object.values(WORD_BANK.dolch).forEach(arr => allPossibleWords.push(...arr));
            Object.values(WORD_BANK.fry).forEach(arr => allPossibleWords.push(...arr));
            allPossibleWords.push(...WORD_BANK.custom);
            const uniqueWords = [...new Set(allPossibleWords)];
            do { distractorWord = uniqueWords[Math.floor(Math.random()*uniqueWords.length)]; } while(distractorWord === currentCorrectWord && uniqueWords.length > 1);
            if (distractorWord === currentCorrectWord && uniqueWords.length <=1) distractorWord = "word"; // Absolute fallback
        }

        if (currentGameMode === 'listenAndPickWord') {
            const pair = Math.random() < 0.5 ? [currentCorrectWord, distractorWord] : [distractorWord, currentCorrectWord];
            wordChoiceBtns.forEach((b,i)=>{ b.textContent = pair[i]; b.disabled = false; b.className = 'choice-btn'; });
            speak(currentCorrectWord);
        } else {
            wordToReadDisplay.textContent = currentCorrectWord;
            const soundWords = Math.random() < 0.5 ? [currentCorrectWord, distractorWord] : [distractorWord, currentCorrectWord];
            soundChoiceBtns.forEach((btn, i) => { btn.dataset.wordToSpeak = soundWords[i]; btn.disabled = false; btn.className = 'choice-btn sound-btn'; });
            if(submitAnswerBtn) submitAnswerBtn.disabled = true;
        }
        if (timeLimit > 0) {
            startCountdown(()=>{
                if (questionAnsweredThisTurn || isMiniGameActive) return;
                questionAnsweredThisTurn = true;
                disableAllChoiceButtons();
                playBuzz();
                showFloatingMessage("Time's Up!", '#ffcdd2', '#333');
                currentStreak = 0;
                setTimeout(nextQ,1200);
            });
        } else {
             if (circleTimerInstance) { circleTimerInstance.set(0); circleTimerInstance.setText('∞'); }
        }
    }
    function disableAllChoiceButtons() { wordChoiceBtns.forEach(b => b.disabled = true); soundChoiceBtns.forEach(b => b.disabled = true); if (submitAnswerBtn) submitAnswerBtn.disabled = true; }
    function handleAnswer(isCorrect, targetButtonElement) {
        if (questionAnsweredThisTurn || isMiniGameActive) return;
        questionAnsweredThisTurn = true;
        clearTimeout(questionTimeoutId);
        if(circleTimerInstance && timeLimit > 0) circleTimerInstance.stop();
        disableAllChoiceButtons();

        if(isCorrect){
          playBell();
          const oldScoreTier = Math.floor(score / 10);
          scoreVal.textContent = ++score;
          const newScoreTier = Math.floor(score / 10);
          if (newScoreTier !== oldScoreTier || score === 10) {
            if (vantaBackgroundKeys.length > 0) { currentBackgroundKey = vantaBackgroundKeys[newScoreTier % vantaBackgroundKeys.length]; }
            else { currentBackgroundKey = null; }
            currentPastelBgIndex = newScoreTier % pastelBackgroundColors.length;
            updateBackgroundState();
          }
          targetButtonElement.classList.add('correct');
          myConfetti({ particleCount:80, spread:100, origin: { y: 0.6 } });
          showFloatingScore("+1 Awesome!", targetButtonElement);
          currentStreak++;
          if (streakThresholds[currentStreak]) { setTimeout(() => { playBell(); showFloatingMessage(streakThresholds[currentStreak], 'gold', '#333'); myConfetti({ particleCount: 150, spread: 180, startVelocity: 45, origin: { y: 0.5 }}); }, 300); }
        } else {
          playBuzz();
          targetButtonElement.classList.add('incorrect');
          if (currentGameMode === 'listenAndPickWord') { wordChoiceBtns.find(b => b.textContent === currentCorrectWord)?.classList.add('correct'); }
          else { soundChoiceBtns.find(b => b.dataset.wordToSpeak === currentCorrectWord)?.classList.add('correct'); }
          showFloatingScore("Oops!", targetButtonElement, true);
          currentStreak = 0;
        }
        targetButtonElement.classList.add('animate__animated', isCorrect ? 'animate__pulse' : 'animate__shakeX');
        const isMiniGameDue = isCorrect && miniGamesEnabled && score > 0 && score % 10 === 0;
        targetButtonElement.addEventListener('animationend', () => {
            targetButtonElement.classList.remove('animate__animated', 'animate__pulse', 'animate__shakeX');
            if (targetButtonElement.classList.contains('sound-btn')) { targetButtonElement.classList.remove('sound-btn-selected'); }
            soundChoiceBtns.forEach(btn => btn.classList.remove('sound-btn-selected'));
            if (isMiniGameDue) {
                quizCont.style.opacity = 1; controlsBar.style.opacity = 1;
                const fadeOutHandler = () => { quizCont.style.display = 'none'; controlsBar.style.display = 'none'; triggerMiniGame(); };
                if (typeof gsap !== 'undefined') {
                    gsap.to([quizCont, controlsBar], {opacity: 0, duration: 0.3, onComplete: fadeOutHandler});
                } else {
                    quizCont.classList.add('animate__animated', 'animate__fadeOutCustom'); controlsBar.classList.add('animate__animated', 'animate__fadeOutCustom');
                    quizCont.addEventListener('animationend', function tempFadeOutListener() {
                        quizCont.classList.remove('animate__animated', 'animate__fadeOutCustom'); controlsBar.classList.remove('animate__animated', 'animate__fadeOutCustom');
                        fadeOutHandler();
                        quizCont.removeEventListener('animationend', tempFadeOutListener);
                    }, { once: true });
                     setTimeout(() => { if (quizCont.classList.contains('animate__fadeOutCustom')) { fadeOutHandler(); } }, 400);
                }
            } else { setTimeout(nextQ, 100); }
        }, { once: true });
    }
    wordChoiceBtns.forEach(btn=>{ btn.addEventListener('click',()=>{ if (questionAnsweredThisTurn || currentGameMode !== 'listenAndPickWord' || isMiniGameActive) return; const isCorrect = btn.textContent === currentCorrectWord; handleAnswer(isCorrect, btn); }); });
    soundChoiceBtns.forEach(btn => { btn.addEventListener('click', () => { if (questionAnsweredThisTurn || currentGameMode !== 'readAndPickSound' || isMiniGameActive) return; const wordToSpeak = btn.dataset.wordToSpeak; speak(wordToSpeak); if (selectedSoundButton && selectedSoundButton !== btn) { selectedSoundButton.classList.remove('sound-btn-selected'); } btn.classList.add('sound-btn-selected'); selectedSoundButton = btn; if(submitAnswerBtn) submitAnswerBtn.disabled = false; }); });
    submitAnswerBtn.addEventListener('click', () => { if (questionAnsweredThisTurn || currentGameMode !== 'readAndPickSound' || !selectedSoundButton || isMiniGameActive) return; const wordSpokenBySelectedButton = selectedSoundButton.dataset.wordToSpeak; const isCorrect = wordSpokenBySelectedButton === currentCorrectWord; handleAnswer(isCorrect, selectedSoundButton); });
    listenBtn.onclick = ()=>{ if (currentCorrectWord && !isMiniGameActive) { if (currentGameMode === 'listenAndPickWord') { speak(currentCorrectWord); } else { speak(currentCorrectWord); } } };
    function showFloatingScore(message, targetButton, isError = false) { const floatEl = document.createElement('div'); floatEl.textContent = message; floatEl.classList.add('floating-effect'); floatEl.classList.add(isError ? 'floating-message' : 'floating-score'); if(isError) {floatEl.style.backgroundColor = 'var(--incorrect-bg)'; floatEl.style.color = '#333';} document.body.appendChild(floatEl); const btnRect = targetButton.getBoundingClientRect(); floatEl.style.left = `${btnRect.left + btnRect.width / 2 - floatEl.offsetWidth / 2}px`; floatEl.style.top = `${btnRect.top - floatEl.offsetHeight - 10}px`; gsap.to(floatEl, { y: -60, opacity: 0, duration: 1.8, ease: 'power1.out', onComplete: () => floatEl.remove() }); }
    function showFloatingMessage(text, bgColor = 'var(--brand)', textColor = 'white') { const msgEl = document.createElement('div'); msgEl.textContent = text; msgEl.classList.add('floating-effect', 'floating-message'); msgEl.style.backgroundColor = bgColor; msgEl.style.color = textColor; msgEl.style.left = '50%'; msgEl.style.top = '15%'; msgEl.style.transform = 'translateX(-50%)'; msgEl.style.padding = '0.8rem 1.5rem'; msgEl.style.fontSize = '1.5em'; document.body.appendChild(msgEl); gsap.fromTo(msgEl, { opacity: 0, y: -20, scale: 0.8 }, { opacity: 1, y: 0, scale: 1, duration: 0.5, ease: 'back.out(1.7)' } ); setTimeout(() => { gsap.to(msgEl, { opacity: 0, y: 20, scale: 0.8, duration: 0.5, ease: 'back.in(1.7)', onComplete: () => msgEl.remove() }); }, 2300); }

    // --- NEW: WORD LIST MANAGEMENT (Modal-based) ---
    function initWordListModal() {
        wordListOpenBtn.addEventListener('click', openWordListModal); // FIX: This listener now correctly opens the modal.
        wordListCloseBtn.addEventListener('click', closeWordListModal);
        wordListSaveBtn.addEventListener('click', saveAndCloseWordListModal);
    }
    
    function openWordListModal() {
        tempSelectionState = JSON.parse(JSON.stringify(selectionState));
        renderWordListModalContent();
        wordListModal.classList.add('visible');
    }

    function closeWordListModal() {
        wordListModal.classList.remove('visible');
    }

    function saveAndCloseWordListModal() {
        selectionState = JSON.parse(JSON.stringify(tempSelectionState));
        localStorage.setItem('wordSelectionState', JSON.stringify(selectionState));
        updateQuizWordsFromSelectionState();
        closeWordListModal();
    }

    function renderWordListModalContent() {
        wordListTreeContainer.innerHTML = '';
        Object.keys(bankDisplayNames).forEach(listKey => {
            const details = document.createElement('details');
            if (listKey === 'dolch') details.open = true;
            
            const summary = document.createElement('summary');
            const bankName = document.createElement('span');
            bankName.textContent = bankDisplayNames[listKey];
            const bankCount = document.createElement('span');
            bankCount.className = 'bank-count';
            summary.appendChild(bankName);
            summary.appendChild(bankCount);
            details.appendChild(summary);

            if (listKey === 'custom') {
                const levelItem = createLevelItem(listKey, 'all', `All Custom Words`);
                details.appendChild(levelItem);
            } else {
                const levelKeys = Object.keys(WORD_BANK[listKey]);
                if (listKey === 'fry') { levelKeys.sort((a, b) => parseInt(a.split('-')[0]) - parseInt(b.split('-')[0])); }
                levelKeys.forEach(levelKey => {
                    const levelName = listKey === 'dolch' ? `Level ${levelKey}` : `Fry ${levelKey}`;
                    details.appendChild(createLevelItem(listKey, levelKey, levelName));
                });
            }
            wordListTreeContainer.appendChild(details);
        });
        updateWordListModalUI();
    }
    
    function createLevelItem(listKey, levelKey, levelName) {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'level-item';
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = tempSelectionState[listKey]?.[levelKey] || false;
        checkbox.addEventListener('change', () => { tempSelectionState[listKey][levelKey] = checkbox.checked; updateWordListModalUI(); });
        const nameSpan = document.createElement('span');
        nameSpan.textContent = levelName;
        const countSpan = document.createElement('span');
        countSpan.className = 'level-word-count';
        label.appendChild(checkbox);
        label.appendChild(nameSpan);
        label.appendChild(countSpan);
        const editBtn = document.createElement('button');
        editBtn.className = 'edit-level-btn';
        editBtn.innerHTML = '✎';
        editBtn.title = `Edit words for ${levelName}`;
        editBtn.addEventListener('click', () => { openWordCustomizationModal(listKey, listKey === 'custom' ? '__ALL__' : levelKey); });
        itemDiv.appendChild(label);
        itemDiv.appendChild(editBtn);
        return itemDiv;
    }

    function updateWordListModalUI() {
        let totalSelectedWords = 0;
        let summaryParts = [];
        wordListTreeContainer.querySelectorAll('details').forEach(details => {
            let bankSelectedWords = 0;
            const listKey = Object.keys(bankDisplayNames).find(key => bankDisplayNames[key] === details.querySelector('summary span:first-child').textContent);
            details.querySelectorAll('.level-item').forEach(item => {
                const checkbox = item.querySelector('input[type="checkbox"]');
                const levelNameText = checkbox.nextElementSibling.textContent;
                const levelKey = levelNameText.includes('Custom') ? 'all' : (listKey === 'dolch' ? levelNameText.split(' ')[1] : levelNameText.split(' ')[1]);
                const levelWordCount = getWordCountForLevel(listKey, levelKey);
                item.querySelector('.level-word-count').textContent = `(${levelWordCount})`;
                if (checkbox.checked) {
                    bankSelectedWords += levelWordCount;
                    if(listKey !== 'custom') summaryParts.push(`${listKey === 'dolch' ? 'Dolch' : 'Fry'} ${levelKey}`);
                    else if(!summaryParts.includes('Custom')) summaryParts.push('Custom');
                }
            });
            details.querySelector('.bank-count').textContent = `(${bankSelectedWords} words)`;
            totalSelectedWords += bankSelectedWords;
        });
        wordListTotalCount.textContent = totalSelectedWords;
        wordListSummaryText.textContent = `You've selected: ${summaryParts.length > 0 ? summaryParts.join(' • ') : 'None'}`;
    }

    function getWordCountForLevel(listKey, levelKey) {
        let wordsForLevel = (listKey === 'custom') ? WORD_BANK.custom : (WORD_BANK[listKey]?.[levelKey] || []);
        const userSelectionsKey = `${listKey}_${levelKey === 'all' ? '__ALL__' : levelKey}_userSelections`;
        const storedUserSelections = localStorage.getItem(userSelectionsKey);
        if (storedUserSelections) {
            try {
                const userSelectedSubset = JSON.parse(storedUserSelections);
                return wordsForLevel.filter(word => userSelectedSubset.includes(word)).length;
            } catch (e) { /* fall through */ }
        }
        return wordsForLevel.length;
    }

    function updateQuizWordsFromSelectionState() {
        const currentWordSet = new Set();
        Object.keys(selectionState).forEach(listKey => {
            Object.keys(selectionState[listKey]).forEach(levelKey => {
                if (selectionState[listKey][levelKey]) {
                    let baseWordsForLevel = (listKey === 'custom') ? [...WORD_BANK.custom] : [...(WORD_BANK[listKey]?.[levelKey] || [])];
                    const userSelectionsKey = `${listKey}_${levelKey === 'all' ? '__ALL__' : levelKey}_userSelections`;
                    const storedUserSelections = localStorage.getItem(userSelectionsKey);
                    if (storedUserSelections) {
                        try {
                            const userSelectedSubset = JSON.parse(storedUserSelections);
                            if (Array.isArray(userSelectedSubset)) { baseWordsForLevel = baseWordsForLevel.filter(word => userSelectedSubset.includes(word)); }
                        } catch (e) { console.error(`Error parsing user selections for ${userSelectionsKey}:`, e); }
                    }
                    baseWordsForLevel.forEach(word => currentWordSet.add(word));
                }
            });
        });
        words = Array.from(currentWordSet);
        wordCountBadge.textContent = words.length;
        if (words.length === 0) { showFloatingMessage("No words selected. Please choose some lists.", "var(--brand-dark)"); }
        clearTimeout(questionTimeoutId); resetQuestionState(); setTimeout(nextQ, 100);
    }

    // --- WORD CUSTOMIZATION MODAL (Inner modal, adapted to work with new system) ---
    function openWordCustomizationModal(listKey, levelKeyContext) {
        currentModalListContext = listKey;
        currentModalLevelContext = levelKeyContext;
        modalSearchInput.value = '';
        modalAddCustomWordBtn.classList.add('hidden');
        if (listKey === 'custom') {
            modalTitle.textContent = `Customize: Custom Word List`;
            modalLevelSelector.style.display = 'none'; modalLevelSelectorLabel.style.display = 'none';
        } else {
            modalTitle.textContent = `Customize: ${listKey.charAt(0).toUpperCase() + listKey.slice(1)} - ${(listKey === 'dolch' ? "Level " : "")}${levelKeyContext}`;
            modalLevelSelector.style.display = 'inline-block'; modalLevelSelectorLabel.style.display = 'inline-block';
            modalLevelSelector.innerHTML = '';
            const levelsForThisList = Object.keys(WORD_BANK[listKey]);
            if (listKey === 'fry') { levelsForThisList.sort((a, b) => parseInt(a.split('-')[0]) - parseInt(b.split('-')[0])); }
            else { levelsForThisList.sort(); }
            levelsForThisList.forEach(lvl => { const option = document.createElement('option'); option.value = lvl; option.textContent = (listKey === 'dolch' ? `Level ${lvl}` : `${lvl}`); modalLevelSelector.appendChild(option); });
            modalLevelSelector.value = levelKeyContext;
        }
        populateModalWordList();
        wordCustomizationModal.classList.add('visible');
    }
    function closeWordCustomizationModal() { wordCustomizationModal.classList.remove('visible'); }
    function populateModalWordList() {
        modalWordList.innerHTML = ''; const searchTerm = modalSearchInput.value.toLowerCase().trim();
        let wordsToDisplay = new Map(); let foundResultsInCurrentList = false;
        if (currentModalListContext === 'custom') {
            (WORD_BANK.custom || []).forEach(word => {
                if (searchTerm === '' || word.toLowerCase().includes(searchTerm)) { wordsToDisplay.set(word, { isCustomGlobal: true, isSelectedForBaseLevel: true }); foundResultsInCurrentList = true; }
            });
        } else {
            const baseWordsForLevel = WORD_BANK[currentModalListContext]?.[currentModalLevelContext] || [];
            const userSelectionsKey = `${currentModalListContext}_${currentModalLevelContext}_userSelections`;
            let userSelectedSubsetForBaseLevel = null;
            const storedUserSelections = localStorage.getItem(userSelectionsKey);
            if (storedUserSelections) { try { userSelectedSubsetForBaseLevel = JSON.parse(storedUserSelections); } catch (e) { /* ignore */ } }
            baseWordsForLevel.forEach(word => {
                if (searchTerm === '' || word.toLowerCase().includes(searchTerm)) {
                    let isSelected = !Array.isArray(userSelectedSubsetForBaseLevel) || userSelectedSubsetForBaseLevel.includes(word);
                    wordsToDisplay.set(word, { isCustomGlobal: WORD_BANK.custom.includes(word), isSelectedForBaseLevel: isSelected }); foundResultsInCurrentList = true;
                }
            });
        }
        const sortedWords = Array.from(wordsToDisplay.keys()).sort((a, b) => a.localeCompare(b));
        sortedWords.forEach(word => {
            const wordData = wordsToDisplay.get(word);
            const itemDiv = document.createElement('div'); itemDiv.classList.add('modal-word-item');
            const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.id = `modal-word-${word.replace(/\s+/g, '-')}`;
            checkbox.value = word; checkbox.checked = wordData.isSelectedForBaseLevel;
            if (wordData.isCustomGlobal) { itemDiv.classList.add('custom-word'); }
            const label = document.createElement('label'); label.htmlFor = checkbox.id; label.textContent = word;
            itemDiv.appendChild(checkbox); itemDiv.appendChild(label);
            modalWordList.appendChild(itemDiv);
        });
        if (searchTerm !== '' && !foundResultsInCurrentList && !WORD_BANK.custom.includes(searchTerm)) { modalAddCustomWordTerm.textContent = searchTerm; modalAddCustomWordBtn.classList.remove('hidden'); }
        else { modalAddCustomWordBtn.classList.add('hidden'); }
    }
    function handleAddCustomWordFromModal() {
        const newWord = modalSearchInput.value.trim(); if (newWord === '') return;
        if (!WORD_BANK.custom.includes(newWord)) {
            WORD_BANK.custom.push(newWord); WORD_BANK.custom.sort();
            localStorage.setItem('customBank', JSON.stringify(WORD_BANK.custom));
            showFloatingMessage(`"${newWord}" added to Custom list.`, "var(--correct-bg)");
            populateModalWordList();
            if (wordListModal.classList.contains('visible')) updateWordListModalUI();
        } else { showFloatingMessage(`"${newWord}" is already in Custom list.`, "var(--brand-light)", "var(--fg)"); }
        modalSearchInput.value = ''; modalAddCustomWordBtn.classList.add('hidden');
    }
    function saveWordCustomizationModal() {
      if (currentModalListContext === 'custom') {
        // 1. Grab whatever the user has checked in the modal
        const selectedWords = Array.from(
          modalWordList.querySelectorAll('input[type="checkbox"]:checked')
        ).map(cb => cb.value);
    
        // 2. Merge those into the existing custom bank (no deletions)
        WORD_BANK.custom = Array.from(
          new Set([...WORD_BANK.custom, ...selectedWords])
        ).sort();
    
        // 3. Persist
        localStorage.setItem('customBank', JSON.stringify(WORD_BANK.custom));
    
      } else {
        // unchanged: per-level customizations for Dolch/Fry lists
        const selectedWordsForThisBaseLevel = [];
        modalWordList
          .querySelectorAll('input[type="checkbox"]')
          .forEach(cb => {
            if (cb.checked) selectedWordsForThisBaseLevel.push(cb.value);
          });
    
        const userSelectionsKey = `${currentModalListContext}_${currentModalLevelContext}_userSelections`;
        const originalBaseWordsForLevel = WORD_BANK[currentModalListContext]?.[currentModalLevelContext] || [];
    
        if (selectedWordsForThisBaseLevel.length === originalBaseWordsForLevel.length) {
          localStorage.removeItem(userSelectionsKey);
        } else {
          localStorage.setItem(
            userSelectionsKey,
            JSON.stringify([...new Set(selectedWordsForThisBaseLevel)].sort())
          );
        }
      }
    
      // close modal, refresh UI, and show a confirmation
      closeWordCustomizationModal();
      if (wordListModal.classList.contains('visible')) {
        updateWordListModalUI();
      }
      showFloatingMessage("Word customizations saved!", "var(--correct-bg)");
    }
    function toggleAllModalWords(select) { modalWordList.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = select; }); }

  </script>
</body>
</html>
