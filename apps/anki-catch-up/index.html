<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>APKG → Fun Viewer (Local)</title>
<style>
  html,body { margin:0; height:100%; background:#0b0f14; color:#eee; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  header { padding:16px; border-bottom:1px solid #222; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  input[type=file] { background:#111; color:#eee; padding:8px; border:1px solid #333; border-radius:6px; }
  #log { opacity:.85; font-size:12px }
  #error {
    display:none; width:100%;
    background:#241317; border:1px solid #5b1d28; color:#ffd7de;
    padding:12px; border-radius:8px; line-height:1.35;
  }
  #error h3 { margin:0 0 6px 0; font-size:14px }
  #error pre { white-space:pre-wrap; margin:6px 0 0 0; font-size:12px; opacity:.9 }
  main { padding:16px; display:grid; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); gap:16px; }
  .card {
    background:#121826; border:1px solid #243042; border-radius:12px; padding:16px; min-height:160px;
    box-shadow:0 10px 25px rgba(0,0,0,.25); display:flex; flex-direction:column; justify-content:space-between;
  }
  .front, .back { font-size:16px; line-height:1.4; }
  .back  { display:none; }
  .meta { font-size:12px; opacity:.65; margin-top:10px }
  button.flip {
    margin-top:12px; border:0; padding:10px 12px; border-radius:8px; background:#1e90ff;
    color:white; cursor:pointer; font-weight:600;
  }
  button.flip:active { transform:translateY(1px) }
  a.media { color:#7dd3fc; text-decoration:underline; }
</style>
</head>
<body>
<header>
  <input id="file" type="file" accept=".apkg,.colpkg" />
  <span id="log"></span>
  <div id="error" role="alert" aria-live="polite"></div>
</header>
<main id="grid"></main>

<!-- fflate (zip) -->
<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>

<!-- Bubble up ANY stray errors to the on-page panel -->
<script>
  window.addEventListener('error', (e) => showError('Unexpected error', e.error?.stack || String(e.message || e)));
  window.addEventListener('unhandledrejection', (e) => showError('Unhandled promise rejection', e.reason?.stack || String(e.reason || e)));
</script>

<!-- sql.js (SQLite in WebAssembly) -->
<script src="https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/sql-wasm.js"></script>

<script>
/* ---------- UI helpers ---------- */
const grid = document.getElementById('grid');
const log  = document.getElementById('log');
const errEl= document.getElementById('error');

function setLog(msg){ log.textContent = msg; }
function clearError(){ errEl.style.display='none'; errEl.innerHTML=''; }
function showError(title, details='', tips=''){
  errEl.style.display='block';
  errEl.innerHTML =
    `<h3>⚠️ ${escapeHtml(title)}</h3>` +
    (tips ? `<div>${escapeHtml(tips)}</div>` : '') +
    (details ? `<pre>${escapeHtml(details)}</pre>` : '');
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ---------- Engine load ---------- */
let SQL;
(async () => {
  try {
    SQL = await initSqlJs({
      locateFile: f => `https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/${f}`
    });
  } catch (e) {
    showError('Failed to load SQLite engine (sql.js).', e?.stack || String(e),
      'Check your connection and refresh the page.');
  }
})();

/* ---------- Resilient media.json parser ---------- */
function tryParseMedia(bytes) {
  const td = new TextDecoder('utf-8', { fatal: false });
  let txt = td.decode(bytes);

  // Strip BOM
  if (txt.charCodeAt(0) === 0xFEFF) txt = txt.slice(1);

  // Keep only the largest {...} span (some decks have stray bytes)
  const firstBrace = txt.indexOf('{');
  const lastBrace  = txt.lastIndexOf('}');
  if (firstBrace === -1 || lastBrace === -1 || lastBrace <= firstBrace) {
    throw new Error('media file contains no JSON object');
  }
  txt = txt.slice(firstBrace, lastBrace + 1);

  // Remove trailing commas before } or ]
  txt = txt.replace(/,\s*([}\]])/g, '$1');

  // Remove illegal control chars (except tab/newline)
  txt = txt.replace(/[\u0000-\u0008\u000B-\u000C\u000E-\u001F]/g, '');

  // Ensure numeric keys are quoted
  txt = txt.replace(/([{,]\s*)(\d+)(\s*:)/g, '$1"$2"$3');

  return JSON.parse(txt);
}

/* ---------- Unzip watchdog so we never "hang" ---------- */
function unzipWithWatchdog(buf, timeoutMs=20000){
  return new Promise((resolve, reject) => {
    let done = false;
    const to = setTimeout(() => {
      if (done) return;
      done = true;
      reject(new Error('Unzip timed out. The file may be extremely large or not a valid .apkg/.colpkg (ZIP).'));
    }, timeoutMs);

    try {
      fflate.unzip(buf, { consume: true }, (err, obj) => {
        if (done) return;
        clearTimeout(to);
        if (err) { done = true; reject(err); }
        else { done = true; resolve(obj); }
      });
    } catch (e) {
      clearTimeout(to);
      reject(e);
    }
  });
}

/* ---------- Minimal templating & sanitization ---------- */
function renderCloze(text){
  return text.replace(/\{\{c(\d+)::(.*?)(::(.*?))?\}\}/g, (m,idx,inner,_m2,hint) => {
    return `<span class="cloze" title="${hint||''}">[ tap to reveal ]<span style="display:none"> ${inner} </span></span>`;
  });
}
function applyTemplate(tpl, fields, fieldNames){
  return tpl.replace(/\{\{([^}]+)\}\}/g, (m, token) => {
    const name = token.split(':')[0].trim();     // ignore filters for now
    const idx = fieldNames.indexOf(name);
    return idx >= 0 ? (fields[idx] ?? '') : '';
  });
}
function sanitize(html){ return html.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi,''); }

/* ---------- Media resolution helpers ---------- */
function mediaURLByIndex(idx, mediaMap, files){
  const name = mediaMap[idx];
  const f = files[idx] || files[name];
  if (!f) return null;
  return URL.createObjectURL(new Blob([f], {type:'application/octet-stream'}));
}
function mediaURLByName(name, reverseMap, files){
  // Direct file present?
  if (files[name]) {
    return URL.createObjectURL(new Blob([files[name]], {type:'application/octet-stream'}));
  }
  // If we have reverse map name->index
  const idx = reverseMap[name];
  if (idx !== undefined && files[idx]) {
    return URL.createObjectURL(new Blob([files[idx]], {type:'application/octet-stream'}));
  }
  return null;
}

/* ---------- Replace media in HTML (img, audio, [sound:]) ---------- */
function buildMediaReplacer(mediaMap, files, diagnostics){
  // Build reverse name→index map for robustness
  const reverseMap = {};
  for (const [k,v] of Object.entries(mediaMap)) reverseMap[v] = k;

  const imgIdxRE   = /<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
  const audioIdxRE = /<audio[^>]+src=["']([^"']+)["'][^>]*>/gi;
  const soundTagRE = /\[sound:([^\]]+)\]/gi;

  return function replaceMedia(html) {
    // IMG
    html = html.replace(imgIdxRE, (m, src) => {
      diagnostics.total++;
      let url = null;
      if (/^\d+$/.test(src)) url = mediaURLByIndex(src, mediaMap, files);
      if (!url) url = mediaURLByName(src, reverseMap, files);
      if (!url) return m;
      diagnostics.resolved++;
      return m.replace(src, url);
    });

    // AUDIO tag with src
    html = html.replace(audioIdxRE, (m, src) => {
      diagnostics.total++;
      let url = null;
      if (/^\d+$/.test(src)) url = mediaURLByIndex(src, mediaMap, files);
      if (!url) url = mediaURLByName(src, reverseMap, files);
      if (!url) return m;
      diagnostics.resolved++;
      return m.replace(src, url);
    });

    // [sound:foo.mp3] → <audio controls>
    html = html.replace(soundTagRE, (m, name) => {
      diagnostics.total++;
      let url = mediaURLByName(name, reverseMap, files);
      if (!url) {
        // Some decks reference numeric names in [sound:42]
        if (/^\d+$/.test(name)) url = mediaURLByIndex(name, mediaMap, files);
      }
      if (!url) return m; // keep original if we can't map
      diagnostics.resolved++;
      return `<audio controls preload="metadata" src="${url}"></audio>`;
    });

    return html;
  };
}

/* ---------- File handler ---------- */
document.getElementById('file').addEventListener('change', async (e) => {
  clearError();
  grid.innerHTML = '';
  setLog('');
  const file = e.target.files?.[0];
  if (!file) return;

  if (file.size > 250 * 1024 * 1024) {
    showError('Large file warning',
      `This deck is ${(file.size/1024/1024).toFixed(1)} MB.`,
      'Very large decks can be slow or run out of memory in mobile browsers. If it stalls, try on desktop or split the deck.');
  }

  try {
    setLog('Reading file…');
    const buf = new Uint8Array(await file.arrayBuffer());

    // ZIP magic check
    if (!(buf[0]===0x50 && buf[1]===0x4b)) {
      showError('This doesn’t look like a .apkg/.colpkg (ZIP).',
        'Expected ZIP header (PK).',
        'Make sure you selected a .apkg/.colpkg exported from Anki.');
      return;
    }

    setLog('Unzipping…');
    let entries;
    try {
      entries = await unzipWithWatchdog(buf, 20000);
    } catch (unzErr) {
      showError('Failed while unzipping the file.',
        unzErr?.stack || String(unzErr),
        'The deck might be corrupted or not an .apkg/.colpkg. Try re-exporting without encryption.');
      return;
    }

    // Locate DB
    const dbEntry = entries['collection.anki21'] || entries['collection.anki2'];
    if (!dbEntry) {
      const present = Object.keys(entries).slice(0,20).join(', ') + (Object.keys(entries).length>20 ? ', …' : '');
      showError('Could not find collection.anki21/.anki2 in this package.',
        `Entries seen: ${present}`,
        'Export the deck as a modern .apkg. If it’s an older format, re-export from Anki to regenerate the database.');
      return;
    }

    // Parse media mapping
    let mediaMap = {};
    if (entries['media']) {
      try {
        mediaMap = tryParseMedia(entries['media']);
      } catch (mErr) {
        showError('media file is not valid JSON (salvage failed).',
          mErr?.stack || String(mErr),
          'We’ll continue without media mapping; images/sounds referenced by filename may not load. Try re-exporting the deck.');
        mediaMap = {};
      }
    } // else: no media map is fine

    if (!SQL) {
      showError('SQLite engine not ready.',
        'sql.js failed to load earlier.',
        'Reload the page and try again (network hiccup).');
      return;
    }

    setLog('Opening SQLite…');
    let db;
    try {
      db = new SQL.Database(dbEntry);
    } catch (dbOpenErr) {
      showError('Failed to open the Anki SQLite database.',
        dbOpenErr?.stack || String(dbOpenErr),
        'The deck may be corrupted or from an unsupported Anki version. Try re-exporting.');
      return;
    }

    // Read col (models, decks)
    let models = {}, decks = {}, notes = [], cards = [];
    try {
      const col = db.exec(`SELECT * FROM col LIMIT 1`)[0];
      if (!col) throw new Error('No rows in col table');
      const row = Object.fromEntries(col.columns.map((c,i)=>[c,col.values[0][i]]));
      try { models = JSON.parse(row.models); } catch { throw new Error('Could not parse col.models JSON'); }
      try { decks  = JSON.parse(row.decks);  } catch { throw new Error('Could not parse col.decks JSON'); }
    } catch (colErr) {
      showError('Could not read core collection metadata (col table).',
        colErr?.stack || String(colErr),
        'The deck schema may be incompatible. Try re-exporting the deck.');
      return;
    }

    // Query notes/cards
    try {
      const nRes = db.exec(`SELECT id, guid, mid, flds, sfld, tags FROM notes`);
      if (nRes[0]) {
        const { columns, values } = nRes[0];
        for (const row of values) notes.push(Object.fromEntries(columns.map((c,i)=>[c,row[i]])));
      } else {
        throw new Error('Notes table returned no columns/rows');
      }
    } catch (nErr) {
      showError('Failed querying notes.',
        nErr?.stack || String(nErr),
        'The deck may be from a newer schema. Try re-exporting.');
      return;
    }

    try {
      const cRes = db.exec(`SELECT id, nid, did, ord FROM cards`);
      if (cRes[0]) {
        const { columns, values } = cRes[0];
        for (const row of values) cards.push(Object.fromEntries(columns.map((c,i)=>[c,row[i]])));
      } else {
        throw new Error('Cards table returned no columns/rows');
      }
    } catch (cErr) {
      showError('Failed querying cards.',
        cErr?.stack || String(cErr),
        'The deck may be from a newer schema. Try re-exporting.');
      return;
    }

    // Build file table & diagnostics
    const fileTable = {};
    for (const [name, bytes] of Object.entries(entries)) fileTable[name] = bytes;

    const mediaLookups = { total: 0, resolved: 0 };
    const replaceMedia = buildMediaReplacer(mediaMap, fileTable, mediaLookups);

    // Render a small demo set
    setLog('Rendering preview…');
    grid.innerHTML = '';

    let shown = 0;
    for (const card of cards) {
      if (shown >= 24) break;

      const note = notes.find(n => n.id === card.nid);
      if (!note) continue;

      const model = models[String(note.mid)];
      if (!model) continue;

      const fieldNames = (model?.flds || []).map(f => f.name);
      const fields = (note.flds || '').split('\x1f');
      const tmpl = model?.tmpls?.[card.ord];
      if (!tmpl) continue;

      let front = applyTemplate(tmpl.qfmt || '', fields, fieldNames);
      let back  = applyTemplate(tmpl.afmt || '', fields, fieldNames);

      // Cloze hinting if detected
      if ((model?.type === 1) || /{{c\d+::/i.test(fields.join(' '))) {
        front = renderCloze(front);
        back  = renderCloze(back);
      }

      front = replaceMedia(sanitize(front));
      back  = replaceMedia(sanitize(back));

      const el = document.createElement('div');
      el.className = 'card';
      el.innerHTML = `
        <div class="front">${front || '(empty front)'}</div>
        <div class="back">${back || '(empty back)'}</div>
        <div class="meta">Deck: ${escapeHtml(decks[card.did]?.name || String(card.did))} • NoteType: ${escapeHtml(model.name||'')} • ord: ${card.ord}</div>
        <button class="flip">Flip</button>
      `;
      el.querySelector('.flip').addEventListener('click', () => {
        const f = el.querySelector('.front'), b = el.querySelector('.back');
        if (b.style.display === 'block') { b.style.display='none'; f.style.display='block'; }
        else { f.style.display='none'; b.style.display='block'; }
      });
      el.addEventListener('click', (ev) => {
        const c = ev.target.closest('.cloze');
        if (c) {
          const inner = c.querySelector('span');
          if (inner) {
            const hidden = inner.style.display === 'none';
            inner.style.display = hidden ? 'inline' : 'none';
            c.firstChild.textContent = hidden ? '' : '[ tap to reveal ]';
          }
        }
      });

      grid.appendChild(el);
      shown++;
    }

    setLog(
      `Loaded ${cards.length} cards from ${Object.keys(decks).length} deck(s). ` +
      `Showing ${Math.min(24, cards.length)} as a demo.` +
      (mediaLookups.total ? ` Media: resolved ${mediaLookups.resolved}/${mediaLookups.total}.` : '')
    );
  } catch (e2) {
    showError('Something went wrong while processing the file.', e2?.stack || String(e2));
  }
});
</script>
</body>
</html>