
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Radionuclides">
  <link rel="apple-touch-icon" href="apple-touch-icon.PNG">
  <title>Radionuclide Slideshow</title>
  <style>
    :root{
      --bg:#0b0b0f;
      --fg:#ababab;
      --muted:#9aa0a6;
      --accent:#00ff9c;
      --surface:#121218;
      --btn:#1e1e27;
      --good:#2bd576;
      --bad:#ff6b6b;
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --step-fade: 450ms;
    }
    *{box-sizing:border-box}
    html, body { height: 100%; overflow: hidden; }
    body{ margin:0; background:var(--bg); color:var(--fg);
      font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    
     /* Backdrop */
    .backdrop{ position:fixed; inset:0; z-index:-1; background:var(--bg); }
    .backdrop::before{ content:""; position:absolute; inset:0; background-size:cover; background-position:center; filter: blur(40px) brightness(.35) saturate(.9); transform:scale(1.1); will-change:transform; }
    .backdrop::after{ content:""; position:absolute; inset:0; background: radial-gradient(55% 45% at 60% 55%, color-mix(in srgb, var(--accent) 18%, transparent), transparent 70%); pointer-events:none; }

    /* Frame */
  
/* --- FIX STARTS HERE --- */

/* 1. Modify the .frame rule */
.frame {
  position: relative;
  width: min(100vw, calc(100svh * (16/9)));
  height: min(100svh, calc(100vw * (9/16)));
  width: min(100vw, calc(100vh * (16/9)));
  height: min(100vh, calc(100vw * (9/16)));
  aspect-ratio: 16/9;
  border-radius: var(--radius);
  overflow: hidden;
  box-shadow: var(--shadow);
  /* --- CHANGE HERE --- */
  display: grid;
  grid-template-columns: 34% 66%; /* Restore the two-column layout */
}

/* 2. Modify the .side rule */
.side {
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  padding: 1.2rem;
  gap: 1rem;
  background: linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,0) 42%); /* Revert to a vertical gradient if you wish */

  /* --- CHANGE HERE --- */
  grid-column: 1; /* Place in the first column */
  /* Remove width, z-index, position, and other overlay properties */
}

.art {
  /* --- CHANGE HERE --- */
  grid-column: 2; /* Place in the second column */

  position: relative;
  width: 100%; height: 100%;
  display: flex; align-items: center; justify-content: center;
  min-width: 0; min-height: 0;
  /* Remove z-index */
}
/* Add this new rule to center the entire frame */
.stage {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100svh; /* Use small viewport height for mobile compatibility */
  display: grid;
  place-items: center;
  z-index: 0;
}


.art img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}



    /* Left column except for .side which is above*/
    .clockWrap{ display:flex; flex-direction:column; align-items:flex-start; gap:.2rem; }
    .clock{ font-variant-numeric:tabular-nums; font-weight:800; line-height:1; letter-spacing:.5px; color: color-mix(in srgb, var(--accent) 85%, white 15%); text-shadow:0 0 24px color-mix(in srgb, var(--accent) 40%, transparent); }
    .clock .ampm{ font-weight:600; color: color-mix(in srgb, var(--accent) 75%, white 10%); opacity:.9; margin-left:.25em; }

    .meta{ display:flex; flex-direction:column; gap:.35rem; max-width: 95%; }
    /* --- STYLES SWAPPED AS REQUESTED --- */
    .kicker { /* This is now for the Radionuclide Name */
      font-size: clamp(1.2rem, 3.6vw, 2.2rem);
      color: color-mix(in srgb, var(--accent) 70%, white 30%);
      font-weight: 800;
      letter-spacing: .2px;
      line-height: 1.1;
      opacity: 0;
      transform: translateY(8px);
    }
    
    .title { /* This is now for the Fact Category */
      text-transform: uppercase;
      letter-spacing: .18em;
      font-weight: 700;
      font-size: 1rem;
      opacity: 0;
      transform: translateY(8px);
    }    
    .sub{ color:var(--muted); font-size: clamp(.95rem, 2.2vw, 1.05rem); opacity:0; transform: translateY(8px); }

    .reveal{ animation: fadeUp var(--step-fade) ease forwards; }
    @keyframes fadeUp { to {opacity:1; transform: translateY(0)} }

    /* Right column: image */
   .tint{ position:absolute; inset:-12%; background:radial-gradient(60% 50% at 50% 65%, color-mix(in srgb, var(--accent) 22%, transparent), transparent 70%); filter: blur(60px); opacity:.6; pointer-events:none }

    /* Click/tap hit overlay */
    .hits{ position:absolute; inset:0; display:grid; grid-template-columns:1fr 1fr; z-index:10; } /* ensure on top of chips */
    .hit{ cursor:pointer; }

    /* Footer & overlays */
    .footer {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: .6rem;
      padding: .8rem 1rem;
      /* --- ADD THIS LINE --- */
      z-index: 11; /* Raise footer above the hits overlay (z-index: 10) */
    }
    .leftGroup{ display:flex; gap:.6rem; align-items:center; }
    .btn{ background:var(--btn); color:var(--fg); border:1px solid rgba(255,255,255,.08); padding:.8rem 1.1rem; border-radius:14px; cursor:pointer; user-select:none; transition: transform .06s ease, background .2s ease, border-color .2s ease, box-shadow .2s ease; overflow:hidden; }
    .btn:hover{ transform: translateY(-1px); }
    .btn.good{ border-color: color-mix(in srgb, var(--good) 55%, transparent); box-shadow: 0 0 0 1px color-mix(in srgb, var(--good) 30%, transparent) inset; }
    .btn.bad{ border-color: color-mix(in srgb, var(--bad) 55%, transparent); box-shadow: 0 0 0 1px color-mix(in srgb, var(--bad) 30%, transparent) inset; }
    .btn.selected{ box-shadow: 0 0 0 2px currentColor inset; }

    .mark{ position:absolute; right:1rem; bottom:1rem; font-size:2rem; opacity:.85; z-index:6; pointer-events:none; text-shadow:0 0 20px rgba(0,0,0,.45); }
    .chip {
      position: absolute;
      top: .6rem;
      right: .6rem;
      background: rgba(255, 255, 255, .06);
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: 999px;
      padding: .25rem .6rem;
      color: var(--muted);
      font-size: .9rem;
      /* --- CHANGE THIS LINE --- */
      z-index: 11; /* Raise chip above the hits overlay */
      pointer-events: none;
    }
    /* Modal */
    dialog{ border:none; border-radius:16px; background:var(--surface); color:var(--fg); width:min(900px, 95vw); box-shadow: var(--shadow); }
    dialog::backdrop{ background:rgba(0,0,0,.6); backdrop-filter: blur(3px); }
    .modal{ padding:1rem; display:grid; gap:1rem; }
    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:.8rem; }
    .grid3{ display:grid; grid-template-columns:repeat(3, 1fr); gap:.8rem; }
    .grid-auto-fit{ display:grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap:.8rem; }
    .field label{ display:block; font-size:.9rem; color:var(--muted); margin-bottom:.25rem; }
    .field input[type="number"], .field input[type="text"], .field select{ width:100%; background:#0f0f15; border:1px solid rgba(255,255,255,.1); color:var(--fg); padding:.55rem .6rem; border-radius:10px; }
    .list{ max-height:45vh; overflow:auto; border:1px solid rgba(255,255,255,.08); border-radius:12px; }
    .row{ display:grid; grid-template-columns:auto 1fr auto; gap:.6rem; align-items:center; padding:.5rem .6rem; border-bottom:1px solid rgba(255,255,255,.06); }
    .row:last-child{ border-bottom:none; }
    .row small{ color:var(--muted); }
    .pill{ padding:.25rem .6rem; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); color:var(--muted); }
    .actions{ display:flex; gap:.6rem; justify-content:flex-end; }

    /* Lightbox */
    .lightbox{ position:fixed; inset:0; background:rgba(0,0,0,.75); display:none; align-items:center; justify-content:center; z-index:9999; }
    .lightbox.show{ display:flex; }
    .lightbox img{ max-width:90vw; max-height:80vh; object-fit:contain; border-radius:12px; box-shadow: var(--shadow); }

    /* Clock sizes */
    @media (orientation: landscape){ .clock{ font-size: clamp(2.6rem, 7vw, 5.2rem); } }
    @media (orientation: portrait){ .clock{ font-size: clamp(2.2rem, 10vw, 4.2rem); } }
  </style>
</head>
<body>
  <div class="backdrop" id="backdrop"></div>
  <main class="stage">
    <section class="frame" id="frame">
      <!-- Left panel -->
      <aside class="side" id="side">
        <div class="clockWrap">
          <div class="clock" id="clock">--:--<span class="ampm" id="ampm"></span></div>
        </div>
        <div class="meta">
          <div id="kicker" class="kicker" aria-hidden="true"></div>
          <div id="title" class="title" aria-hidden="true"></div>
          <div id="details" class="sub" aria-hidden="true"></div>
        </div>
      </aside>

      <!-- Image -->
      <div class="art" id="artArea">
        <div class="tint" id="tint"></div>
        <img id="artImg" alt="Radionuclide Mnemonic" />
        <div class="mark" id="mark">&nbsp;</div>
      </div>

      <!-- Full-screen hit grid -->
      <div class="hits" id="hits">
        <div class="hit" id="hitLeft" aria-label="Back"></div>
        <div class="hit" id="hitRight" aria-label="Forward"></div>
      </div>

      <!-- Footer -->
      <div class="footer">
        <div class="leftGroup">
          <button id="btnBad" class="btn bad">Not yet</button>
          <button id="btnGood" class="btn good">Got it</button>
          <button id="btnSettings" class="btn" title="Settings">⚙️</button>
        </div>
        <span class="chip" id="chip">—</span>
      </div>
    </section>
  </main>

  <!-- Settings -->
  <dialog id="settings" tabindex="-1">
    <form method="dialog" class="modal" id="settingsForm">
      <h3 style="margin:.2rem 0 .2rem">Settings</h3>

      <div class="grid3">
        <div class="field"><label>New per day</label><input name="newCount" id="newCount" type="number" min="0" max="200" value="5"></div>
        <div class="field"><label>Review per day</label><input name="reviewCount" id="reviewCount" type="number" min="0" max="200" value="5"></div>
        <div class="field"><label>Base image path</label><input name="imageBase" type="text" placeholder="./" value="./"></div>
      </div>

      <p style="color:var(--muted); font-size: .9rem; margin:.5rem 0 0;">Fact display duration (seconds)</p>
      <div class="grid-auto-fit">
        <div class="field"><label>Image</label><input name="tImage" type="number" min="1" value="4"></div>
        <div class="field"><label>Name</label><input name="tName" type="number" min="1" value="2"></div>
        <div class="field"><label>Prod. (Q)</label><input name="tProductionQ" type="number" min="1" value="3"></div>
        <div class="field"><label>Prod. (A)</label><input name="tProductionA" type="number" min="1" value="4"></div>
        <div class="field"><label>Decay (Q)</label><input name="tDecayQ" type="number" min="1" value="3"></div>
        <div class="field"><label>Decay (A)</label><input name="tDecayA" type="number" min="1" value="4"></div>
        <div class="field"><label>Photons (Q)</label><input name="tPhotonsQ" type="number" min="1" value="3"></div>
        <div class="field"><label>Photons (A)</label><input name="tPhotonsA" type="number" min="1" value="4"></div>
        <div class="field"><label>Half-Life (Q)</label><input name="tHalfLifeQ" type="number" min="1" value="3"></div>
        <div class="field"><label>Half-Life (A)</label><input name="tHalfLifeA" type="number" min="1" value="4"></div>
        <div class="field"><label>Note (A)</label><input name="tOtherFactsA" type="number" min="1" value="6"></div>
      </div>

      <div class="field"><label>Auto accent</label>
        <select name="autoAccent"><option value="on">On</option><option value="off">Off</option></select>
      </div>

      <div class="row" style="justify-content:space-between">
        <strong>Today's Repertoire</strong>
        <span class="pill" id="selCount">0/10</span>
      </div>

      <div class="field"><label>Search</label><input type="text" id="search" placeholder="Filter by radionuclide name..."></div>
      <div class="list" id="deckList" aria-label="Deck list"></div>

      <div class="actions">
        <button class="btn" value="cancel">Close</button>
        <button class="btn good" value="save">Save</button>
      </div>
    </form>
  </dialog>

  <!-- Lightbox -->
  <div class="lightbox" id="imgPreview"><img alt="Preview" id="previewImg"></div>

    <script>
    /* ===== Config & State ===== */
    const CONFIG_KEY = "radSRS_config_v4";
    const STATE_KEY  = "radSRS_state_v3";
    const TODAY_KEY  = "radSRS_today_v4";

    const DEFAULTS = {
      imageBase: "./",
      autoAccent: "on",
      easeDefault: 2.5,
      /* new vs review targets */
      newCount: 5,
      reviewCount: 5,
      /* timings */
      tImage: 4, tName: 2,
      tProductionQ: 3, tProductionA: 4,
      tDecayQ: 3,      tDecayA: 4,
      tPhotonsQ: 3,    tPhotonsA: 4,
      tHalfLifeQ: 3,   tHalfLifeA: 4,
      tOtherFactsQ: 3, tOtherFactsA: 6 // Q for question, A for answer (longer)
    };

    const el = {
      frame: document.getElementById("frame"),
      img: document.getElementById("artImg"),
      tint: document.getElementById("tint"),
      clock: document.getElementById("clock"),
      ampm: document.getElementById("ampm"),
      kicker: document.getElementById("kicker"),
      title: document.getElementById("title"),
      details: document.getElementById("details"),
      hits: document.getElementById("hits"),
      btnGood: document.getElementById("btnGood"),
      btnBad: document.getElementById("btnBad"),
      btnSettings: document.getElementById("btnSettings"),
      mark: document.getElementById("mark"),
      chip: document.getElementById("chip"),
      settings: document.getElementById("settings"),
      settingsForm: document.getElementById("settingsForm"),
      deckList: document.getElementById("deckList"),
      selCount: document.getElementById("selCount"),
      search: document.getElementById("search"),
      newCount: document.getElementById("newCount"),
      reviewCount: document.getElementById("reviewCount"),
      artArea: document.getElementById("artArea"),
      backdrop: document.getElementById("backdrop"),
      imgPreview: document.getElementById("imgPreview"),
      previewImg: document.getElementById("previewImg")
    };

    let cfg = loadConfig();
    let deck = [];
    let progress = loadState();
    let playlist = [];
    let todaySel = loadToday();
    let session = { index:0, phase:0, timers:[], today: dayISO(new Date()) };
    let suppressNextClick = false;

    /* ===== Phase plan (image → name → Q/A pairs) ===== */
    const FACT_ORDER = [
      { key: "name",       label: "Name",                 isQuestion: false, timerKey: "tName" },
      { key: "production", label: "Production",           isQuestion: true,  timerKeyQ: "tProductionQ", timerKeyA: "tProductionA" },
      { key: "decay",      label: "Decay Mode",           isQuestion: true,  timerKeyQ: "tDecayQ",      timerKeyA: "tDecayA" },
      { key: "photons",    label: "Principal Photons",    isQuestion: true,  timerKeyQ: "tPhotonsQ",    timerKeyA: "tPhotonsA" },
      { key: "halfLife",   label: "Half-Life",            isQuestion: true,  timerKeyQ: "tHalfLifeQ",   timerKeyA: "tHalfLifeA" },
      { key: "otherFacts", label: "Note",                 isQuestion: true,  timerKeyQ: "tOtherFactsQ", timerKeyA: "tOtherFactsA" }
    ];

    const PHASES = [{ type: "image", duration: () => cfg.tImage * 1000 }];
    FACT_ORDER.forEach(f => {
      if (f.isQuestion) {
        PHASES.push({ type: "question", fact: f, duration: () => cfg[f.timerKeyQ] * 1000 });
        PHASES.push({ type: "answer",   fact: f, duration: () => cfg[f.timerKeyA] * 1000 });
      } else {
        PHASES.push({ type: "title",    fact: f, duration: () => cfg[f.timerKey] * 1000 });
      }
    });

    /* ===== Utils ===== */
    function totalTarget(){ return Math.max(0, (+cfg.newCount||0) + (+cfg.reviewCount||0)); }
    function loadConfig(){
      const raw = localStorage.getItem(CONFIG_KEY);
      const merged = raw ? { ...DEFAULTS, ...JSON.parse(raw) } : { ...DEFAULTS };
      /* back-compat: if older config had dailyCount, split it evenly */
      if (merged.dailyCount != null && (merged.newCount == null || merged.reviewCount == null)) {
        const dc = +merged.dailyCount || 10;
        merged.newCount = Math.floor(dc/2);
        merged.reviewCount = dc - merged.newCount;
        delete merged.dailyCount;
      }
      return merged;
    }
    function saveConfig(){ localStorage.setItem(CONFIG_KEY, JSON.stringify(cfg)); }
    function loadState(){ const raw=localStorage.getItem(STATE_KEY); return raw?JSON.parse(raw):{}; }
    function saveState(){ localStorage.setItem(STATE_KEY, JSON.stringify(progress)); }
    function loadToday(){ const raw=localStorage.getItem(TODAY_KEY); return raw?JSON.parse(raw):{date: dayISO(new Date()), ids: []}; }
    function saveToday(){ localStorage.setItem(TODAY_KEY, JSON.stringify(todaySel)); }
    function dayISO(d){ const z= new Date(d.getFullYear(), d.getMonth(), d.getDate()); return z.toISOString().slice(0,10); }
    function isHttp(url){ return /^https?:/i.test(url); }
    function clearTimers(){ session.timers.forEach(t=>clearTimeout(t)); session.timers=[]; }
    function restartTimer(ms, fn){ clearTimers(); const t=setTimeout(fn, ms); session.timers=[t]; }

    function cleanText(val){
      if(val==null) return "";
      const s=String(val);
      const tmp=document.createElement("div");
      tmp.innerHTML=s;
      const text=tmp.textContent||tmp.innerText||"";
      return text.split(/\s+/).join(" ").trim();
    }

    function ensureProgress(card){
      if(!progress[card.id]){
        progress[card.id] = { ease: cfg.easeDefault, intervalDays:0, dueISO: session.today, reps:0, lapses:0, state:"new", learningStep:0, lastGrade:null };
      }
      return progress[card.id];
    }

    function grade(card, kind){
      const p=ensureProgress(card);
      if(kind==="good"){
        if(p.state==="new"){
          p.state="learning"; p.learningStep=1; p.intervalDays=1; p.dueISO=dayISO(new Date(Date.now()+86400000));
        } else if(p.state==="learning"){
          if(p.learningStep===1){
            p.learningStep=2; p.intervalDays=3; p.dueISO=dayISO(new Date(Date.now()+3*86400000));
          } else {
            p.state="review"; p.learningStep=0; p.intervalDays=Math.max(5, p.intervalDays||5); p.dueISO=dayISO(new Date(Date.now()+p.intervalDays*86400000));
          }
        } else {
          const next=Math.round(Math.max(1, p.intervalDays * p.ease));
          p.intervalDays=next; p.dueISO=dayISO(new Date(Date.now()+next*86400000));
        }
        p.reps++;
      } else {
        p.lapses++; p.state="learning"; p.learningStep=1; p.intervalDays=1; p.dueISO=dayISO(new Date(Date.now()+86400000));
      }
      p.lastGrade = kind; saveState(); showGradeFeedback(kind); updateChip();
    }

    /* ===== Accent from image + blurred backdrop ===== */
    function autoAccentFromImage(img){
      try{
        const canvas=document.createElement("canvas");
        const ctx=canvas.getContext("2d",{willReadFrequently:true});
        const w=canvas.width=80, h=canvas.height=80;
        ctx.drawImage(img,0,0,w,h);
        const data=ctx.getImageData(0,0,w,h).data; let r=0,g=0,b=0,c=0;
        for(let i=0;i<data.length;i+=4){ const a=data[i+3]; if(a<30) continue; r+=data[i]; g+=data[i+1]; b+=data[i+2]; c++; }
        if(c){ r=Math.round(r/c); g=Math.round(g/c); b=Math.round(b/c); const accent=`rgb(${r},${g},${b})`; document.documentElement.style.setProperty("--accent", accent); }
      }catch(e){}
      const url = img.currentSrc || img.src;
      el.backdrop.style.backgroundImage = `url('${url}')`;
      el.backdrop.style.backgroundSize = "cover";
      el.backdrop.style.backgroundPosition = "center";
      el.backdrop.style.filter = "blur(40px) brightness(.35) saturate(.9)";
      el.backdrop.style.transform = "scale(1.1)";
    }

    /* ===== Clock ===== */
    function fmtTime(d){ let h=d.getHours(); const m=d.getMinutes().toString().padStart(2,"0"); const ampm = h>=12? "PM":"AM"; h = h%12 || 12; return {h, m, ampm}; }
    function startClock(){ const tick=()=>{ const d=new Date(); const {h,m,ampm}=fmtTime(d); el.clock.textContent = `${h}:${m}`; el.ampm.textContent=ampm; }; tick(); setInterval(tick, 15000); }

    /* ===== Today selection (separate new/review) ===== */
    function ensureToday(){
      const today = dayISO(new Date());
      const targetTotal = totalTarget();

      if(todaySel.date !== today){ todaySel = { date: today, ids: [] }; }

      if(!todaySel.ids.length){
        const due = [];   // review pool
        const fresh = []; // new pool
        for(const c of deck){
          const p=ensureProgress(c);
          if(p.state!=="new" && p.dueISO<=today){ due.push(c.id); }
          else if(p.state==="new"){ fresh.push(c.id); }
        }

        const chosen = [];
        // up to reviewCount from due
        for(const id of due){ if(chosen.length >= cfg.reviewCount) break; if(!chosen.includes(id)) chosen.push(id); }
        // up to newCount from fresh
        let newAdded=0;
        for(const id of fresh){ if(newAdded >= cfg.newCount) break; if(!chosen.includes(id)){ chosen.push(id); newAdded++; } }

        // fill remainder (if any) from any deck item not already chosen
        while(chosen.length < Math.min(targetTotal, deck.length)){
          const c = deck[chosen.length % deck.length];
          if(!chosen.includes(c.id)) chosen.push(c.id);
          else {
            // find any not chosen
            const extra = deck.find(x=>!chosen.includes(x.id));
            if(!extra) break;
            chosen.push(extra.id);
          }
        }

        todaySel.ids = chosen.slice(0, targetTotal);
        saveToday();
      }
    }

    function buildPlaylist(){
      ensureToday();
      const map=new Map(deck.map(c=>[c.id,c]));
      playlist=todaySel.ids.map(id=>map.get(id)).filter(Boolean);
      if(!playlist.length && deck.length>0){
        // fallback: first N items
        const targetTotal = totalTarget() || 10;
        playlist = deck.slice(0, targetTotal);
        todaySel.ids = playlist.map(c=>c.id);
        saveToday();
      }
      session.index=0; updateChip();
    }

    /* ===== Rendering ===== */
    function hideMeta(){
      [el.kicker, el.title, el.details].forEach(n => {
        n.classList.remove("reveal");
        n.style.opacity=0;
        n.style.transform="translateY(8px)";
      });
    }
    function setMeta(kicker, title, details){
      el.kicker.textContent=kicker||"";
      el.title.textContent=title||"";
      el.details.textContent=details||"";
    }
    function loadImageFor(card){
      return new Promise((resolve)=>{
        const src = isHttp(card.image)? card.image : (cfg.imageBase||"./") + card.image;
        el.img.onload=()=>resolve();
        el.img.onerror=()=>resolve();
        el.img.src=src;
      });
    }
    function updateChip(){
      const n=playlist.length||0;
      const i=Math.min(session.index+1, Math.max(n,1));
      el.chip.textContent=`Today ${i}/${n}`;
    }

    async function showCurrent(auto=true){
      const card=playlist[session.index];
      if(!card){ setMeta("No deck.json found", "—", "Place deck.json next to this file."); return; }
      hideMeta(); setMeta("", "", "");
      await loadImageFor(card);
      if(cfg.autoAccent==="on") autoAccentFromImage(el.img);
      if(auto){ session.phase=0; revealStep(); scheduleFromCurrent(); }
      updateChip();
    }

    function revealStep(){
      const card = playlist[session.index]; if(!card) return;
      const ph = PHASES[session.phase]; if(!ph) return;
    
      hideMeta();
    
      // Keep the Radionuclide Name (in el.kicker) visible once it has been revealed.
      const nameRevealPhaseIndex = PHASES.findIndex(p => p.type === "title");
      if (nameRevealPhaseIndex >= 0 && session.phase >= nameRevealPhaseIndex) {
        el.kicker.textContent = card.name || "";
        el.kicker.classList.add("reveal");
      }
    
      switch(ph.type){
        case "image":
          // Image only, nothing in the meta panel.
          break;
        case "title":
          // This is the first time we reveal the name. It's already handled above.
          break;
        case "question":
          // Show the fact category in el.title.
          el.title.textContent = ph.fact.label;
          el.title.classList.add("reveal");
          break;
        case "answer":
          // Show the fact category (el.title) and the answer (el.details).
          el.title.textContent = ph.fact.label;
          el.details.textContent = card[ph.fact.key] || "N/A";
          el.title.classList.add("reveal");
          el.details.classList.add("reveal");
          break;
      }
    }

    function advanceToNextValidPhase() {
      const card = playlist[session.index];
      if (!card) {
        session.phase++;
        return;
      }
      
      do {
        session.phase++;
        const nextPhase = PHASES[session.phase];
        if (!nextPhase || !nextPhase.fact) break;
        if (card[nextPhase.fact.key]) break;
    
      } while (session.phase < PHASES.length -1);
    }
    
    function scheduleFromCurrent(){
      const current = PHASES[session.phase];
      if(!current) return;
      const dur = current.duration();
      restartTimer(dur, ()=>{
        if(session.phase < PHASES.length - 1){
          advanceToNextValidPhase();
          revealStep();
          scheduleFromCurrent();
        }else{
          nextCard();
        }
      });
    }

    function nextCard(){
      if(!playlist.length) return;
      session.index = (session.index+1)%playlist.length;
      showCurrent(true);
    }

    function stepBackward(){
      if(session.phase > 0){
        session.phase--;
        revealStep();
        const dur = PHASES[session.phase].duration();
        restartTimer(dur, ()=>{
          if(session.phase < PHASES.length - 1){
            session.phase++;
            revealStep();
            scheduleFromCurrent();
          } else {
            nextCard();
          }
        });
      } else {
        session.index = (session.index - 1 + playlist.length) % playlist.length;
        showCurrent(false);
        session.phase = PHASES.length - 1;
        revealStep();
        restartTimer(PHASES[session.phase].duration(), nextCard);
      }
    }

    function showGradeFeedback(kind){
      el.mark.textContent = kind==="good" ? "✓" : "✕";
      el.mark.style.color = kind==="good" ? "var(--good)" : "var(--bad)";
    }

    /* ===== Settings modal ===== */
    function openSettings(){
      const f=el.settingsForm;
      Object.keys(DEFAULTS).forEach(key => {
        if (f[key]) f[key].value = cfg[key];
      });
      buildDeckListFresh();
      el.settings.showModal();
      setTimeout(()=>{ el.settings.focus({preventScroll:true}); }, 0);
    }

    let tempSel = new Set();
    function buildDeckListFresh(){
      const term=(el.search.value||"").toLowerCase();
      tempSel = new Set(todaySel.ids);
      el.deckList.innerHTML="";
      let selectedCount = tempSel.size;
      const updateSelCount=()=>{
        el.selCount.textContent = `${selectedCount}/${totalTarget() || 10}`;
        el.newCount.value = cfg.newCount;
        el.reviewCount.value = cfg.reviewCount;
      };
      for(const c of deck){
        const name=cleanText(c.name);
        if(term && !name.toLowerCase().includes(term)) continue;
        const row=document.createElement("div"); row.className="row"; row.dataset.id=c.id;

        const cb=document.createElement("input"); cb.type="checkbox"; cb.checked=tempSel.has(c.id);
        const label=document.createElement("div"); label.innerHTML=`<strong>${name}</strong>`;
        const jump=document.createElement("button"); jump.className="btn"; jump.textContent="Image";

        cb.addEventListener("change", ()=>{
          if(cb.checked){
            const limit = totalTarget() || 10;
            if(selectedCount >= limit){
              cfg.newCount = Math.max(0, (selectedCount + 1) - (+cfg.reviewCount||0));
            }
            tempSel.add(c.id);
          } else {
            tempSel.delete(c.id);
          }
          selectedCount = tempSel.size;
          updateSelCount();
        });

        jump.addEventListener("click",(e)=>{
          e.preventDefault();
          const src = isHttp(c.image)? c.image : (cfg.imageBase||"./") + c.image;
          el.previewImg.src = src;
          el.imgPreview.classList.add("show");
        });

        row.appendChild(cb); row.appendChild(label); row.appendChild(jump);
        el.deckList.appendChild(row);
      }
      updateSelCount();
    }

    el.imgPreview.addEventListener("click", ()=>{ el.imgPreview.classList.remove("show"); el.previewImg.src=""; });
    el.search.addEventListener("input", buildDeckListFresh);

    el.settingsForm.addEventListener("submit", (e)=>{
      const action = e.submitter && e.submitter.value;
      if(action==="save"){
        const f = el.settingsForm;
        Object.keys(DEFAULTS).forEach(key => {
          if (f[key]) {
            const val = (f[key].type === "number") ? +f[key].value : f[key].value;
            cfg[key] = (val ?? DEFAULTS[key]);
          }
        });
        cfg.newCount = Math.max(0, Math.min(200, +cfg.newCount||0));
        cfg.reviewCount = Math.max(0, Math.min(200, +cfg.reviewCount||0));

        saveConfig();

        const target = totalTarget() || 10;
        todaySel.ids = Array.from(tempSel).slice(0, target);
        saveToday();

        buildPlaylist();
        showCurrent(true);
      }
      e.preventDefault();
      el.settings.close();
    });

    /* ===== Input / gestures ===== */
    function onHitClick(e){
      if(suppressNextClick){ suppressNextClick=false; return; }
      const rect = el.hits.getBoundingClientRect();
      const x = (typeof e.clientX === "number" ? e.clientX : rect.left + rect.width*0.75) - rect.left;
      if (x < rect.width/2){
        stepBackward();
      } else {
        if (session.phase < PHASES.length - 1){
          advanceToNextValidPhase();
          revealStep();
          scheduleFromCurrent();
        } else {
          nextCard();
        }
      }
    }

    let lpTimer=null; let touchStartX=0, touchStartY=0; const LONG_PRESS_MS=550; const MOVE_TOL=12;
    function onTouchStart(e){
      const t=e.touches[0]; touchStartX=t.clientX; touchStartY=t.clientY;
      const artRect = el.artArea.getBoundingClientRect();
      if(t.clientX<artRect.left || t.clientX>artRect.right || t.clientY<artRect.top || t.clientY>artRect.bottom){ return; }
      lpTimer=setTimeout(()=>{
        el.hits.style.pointerEvents="none";
        suppressNextClick=true;
        setTimeout(()=>{ el.hits.style.pointerEvents="auto"; }, 1200);
      }, LONG_PRESS_MS);
    }
    function onTouchMove(e){
      if(!lpTimer) return;
      const t=e.touches[0];
      if(Math.abs(t.clientX-touchStartX)>MOVE_TOL || Math.abs(t.clientY-touchStartY)>MOVE_TOL){
        clearTimeout(lpTimer); lpTimer=null;
      }
    }
    function onTouchEnd(){ if(lpTimer){ clearTimeout(lpTimer); lpTimer=null; } }

    el.hits.addEventListener("click", onHitClick);
    el.hits.addEventListener("touchstart", onTouchStart, {passive:true});
    el.hits.addEventListener("touchmove", onTouchMove,   {passive:true});
    el.hits.addEventListener("touchend", onTouchEnd,     {passive:true});
    el.hits.addEventListener("touchcancel", onTouchEnd,  {passive:true});

    el.btnGood.addEventListener("click", ()=>{ if(!playlist.length) return; grade(playlist[session.index], "good"); el.btnGood.classList.add("selected"); setTimeout(()=>el.btnGood.classList.remove("selected"), 400); });
    el.btnBad .addEventListener("click", ()=>{ if(!playlist.length) return; grade(playlist[session.index], "bad");  el.btnBad .classList.add("selected"); setTimeout(()=>el.btnBad .classList.remove("selected"), 400); });
    el.btnSettings.addEventListener("click", openSettings);

    window.addEventListener("keydown", (e)=>{
      if (e.target && e.target.tagName === "INPUT") return;
      if(e.key==="ArrowRight"){ onHitClick({ clientX: el.hits.getBoundingClientRect().left + el.hits.offsetWidth*0.75 }); }
      else if(e.key==="ArrowLeft"){ onHitClick({ clientX: el.hits.getBoundingClientRect().left + el.hits.offsetWidth*0.25 }); }
      else if(e.key.toLowerCase()==="g"){ if(playlist.length) grade(playlist[session.index],"good"); }
      else if(e.key.toLowerCase()==="b"){ if(playlist.length) grade(playlist[session.index],"bad"); }
      else if(e.key.toLowerCase()==="s"){ openSettings(); }
    });

    /* ===== Init ===== */
    async function init(){
      startClock();
      try{
        const res = await fetch("deck.json");
        deck = await res.json();
      }catch(e){
        deck = [];
        console.error("Failed to load or parse deck.json", e);
      }
      deck = deck.map(card => ({
        id: String(card.id ?? card.name ?? Math.random().toString(36).slice(2)),
        image: card.image,
        name: cleanText(card.name),
        production: cleanText(card.production),
        decay: cleanText(card.decay),
        photons: cleanText(card.photons),
        halfLife: cleanText(card.halfLife),
        otherFacts: cleanText(card.otherFacts) 
      }));
      if(!deck.length){ setMeta("Error:", "deck.json is missing or empty."); return; }
      ensureToday(); buildPlaylist(); showCurrent(true);
    }
    init();
  </script>
</body>
</html>
