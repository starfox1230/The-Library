<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Report Search - Night Mode</title>
  <style>
    :root {
      --bg-color: #1e1e1e;
      --text-color: #d4d4d4;
      --input-bg: #3c3c3c;
      --input-border: #555;
      --result-bg: #2a2a2a;
      --result-border: #444;
      --highlight-bg: #5a5a2a; /* Yellowish highlight */
      --highlight-text: #f0f0aa;
      --button-bg: #0e639c;
      --button-hover-bg: #1177bb;
      --button-text: #ffffff;
      --danger-button-bg: #a03030;
      --danger-button-hover-bg: #c04040;
      --link-color: #9cdcfe;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      margin: 0;
      padding: 1.5rem;
      background-color: var(--bg-color);
      color: var(--text-color);
      line-height: 1.6;
    }

    h1 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      color: var(--text-color);
      border-bottom: 1px solid var(--input-border);
      padding-bottom: 0.75rem;
      font-weight: 500;
    }

    #controls {
      margin-bottom: 1.5rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid var(--input-border);
    }

    /* --- Raw Input Area --- */
    #raw-input-section {
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 1px dashed var(--input-border); /* Dashed separator */
    }
    #raw-input-section label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
    }
    #raw-case-input {
        width: 100%;
        box-sizing: border-box;
        height: 200px; /* Adjust height as needed */
        padding: 0.75rem 1rem;
        margin-bottom: 0.5rem;
        background-color: var(--input-bg);
        border: 1px solid var(--input-border);
        color: var(--text-color);
        border-radius: 4px;
        font-family: monospace; /* Good for code-like input */
        font-size: 0.95rem;
        line-height: 1.5;
    }
     #raw-case-input:focus {
      outline: none;
      border-color: var(--button-bg);
      box-shadow: 0 0 0 2px rgba(14, 99, 156, 0.5);
    }
    /* --- End Raw Input Area --- */


    #txt-filter {
      width: 100%;
      box-sizing: border-box;
      padding: 0.75rem 1rem;
      margin-bottom: 1.5rem;
      background-color: var(--input-bg);
      border: 1px solid var(--input-border);
      color: var(--text-color);
      border-radius: 4px;
      font-size: 1.1rem;
    }
    #txt-filter:focus {
      outline: none;
      border-color: var(--button-bg);
      box-shadow: 0 0 0 2px rgba(14, 99, 156, 0.5);
    }

    #results {
      margin-top: 1rem;
    }

    /* Result item (snippet view) */
    .result-item {
      background-color: var(--result-bg);
      border: 1px solid var(--result-border);
      border-radius: 5px;
      padding: 0.8rem 1.2rem;
      margin-bottom: 0.8rem;
      cursor: pointer; /* Default for snippet */
      transition: background-color 0.2s ease;
       white-space: pre-wrap;
       word-break: break-word;
    }
    .result-item:hover {
        background-color: #333333;
    }
    /* Make expanded view non-hoverable */
    .result-item:has(.full-report-view):hover {
        background-color: var(--result-bg); /* Revert hover effect when expanded */
    }


    .result-item strong { /* Highlight */
      background-color: var(--highlight-bg);
      color: var(--highlight-text);
      font-weight: normal;
      padding: 0.1em 0.2em;
      border-radius: 3px;
    }

    /* Expanded report view */
    .full-report-view {
        background-color: #252526;
        border: 1px solid #555;
        border-radius: 5px;
        padding: 1rem 1.5rem;
        margin-top: 0.5rem;
        white-space: pre-wrap;
        cursor: default; /* Override parent cursor */
        font-family: monospace;
        font-size: 0.95em;
        line-height: 1.5;
    }
    .full-report-view h3 {
        margin-top: 0;
        margin-bottom: 0.5rem;
        font-size: 1rem;
        color: var(--link-color);
        border-bottom: 1px dashed var(--input-border);
        padding-bottom: 0.3rem;
    }
     /* Highlight within expanded view */
    .full-report-view strong {
        background-color: var(--highlight-bg);
        color: var(--highlight-text);
        font-weight: normal;
        padding: 0.1em 0.2em;
        border-radius: 3px;
    }


    .report-meta {
        font-size: 0.85em;
        color: #aaa;
        margin-bottom: 0.5em;
    }

    #status-message {
      text-align: center;
      color: #888;
      margin-top: 2rem;
      font-style: italic;
    }

    button {
      margin-right: .5rem;
      padding: .5rem 1rem;
      margin-top: .5rem;
      border: none;
      border-radius: 4px;
      background-color: var(--button-bg);
      color: var(--button-text);
      cursor: pointer;
      font-size: 0.95rem;
      transition: background-color 0.2s ease;
    }
    button:hover {
      background-color: var(--button-hover-bg);
    }
    #btn-clear-db {
        background-color: var(--danger-button-bg);
    }
     #btn-clear-db:hover {
        background-color: var(--danger-button-hover-bg);
    }
    #btn-parse-raw {
        background-color: #2a8f5a;
    }
    #btn-parse-raw:hover {
        background-color: #35a56c;
    }


    input[type="file"] { display: none; }

  </style>
</head>
<body>
  <h1>Report Search</h1>

  <div id="controls">
    <div id="raw-input-section">
      <label for="raw-case-input">Paste Raw Cases Here (Format: Case X...Attending Report:...Resident Report:...):</label>
      <textarea id="raw-case-input" placeholder="Case 1 Attending Report: ... Resident Report: ... Case 2 ..."></textarea><br>
      <button id="btn-parse-raw">Parse & Add Cases</button>
    </div>

    <button id="btn-load-db" title="Replace current database with file content">Load Report Database (JSON)</button>
    <button id="btn-append-db" title="Add reports from file to current database">Append to Database (JSON)</button>
    <button id="btn-download-db">Download Database (JSON)</button>
    <button id="btn-clear-db">Clear Saved Database</button>

    <input type="file" id="json-upload-input" accept=".json">
  </div>

  <input
    type="search"
    id="txt-filter"
    placeholder="Search: term &quot;exact phrase&quot; -exclude_term -&quot;exclude phrase&quot;"
  >
  <!-- Search Scope Toggle -->
  <div id="search-scope-controls" style="margin-bottom: 1rem; margin-top: -0.5rem; font-size: 0.9em;">
    <label style="margin-right: 0.5rem;">Search Scope:</label>
    <input type="radio" id="scope-section" name="search-scope" value="section" checked>
    <label for="scope-section" style="margin-right: 1rem;">Within each section (all terms must match, none of excluded)</label>
    <input type="radio" id="scope-report" name="search-scope" value="report">
    <label for="scope-report">Across whole report (any include term can match, none of excluded)</label>
  </div>
  <div id="results"></div>
  <div id="status-message">Load a database or type to search.</div>

  <script>
    const LOCAL_STORAGE_KEY = 'reportSearchDb_v1';
  let reportDatabase = [];
  let currentUploadMode = 'load';
  let currentSearchScope = 'section';

  // --- Search Term Parser (MODIFIED) ---
  /**
   * Parses a search query string into an object containing 'include' and 'exclude' token arrays.
   * Quoted phrases are treated as single tokens.
   * '-' prefix marks a token for exclusion.
   * All tokens are converted to lowercase.
   * Example: `word1 -"exact phrase" -word2 "another phrase"`
   * -> `{ include: ["word1", "another phrase"], exclude: ["exact phrase", "word2"] }`
   * @param {string} query The raw search query.
   * @returns {{include: string[], exclude: string[]}} An object with include and exclude token arrays.
   */
  function parseSearchTerm(query) {
    query = query.trim();
    const includeTokens = [];
    const excludeTokens = [];
    if (!query) return { include: includeTokens, exclude: excludeTokens };

    // Regex: captures optional hyphen, then (quoted string OR non-whitespace sequence)
    // Group 1: optional hyphen (-)
    // Group 2: content of a quoted string (if present)
    // Group 3: unquoted word (if present)
    const regex = /(-)?(?:"([^"]+)"|([^\s"]+))/g;
    let match;

    while ((match = regex.exec(query)) !== null) {
        const isExclude = match[1] === '-';
        let tokenContent = match[2] || match[3]; // match[2] for quoted, match[3] for unquoted

        if (tokenContent && tokenContent.trim() !== "") { // Ensure token is not just empty quotes
            tokenContent = tokenContent.toLowerCase();
            if (isExclude) {
                excludeTokens.push(tokenContent);
            } else {
                includeTokens.push(tokenContent);
            }
        }
    }
    return { include: includeTokens, exclude: excludeTokens };
  }


  // --- Database Utilities ---
  function paragraphSplitter(text) {
    if (!text) return [];
    const paragraphs = [];
    let currentNonSectionParaBuffer = []; 
    const selfContainedSectionRegex = /^([A-Z][A-Z0-9\s\/(),'-]*[A-Z0-9]):\s+(.+)$/;
    const lines = text.split(/\r?\n/);

    for (const line of lines) {
        const currentLineContent = line.trimEnd();
        const sectionMatch = currentLineContent.match(selfContainedSectionRegex);

        if (sectionMatch) {
            if (currentNonSectionParaBuffer.length > 0) {
                paragraphs.push(currentNonSectionParaBuffer.join('\n').trim());
                currentNonSectionParaBuffer = [];
            }
            paragraphs.push(currentLineContent);
        } else {
            if (currentLineContent === '') { 
                if (currentNonSectionParaBuffer.length > 0) {
                    paragraphs.push(currentNonSectionParaBuffer.join('\n').trim());
                    currentNonSectionParaBuffer = [];
                }
            } else {
                currentNonSectionParaBuffer.push(line); 
            }
        }
    }
    if (currentNonSectionParaBuffer.length > 0) {
        paragraphs.push(currentNonSectionParaBuffer.join('\n').trim());
    }
    return paragraphs.filter(p => p.length > 0);
  }

  function processLoadedData(data, mode = 'load') {
      let loadedReports = [];
      if (!Array.isArray(data)) {
          if (typeof data === 'string' && data.trim().toLowerCase().startsWith('case')) {
             try {
                 const parsedFromRaw = parseRawCases(data);
                 loadedReports = parsedFromRaw.newReports;
                 alert(`Parsed raw text input: ${parsedFromRaw.addedCount} reports added, ${parsedFromRaw.failedCount} failed.`);
             } catch (rawParseError) {
                  console.error("Failed to parse input as raw text:", rawParseError);
                  throw new Error("Invalid JSON format and failed to parse as raw case text.");
             }
          } else {
              throw new Error("Invalid JSON format: Expected an array of report objects.");
          }
      } else {
         loadedReports = data.map((item, index) => {
            if (!item || typeof item !== 'object' || typeof item.attendingReport === 'undefined' || typeof item.residentReport === 'undefined') {
                console.warn(`Skipping invalid item at index ${index} during JSON load.`);
                return null;
            }
            const id = item.id || `report_${Date.now()}_${index}`;
            return {
                id: id,
                attendingReport: (item.attendingReport || "").trim(),
                residentReport: (item.residentReport || "").trim(),
                attendingParagraphs: paragraphSplitter(item.attendingReport),
                residentParagraphs: paragraphSplitter(item.residentReport)
            };
         }).filter(Boolean);
         if (mode === 'load') {
             alert(`Database Loaded from JSON: ${loadedReports.length} reports processed.`);
         }
      }

      const existingIds = new Set(reportDatabase.map(r => r.id));
      let actuallyAddedCount = 0;

      if (mode === 'load') {
          reportDatabase = []; 
          loadedReports.forEach(newReport => {
              if (!reportDatabase.some(r => r.id === newReport.id)) { 
                  reportDatabase.push(newReport);
                  actuallyAddedCount++;
              } else {
                 console.warn(`Skipping report with duplicate ID '${newReport.id}' within the loaded data.`);
              }
          });
          existingIds.clear(); 
          reportDatabase.forEach(r => existingIds.add(r.id));

      } else if (mode === 'append') {
          loadedReports.forEach(newReport => {
              if (!existingIds.has(newReport.id)) {
                  reportDatabase.push(newReport);
                  existingIds.add(newReport.id);
                  actuallyAddedCount++;
              } else {
                  console.warn(`Skipping report with duplicate ID '${newReport.id}' during append.`);
              }
          });
           alert(`Database Appended: ${actuallyAddedCount} new reports added. Total: ${reportDatabase.length} reports.`);
      }

      if (actuallyAddedCount > 0 || (mode === 'load' && loadedReports.length > 0) ) {
        saveDatabase();
      }
      renderResults(document.getElementById('txt-filter').value);
      updateStatusMessage();
  }

   function parseRawCases(rawText) {
       if (!rawText || !rawText.trim()) {
           return { addedCount: 0, failedCount: 0, newReports: [] };
       }
       const caseChunks = rawText.split(/(?=^Case\s*\d+)/m).filter(chunk => chunk.trim());
       const newReports = [];
       let addedCount = 0;
       let failedCount = 0;

       caseChunks.forEach((chunk, index) => {
           chunk = chunk.trim();
           if (!chunk) return;
           const caseMatch = chunk.match(/^Case\s*(\d+)/);
           const caseNum = caseMatch ? caseMatch[1] : null;
           let reportId = caseNum ? `Case_${caseNum}` : `raw_${Date.now()}_${index}`;
           let attendingReport = '';
           let residentReport = '';
           const attendHeaderMatch = chunk.match(/Attending\s*Report:/i);
           const residentHeaderMatch = chunk.match(/(?:Resident|Residenrt)\s*Report:/i);
           let textAfterCaseNum = chunk;
           if(caseMatch) {
               textAfterCaseNum = chunk.substring(caseMatch[0].length).trim();
           }

           if (attendHeaderMatch && residentHeaderMatch) {
                if (attendHeaderMatch.index < residentHeaderMatch.index) {
                    attendingReport = textAfterCaseNum.substring(
                        attendHeaderMatch.index + attendHeaderMatch[0].length - (chunk.length - textAfterCaseNum.length), 
                        residentHeaderMatch.index - (chunk.length - textAfterCaseNum.length)
                    ).trim();
                    residentReport = textAfterCaseNum.substring(
                        residentHeaderMatch.index + residentHeaderMatch[0].length - (chunk.length - textAfterCaseNum.length)
                    ).trim();
                } else { 
                    residentReport = textAfterCaseNum.substring(
                        residentHeaderMatch.index + residentHeaderMatch[0].length - (chunk.length - textAfterCaseNum.length),
                        attendHeaderMatch.index - (chunk.length - textAfterCaseNum.length)
                    ).trim();
                    attendingReport = textAfterCaseNum.substring(
                        attendHeaderMatch.index + attendHeaderMatch[0].length - (chunk.length - textAfterCaseNum.length)
                    ).trim();
                }
           } else if (attendHeaderMatch) {
               attendingReport = textAfterCaseNum.substring(
                   attendHeaderMatch.index + attendHeaderMatch[0].length - (chunk.length - textAfterCaseNum.length)
                ).trim();
           } else if (residentHeaderMatch) { 
               residentReport = textAfterCaseNum.substring(
                   residentHeaderMatch.index + residentHeaderMatch[0].length - (chunk.length - textAfterCaseNum.length)
                ).trim();
           } else {
               if (textAfterCaseNum) {
                   attendingReport = textAfterCaseNum;
               }
           }

           if (attendingReport || residentReport) { 
               const report = {
                   id: reportId, 
                   attendingReport: attendingReport,
                   residentReport: residentReport,
                   attendingParagraphs: paragraphSplitter(attendingReport),
                   residentParagraphs: paragraphSplitter(residentReport)
               };
               newReports.push(report);
               addedCount++;
           } else {
               console.warn(`Failed to parse Case chunk effectively: "${chunk.substring(0, 100)}..." - Could not extract Attending or Resident report content.`);
               failedCount++;
           }
       });
       return { addedCount, failedCount, newReports };
   }

  function saveDatabase() {
    try {
      const dataToSave = reportDatabase.map(r => ({
          id: r.id,
          attendingReport: r.attendingReport,
          residentReport: r.residentReport
      }));
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
    } catch (e) {
      console.error("Error saving database:", e);
      alert("Error saving database to local storage. It might be full.");
    }
  }

  function loadDatabase() {
    const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
    reportDatabase = [];
    if (saved) {
      try {
        const parsedData = JSON.parse(saved);
        processLoadedData(parsedData, 'load'); 
      } catch (e) {
        console.error("Error loading database:", e);
        localStorage.removeItem(LOCAL_STORAGE_KEY); 
        alert("Error loading database from local storage. Cleared potentially corrupted data.");
      }
    }
    updateStatusMessage(); 
  }

  // --- UI Rendering ---
  function highlightMatches(text, includeTokens) { // Takes includeTokens only
      if (!includeTokens || includeTokens.length === 0 || !text) return text;
      let highlightedText = text;
      // Create a unique set of tokens, sorted by length (longest first) to prevent partial highlighting issues
      const sortedTokens = [...new Set(includeTokens.filter(t => t.trim() !== ""))].sort((a, b) => b.length - a.length);

      for (const token of sortedTokens) {
          const escapedToken = token.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          try {
              const regex = new RegExp(`(${escapedToken})`, 'gi'); 
              highlightedText = highlightedText.replace(regex, (match, p1) => `<strong>${p1}</strong>`);
          } catch (e) {
              console.warn("Highlighting regex error for token:", token, e);
          }
      }
      return highlightedText;
  }

  // --- renderResults (MODIFIED heavily for new search logic) ---
  function renderResults(rawQueryFromInput) {
    const resultsContainer = document.getElementById('results');
    const statusMessage = document.getElementById('status-message');
    resultsContainer.innerHTML = ''; 

    const parsedQuery = parseSearchTerm(rawQueryFromInput);

    if (parsedQuery.include.length === 0 && parsedQuery.exclude.length === 0) {
        updateStatusMessage();
        return;
    }

    let matchFoundOverall = false;
    const fragment = document.createDocumentFragment();

    if (currentSearchScope === 'section') {
        reportDatabase.forEach(report => {
          const processParagraphs = (paragraphs, type, reportId) => {
            paragraphs.forEach((p) => {
              const paragraphTextLower = p.toLowerCase();
              
              const allIncludeTokensFound = parsedQuery.include.length === 0 || 
                                          parsedQuery.include.every(token => paragraphTextLower.includes(token));
              const noExcludeTokensFound = parsedQuery.exclude.every(token => !paragraphTextLower.includes(token));

              if (allIncludeTokensFound && noExcludeTokensFound) {
                matchFoundOverall = true;
                const div = document.createElement('div');
                div.className = 'result-item';
                div.dataset.reportId = reportId;
                div.dataset.originalParagraph = p;
                div.dataset.rawQueryForHighlight = rawQueryFromInput;
                div.dataset.reportType = type;
                div.dataset.searchScopeWhenCreated = 'section';

                const meta = document.createElement('div');
                meta.className = 'report-meta';
                meta.textContent = `Match in ${reportId} (${type} Section)`;
                div.appendChild(meta);

                const content = document.createElement('div');
                content.innerHTML = highlightMatches(p, parsedQuery.include); // Highlight only include terms
                div.appendChild(content);

                div.addEventListener('dblclick', handleResultDoubleClick);
                fragment.appendChild(div);
              }
            });
          };
          processParagraphs(report.attendingParagraphs, 'Attending', report.id);
          processParagraphs(report.residentParagraphs, 'Resident', report.id);
        });
    } else { // currentSearchScope === 'report'
        reportDatabase.forEach(report => {
            const reportFullTextLower = (report.attendingReport + " " + report.residentReport).toLowerCase();

            const reportContainsExclusion = parsedQuery.exclude.some(token => reportFullTextLower.includes(token));
            if (reportContainsExclusion) {
                return; // Skip this report if any exclusion term is found
            }

            let reportMatchesIncludeCriteria;
            if (parsedQuery.include.length === 0) {
                reportMatchesIncludeCriteria = true; // No include terms, and passed exclusion = match
            } else {
                reportMatchesIncludeCriteria = parsedQuery.include.some(token => reportFullTextLower.includes(token));
            }

            if (reportMatchesIncludeCriteria) {
                matchFoundOverall = true;
                const reportDiv = document.createElement('div');
                reportDiv.className = 'result-item';
                reportDiv.dataset.reportId = report.id;
                reportDiv.dataset.rawQueryForHighlight = rawQueryFromInput;
                // For report scope, initiallyMatchedParagraphs stores those with *include* terms for snippet.
                // Or it will be empty for purely negative searches.
                const initiallyMatchedParagraphsData = [];

                if (parsedQuery.include.length > 0) {
                    const collectSnippets = (paragraphs, type) => {
                        paragraphs.forEach(p => {
                            const paragraphTextLower = p.toLowerCase();
                            if (parsedQuery.include.some(token => paragraphTextLower.includes(token))) {
                                initiallyMatchedParagraphsData.push({ text: p, type: type });
                            }
                        });
                    };
                    collectSnippets(report.attendingParagraphs, 'Attending');
                    collectSnippets(report.residentParagraphs, 'Resident');
                }
                reportDiv.dataset.initiallyMatchedParagraphs = JSON.stringify(initiallyMatchedParagraphsData);
                reportDiv.dataset.searchScopeWhenCreated = 'report';

                const meta = document.createElement('div');
                meta.className = 'report-meta';
                meta.textContent = `Matches in Report ${report.id}`;
                reportDiv.appendChild(meta);

                if (initiallyMatchedParagraphsData.length > 0) {
                    initiallyMatchedParagraphsData.forEach(paraData => {
                        const contentDiv = document.createElement('div');
                        contentDiv.style.marginBottom = "0.5em"; contentDiv.style.paddingLeft = "1em";
                        contentDiv.style.borderLeft = "2px solid var(--input-border)";
                        
                        const paraMeta = document.createElement('div');
                        paraMeta.textContent = `(from ${paraData.type} report)`;
                        paraMeta.style.fontSize = "0.8em"; paraMeta.style.fontStyle = "italic"; paraMeta.style.color = "#aaa";
                        contentDiv.appendChild(paraMeta);

                        const textContent = document.createElement('div');
                        textContent.innerHTML = highlightMatches(paraData.text, parsedQuery.include);
                        contentDiv.appendChild(textContent);
                        reportDiv.appendChild(contentDiv);
                    });
                } else if (parsedQuery.include.length === 0) { // Purely negative search, show context
                    const addReportContextSnippet = (fullSectionText, type, maxLength = 250) => {
                        if (!fullSectionText || !fullSectionText.trim()) return;
                        const contentDiv = document.createElement('div');
                        contentDiv.style.marginBottom = "0.5em"; contentDiv.style.paddingLeft = "1em";
                        contentDiv.style.borderLeft = "2px solid var(--input-border)";
                        const paraMeta = document.createElement('div');
                        paraMeta.textContent = `(from ${type} report)`;
                        paraMeta.style.fontSize = "0.8em"; paraMeta.style.fontStyle = "italic"; paraMeta.style.color = "#aaa";
                        contentDiv.appendChild(paraMeta);
                        const textContentDisplay = document.createElement('div');
                        textContentDisplay.textContent = fullSectionText.substring(0, maxLength) + (fullSectionText.length > maxLength ? "..." : "");
                        contentDiv.appendChild(textContentDisplay);
                        reportDiv.appendChild(contentDiv);
                    };
                    let addedContext = false;
                    if (report.attendingReport) { addReportContextSnippet(report.attendingReport, 'Attending'); addedContext = true;}
                    if (report.residentReport) { addReportContextSnippet(report.residentReport, 'Resident'); addedContext = true;}
                    if (!addedContext) {
                        const noPreview = document.createElement('div');
                        noPreview.textContent = "(Report content is empty but meets search criteria)";
                        noPreview.style.fontStyle = "italic"; noPreview.style.marginLeft = "1em";
                        reportDiv.appendChild(noPreview);
                    }
                }
                reportDiv.addEventListener('dblclick', handleResultDoubleClick);
                fragment.appendChild(reportDiv);
            }
        });
    }

    resultsContainer.appendChild(fragment);

    if ((parsedQuery.include.length > 0 || parsedQuery.exclude.length > 0) && !matchFoundOverall) {
        statusMessage.textContent = 'No matching results found for "' + rawQueryFromInput + '".';
        statusMessage.style.display = 'block';
    } else {
       updateStatusMessage();
    }
  }

   function updateStatusMessage() {
       const statusMessage = document.getElementById('status-message');
       const filterInput = document.getElementById('txt-filter');
       const resultsContainer = document.getElementById('results');
       const currentRawQuery = filterInput.value;
       const parsedQuery = parseSearchTerm(currentRawQuery); // MODIFIED

       if (parsedQuery.include.length === 0 && parsedQuery.exclude.length === 0 && resultsContainer.innerHTML === '') {
            statusMessage.textContent = reportDatabase.length > 0
                ? 'Type in the search box above to find reports.'
                : 'Load a report database or paste raw cases above.';
            statusMessage.style.display = 'block';
       } else if ((parsedQuery.include.length > 0 || parsedQuery.exclude.length > 0) && resultsContainer.innerHTML === '') {
           // "No matching results" is handled by renderResults, so only hide if not that message
           if (!statusMessage.textContent.startsWith('No matching')) {
                statusMessage.style.display = 'none'; // Should be hidden if no results were found due to renderResults setting specific msg
           } else {
                statusMessage.style.display = 'block'; 
           }
       } else if (resultsContainer.innerHTML !== '') { 
            statusMessage.style.display = 'none';
       } else { 
            statusMessage.textContent = reportDatabase.length > 0
                ? 'Type in the search box above to find reports.'
                : 'Load a report database or paste raw cases above.';
           statusMessage.style.display = 'block';
       }
   }

  // --- Event Handlers ---
  function handleResultDoubleClick(event) { // EXPAND (MODIFIED)
    const resultItem = event.currentTarget;
    const reportId = resultItem.dataset.reportId;
    const report = reportDatabase.find(r => r.id === reportId);

    if (!report) {
        console.error("Could not find report for ID:", reportId);
        resultItem.innerHTML = '<div class="report-meta" style="color: red;">Error: Report data not found.</div>';
        resultItem.style.cursor = 'default';
        resultItem.removeEventListener('dblclick', handleResultDoubleClick);
        return;
    };

    const originalDataset = { ...resultItem.dataset };
    resultItem.innerHTML = '';
    resultItem.style.cursor = 'default';
    resultItem.removeEventListener('dblclick', handleResultDoubleClick);
    Object.keys(originalDataset).forEach(key => { resultItem.dataset[key] = originalDataset[key]; });

    const fullView = document.createElement('div');
    fullView.className = 'full-report-view';

    const meta = document.createElement('div');
    meta.className = 'report-meta';
    meta.textContent = `Full Report: ${report.id} (Double-click to collapse)`;
    fullView.appendChild(meta);

    const rawCurrentQuery = document.getElementById('txt-filter').value; // Use current query for full view highlight
    const currentParsedQuery = parseSearchTerm(rawCurrentQuery); // MODIFIED

    const attendingHeader = document.createElement('h3');
    attendingHeader.textContent = 'Attending Report';
    fullView.appendChild(attendingHeader);
    const attendingContent = document.createElement('div');
    // Highlight using only include terms from current query
    attendingContent.innerHTML = highlightMatches(report.attendingReport, currentParsedQuery.include);
    fullView.appendChild(attendingContent);

    if (report.residentReport && report.residentReport.trim()) {
        const residentHeader = document.createElement('h3');
        residentHeader.textContent = 'Resident Report';
        residentHeader.style.marginTop = '1rem';
        fullView.appendChild(residentHeader);
        const residentContent = document.createElement('div');
        residentContent.innerHTML = highlightMatches(report.residentReport, currentParsedQuery.include);
        fullView.appendChild(residentContent);
    }

    resultItem.appendChild(fullView);
    resultItem.addEventListener('dblclick', handleCollapseDoubleClick);
  }

  function handleCollapseDoubleClick(event) { // COLLAPSE (MODIFIED)
      const resultItem = event.currentTarget;
      const reportId = resultItem.dataset.reportId;
      const rawQueryForHighlight = resultItem.dataset.rawQueryForHighlight; // Query used when snippet was created
      const searchScopeWhenCreated = resultItem.dataset.searchScopeWhenCreated;

      resultItem.innerHTML = ''; 
      resultItem.style.cursor = 'pointer';
      resultItem.removeEventListener('dblclick', handleCollapseDoubleClick);

      const parsedQueryForSnippet = parseSearchTerm(rawQueryForHighlight); // MODIFIED

      if (searchScopeWhenCreated === 'report') {
          const initiallyMatchedParagraphs = JSON.parse(resultItem.dataset.initiallyMatchedParagraphs);
          
          const meta = document.createElement('div');
          meta.className = 'report-meta';
          meta.textContent = `Matches in Report ${reportId}`;
          resultItem.appendChild(meta);

          if (parsedQueryForSnippet.include.length > 0 && initiallyMatchedParagraphs.length > 0) {
              initiallyMatchedParagraphs.forEach(paraData => {
                  const contentDiv = document.createElement('div'); /* styles */
                  const paraMeta = document.createElement('div'); /* styles */
                  contentDiv.appendChild(paraMeta); paraMeta.textContent = `(from ${paraData.type} report)`;
                  const textContent = document.createElement('div');
                  textContent.innerHTML = highlightMatches(paraData.text, parsedQueryForSnippet.include);
                  contentDiv.appendChild(textContent); resultItem.appendChild(contentDiv);
                  // Basic styling for consistency
                  contentDiv.style.marginBottom = "0.5em"; contentDiv.style.paddingLeft = "1em";
                  contentDiv.style.borderLeft = "2px solid var(--input-border)";
                  paraMeta.style.fontSize = "0.8em"; paraMeta.style.fontStyle = "italic"; paraMeta.style.color = "#aaa";

              });
          } else if (parsedQueryForSnippet.include.length === 0) { // Purely negative search, recreate context snippet
              const report = reportDatabase.find(r => r.id === reportId);
              if (report) {
                  const addReportContextSnippetForCollapse = (fullSectionText, type, maxLength = 250) => {
                      if (!fullSectionText || !fullSectionText.trim()) return;
                      const contentDiv = document.createElement('div'); /* styles */
                      const paraMeta = document.createElement('div'); /* styles */
                      contentDiv.appendChild(paraMeta); paraMeta.textContent = `(from ${type} report)`;
                      const textContentDisplay = document.createElement('div');
                      textContentDisplay.textContent = fullSectionText.substring(0, maxLength) + (fullSectionText.length > maxLength ? "..." : "");
                      contentDiv.appendChild(textContentDisplay); resultItem.appendChild(contentDiv);
                      // Basic styling for consistency
                      contentDiv.style.marginBottom = "0.5em"; contentDiv.style.paddingLeft = "1em";
                      contentDiv.style.borderLeft = "2px solid var(--input-border)";
                      paraMeta.style.fontSize = "0.8em"; paraMeta.style.fontStyle = "italic"; paraMeta.style.color = "#aaa";
                  };
                  let addedContext = false;
                  if (report.attendingReport) { addReportContextSnippetForCollapse(report.attendingReport, 'Attending'); addedContext = true;}
                  if (report.residentReport) { addReportContextSnippetForCollapse(report.residentReport, 'Resident'); addedContext = true;}
                  if (!addedContext) { 
                      const noPreview = document.createElement('div'); noPreview.textContent = "(Report content is empty but meets search criteria)";
                      noPreview.style.fontStyle = "italic"; noPreview.style.marginLeft = "1em"; resultItem.appendChild(noPreview);
                  }
              } else {
                  resultItem.innerHTML += '<div style="color:orange">Error: Could not restore report context.</div>';
              }
          }
      } else { // Section scope collapse
          const originalParagraph = resultItem.dataset.originalParagraph;
          const reportType = resultItem.dataset.reportType;
          if (typeof originalParagraph === 'undefined' || typeof reportType === 'undefined') {
              console.error("Missing data for section-scope collapse.", resultItem.dataset);
              resultItem.innerHTML = '<div class="report-meta" style="color: orange;">Error: Could not restore snippet.</div>';
              resultItem.style.cursor = 'default'; 
              return; 
          }
          const meta = document.createElement('div');
          meta.className = 'report-meta';
          meta.textContent = `Match in ${reportId} (${reportType} Section)`;
          resultItem.appendChild(meta);
          const content = document.createElement('div');
          content.innerHTML = highlightMatches(originalParagraph, parsedQueryForSnippet.include);
          resultItem.appendChild(content);
      }
      resultItem.addEventListener('dblclick', handleResultDoubleClick);
  }


  function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
          try {
              const fileContent = e.target.result;
              let loadedData;
              try {
                  loadedData = JSON.parse(fileContent);
              } catch (jsonError) {
                  if (typeof fileContent === 'string' && fileContent.trim().toLowerCase().startsWith('case')) {
                       loadedData = fileContent; 
                  } else {
                      throw new Error("File is not valid JSON and doesn't appear to be raw case text.");
                  }
              }
              processLoadedData(loadedData, currentUploadMode);
          } catch (err) {
              alert(`Error loading or processing file: ${err.message}`);
              console.error("File Load/Process Error:", err);
          } finally {
              event.target.value = ''; 
          }
      };
      reader.onerror = (e) => {
          alert("Error reading file.");
          console.error("File Reader Error:", e);
          event.target.value = '';
      };
      reader.readAsText(file);
  }

  // --- Initialization and Event Listeners ---
  document.addEventListener('DOMContentLoaded', () => {
    loadDatabase();

    const filterInput = document.getElementById('txt-filter');
    const fileUploadInput = document.getElementById('json-upload-input');
    const rawCaseInput = document.getElementById('raw-case-input');
    const parseRawButton = document.getElementById('btn-parse-raw');
    const searchScopeRadios = document.querySelectorAll('input[name="search-scope"]'); 

    let filterTimeout;
        filterInput.addEventListener('input', () => {
            clearTimeout(filterTimeout);
            filterTimeout = setTimeout(() => {
                const currentQuery = filterInput.value; // Get current value from input field
    
                if (currentQuery.length >= 4) {
                    renderResults(currentQuery);
                } else {
                    // Clear previous results if query length is less than 4
                    document.getElementById('results').innerHTML = '';
    
                    if (currentQuery.length > 0) { // Input has 1, 2, or 3 characters
                        document.getElementById('status-message').textContent = 'Please enter at least 4 characters to begin searching.';
                        document.getElementById('status-message').style.display = 'block';
                    } else { // Input is empty (0 characters)
                        // updateStatusMessage will handle showing the default prompt
                        // (e.g., "Type in the search box..." or "Load a report database...")
                        updateStatusMessage();
                    }
                }
            }, 250); // Debounce time remains 250ms
        });

    searchScopeRadios.forEach(radio => {
        radio.addEventListener('change', (event) => {
            currentSearchScope = event.target.value;
            renderResults(filterInput.value); 
        });
    });


    parseRawButton.addEventListener('click', () => {
        const rawText = rawCaseInput.value;
        if (!rawText.trim()) {
            alert("Please paste case text into the box first.");
            return;
        }
        try {
            const parseResult = parseRawCases(rawText); 
            let actuallyAddedToDbCount = 0;

            if (parseResult.newReports.length > 0) {
                const currentIds = new Set(reportDatabase.map(r => r.id));
                let idCounter = 0;

                parseResult.newReports.forEach(newReport => {
                    let uniqueId = newReport.id;
                    while (currentIds.has(uniqueId)) {
                        idCounter++;
                        uniqueId = `${newReport.id}_${idCounter}`;
                    }
                    newReport.id = uniqueId; 
                    
                    reportDatabase.push(newReport);
                    currentIds.add(uniqueId);
                    actuallyAddedToDbCount++;
                });

                if (actuallyAddedToDbCount > 0) {
                    saveDatabase();
                    rawCaseInput.value = ''; 
                    renderResults(filterInput.value); 
                    updateStatusMessage();
                    alert(`Successfully added ${actuallyAddedToDbCount} new reports from text.${parseResult.failedCount > 0 ? ` ${parseResult.failedCount} text segments failed to parse fully.` : ''}`);
                } else {
                     alert(`No new reports were added. ${parseResult.failedCount > 0 ? ` ${parseResult.failedCount} text segments failed to parse fully.` : ''}`);
                }
            } else {
                alert(`Could not parse any valid reports from the text.${parseResult.failedCount > 0 ? ` ${parseResult.failedCount} potential cases failed to parse.` : ''}`);
            }
        } catch (error) {
            console.error("Error parsing raw cases from button:", error);
            alert("An unexpected error occurred while parsing the text. Check the console for details.");
        }
    });

    document.getElementById('btn-load-db').onclick = () => {
      currentUploadMode = 'load';
      fileUploadInput.click();
    };
    document.getElementById('btn-append-db').onclick = () => {
      currentUploadMode = 'append';
      fileUploadInput.click();
    };
    fileUploadInput.addEventListener('change', handleFileUpload);

    document.getElementById('btn-download-db').onclick = () => {
        if (reportDatabase.length === 0) {
            alert("Database is empty. Nothing to download."); return;
        }
        const dataToSave = reportDatabase.map(r => ({ id: r.id, attendingReport: r.attendingReport, residentReport: r.residentReport }));
        const str = JSON.stringify(dataToSave, null, 2);
        const blob = new Blob([str], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const date = new Date();
        const timestamp = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        a.download = `reportDatabase_${timestamp}.json`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
    };

    document.getElementById('btn-clear-db').onclick = () => {
      if (confirm("Are you sure you want to clear the entire saved report database from your browser? This cannot be undone.")) {
        localStorage.removeItem(LOCAL_STORAGE_KEY);
        reportDatabase = [];
        renderResults(''); 
        updateStatusMessage();
        alert("Saved database cleared.");
      }
    };
  });
  </script>
</body>
</html>
