<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>APKG → Text Export (Anki Order)</title>
<style>
  :root{
    --bg:#020617; --panel:#020617; --panel2:#020617;
    --fg:#e5edff; --muted:#94a3b8; --accent:#38bdf8;
    --border:#1f2937;
  }
  *{ box-sizing:border-box }
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(circle at 0% 0%, #0f172a 0, #020617 50%, #000 100%);
    color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    display:flex; flex-direction:column; align-items:center; padding:16px;
  }
  h1{ margin:8px 0 4px; font-size:18px }
  p{ margin:4px 0; color:var(--muted); font-size:13px }
  .card{
    width:min(980px, 100%); background:linear-gradient(145deg, rgba(15,23,42,.95), rgba(15,23,42,.92));
    border-radius:16px; padding:16px 16px 12px; border:1px solid rgba(148,163,184,.25);
    box-shadow:0 18px 40px rgba(15,23,42,.8);
  }
  .controls{
    display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:8px 0 10px;
  }
  input[type=file]{
    background:#020617; border:1px solid var(--border); color:var(--fg);
    padding:8px 10px; border-radius:10px; font-size:13px;
  }
  button{
    border:0; border-radius:999px; padding:8px 14px; font-size:13px;
    font-weight:600; cursor:pointer; background:var(--accent); color:#0f172a;
    box-shadow:0 8px 22px rgba(56,189,248,.35);
  }
  button.secondary{
    background:#020617; color:var(--fg); border:1px solid var(--border);
    box-shadow:none;
  }
  button:disabled{
    opacity:.45; cursor:not-allowed; box-shadow:none;
  }
  #status{ font-size:12px; color:var(--muted); margin-top:4px; min-height:18px }
  textarea{
    width:100%; height:55vh; margin-top:10px; resize:vertical;
    background:#020617; color:var(--fg); border-radius:12px;
    border:1px solid var(--border); padding:10px; font-family:Menlo,Consolas,monospace;
    font-size:12px; line-height:1.4; white-space:pre; overflow:auto;
  }
</style>
</head>
<body>
<div class="card">
  <h1>APKG → Text Export (Anki Order)</h1>
  <p>Exports all due cards using the same queue logic as your Lightning Drill app (approximate Anki order), with plain front/back text.</p>

  <div class="controls">
    <input id="fileInput" type="file" accept=".apkg,.colpkg" />
    <button id="downloadBtn" class="secondary" disabled>Download .txt</button>
    <button id="copyBtn" disabled>Copy text</button>
  </div>
  <div id="status"></div>
  <textarea id="output" placeholder="Load an .apkg/.colpkg file to see output here…" spellcheck="false"></textarea>
</div>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/sql-wasm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/protobufjs@7.3.0/dist/protobuf.min.js"></script>
<script>
/* ========= Small helpers ========= */
function stripHtml(s){
  const d = document.createElement('div');
  d.innerHTML = s;
  return d.textContent || d.innerText || '';
}
function sanitize(html){
  return String(html).replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi,'');
}

/* ========= Unzip + media parsing (same core as Lightning) ========= */
function unzipWithWatchdog(buf, timeoutMs=20000){
  return new Promise((resolve, reject) => {
    let done=false;
    const to=setTimeout(()=>{ if(!done){done=true; reject(new Error('Unzip timeout'))}}, timeoutMs);
    try{
      fflate.unzip(buf, {consume:true}, (err,obj)=>{
        if(done) return;
        clearTimeout(to);
        if(err){ done=true; reject(err) } else { done=true; resolve(obj) }
      });
    }catch(e){
      clearTimeout(to);
      reject(e);
    }
  });
}

function looksGzip(b){ return b.length>2 && b[0]===0x1F && b[1]===0x8B }
function looksZstd(b){
  return b.length>4 && (
    (b[0]===0xFD && b[1]===0x2F && b[2]===0xB5 && b[3]===0x28) ||
    (b[0]===0x28 && b[1]===0xB5 && b[2]===0x2F && b[3]===0xFD)
  );
}

function loadScript(url){
  return new Promise((res,rej)=>{
    const s=document.createElement('script');
    s.src=url;
    s.onload=res;
    s.onerror=()=>rej(new Error('Failed '+url));
    document.head.appendChild(s);
  });
}

async function maybeDecompress(bytes){
  if(bytes[0]===0x7B) return bytes; // '{' JSON
  if(looksGzip(bytes)) return fflate.gunzipSync(bytes);
  if(looksZstd(bytes)){
    if(!window.ZstdCodec){
      await loadScript('https://cdn.jsdelivr.net/npm/zstd-codec@0.1.4/dist/zstd-codec.min.js');
    }
    return await new Promise((resolve,reject)=>{
      window.ZstdCodec.run(zstd=>{
        try{
          const out = new zstd.Simple().decompress(bytes);
          resolve(out);
        }catch(e){ reject(e) }
      });
    });
  }
  return bytes;
}

function parseMediaJSON(txt){
  if(txt.charCodeAt(0)===0xFEFF) txt=txt.slice(1); // BOM
  const first=txt.indexOf('{'), last=txt.lastIndexOf('}');
  if(first<0||last<0||last<=first) throw new Error('No JSON object in media file');
  txt = txt.slice(first,last+1)
           .replace(/,\s*([}\]])/g,'$1')
           .replace(/[\u0000-\u0008\u000B-\u000C\u000E-\u001F]/g,'')
           .replace(/([{,]\s*)(\d+)(\s*:)/g,'$1"$2"$3');
  return JSON.parse(txt);
}

async function decodeProtoMedia(bytes){
  const urls=[
    "https://cdn.jsdelivr.net/gh/ankitects/anki@stable/proto/anki/import_export.proto",
    "https://cdn.jsdelivr.net/gh/ankitects/anki@main/proto/anki/import_export.proto"
  ];
  let root=null;
  for(const u of urls){
    try{
      const r=await fetch(u,{cache:'force-cache'});
      if(!r.ok) continue;
      root = protobuf.parse(await r.text()).root;
      break;
    }catch{}
  }
  if(!root) throw new Error('proto load failed');

  function toMap(obj){
    for(const v of Object.values(obj||{})){
      if(Array.isArray(v)&&v.length&&typeof v[0]==='object'){
        const hasIdx=('index'in v[0])||('id'in v[0]);
        const hasNm=('filename'in v[0])||('name'in v[0]);
        if(hasIdx&&hasNm){
          const m={};
          for(const it of v){
            const k=(it.index??it.id);
            const nm=(it.filename??it.name);
            if(k!=null&&typeof nm==='string') m[String(k)]=nm;
          }
          return m;
        }
      }
    }
    return null;
  }

  const all=[];
  (function walk(ns){
    for(const k of Object.keys(ns.nested||{})){
      const v=ns.nested[k];
      if(v.fields) all.push(v);
      if(v.nested) walk(v);
    }
  })(root);

  for(const T of all){
    try{
      const msg=T.decode(bytes);
      const map=toMap(msg);
      if(map) return map;
    }catch{}
  }
  throw new Error('unknown media map');
}

async function parseMediaEntry(entryBytes){
  const td=new TextDecoder('utf-8',{fatal:false});
  let bytes=await maybeDecompress(entryBytes);
  if(bytes[0]===0x7B){ // JSON
    return parseMediaJSON(td.decode(bytes));
  }
  try{
    return await decodeProtoMedia(bytes);
  }catch(e){
    console.warn('media map parse failed', e);
    return {};
  }
}

function mediaURLForKey(key, files){
  const bytes=files[key];
  if(!bytes) return null;
  return URL.createObjectURL(new Blob([bytes],{type:'application/octet-stream'}));
}

function buildMediaReplacer(mediaMap, files){
  const reverse={};
  for(const [k,v] of Object.entries(mediaMap)) reverse[v]=k;

  const imgRE=/<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
  const audioRE=/\[sound:([^\]]+)\]/gi;

  function resolve(src){
    if(/^\d+$/.test(src)){
      const u=mediaURLForKey(src,files);
      if(u) return u;
    }
    let u=mediaURLForKey(src,files);
    if(u) return u;
    const idx=reverse[src];
    if(idx!==undefined){
      u=mediaURLForKey(idx,files);
      if(u) return u;
    }
    return null;
  }

  return function replaceAll(html){
    html = html.replace(imgRE,(m,src)=>{
      const u=resolve(src);
      return u ? m.replace(src,u) : m;
    });
    html = html.replace(audioRE,(m,name)=>{
      const u=resolve(name);
      return u ? `<audio controls preload="metadata" src="${u}"></audio>` : m;
    });
    return html;
  };
}

/* ========= Cloze templating & templates (same behavior as Lightning) ========= */
function processClozeForOrd(text, targetIndex, side){
  return String(text).replace(/\{\{c(\d+)::([\s\S]*?)(?:::(.*?))?\}\}/g,(m,n,inner,hint)=>{
    const idx=parseInt(n,10);
    const safeInner = (inner||'').replace(/</g,'&lt;');
    const safeHint  = (hint||'').replace(/</g,'&lt;');
    if(idx===targetIndex){
      if(side==='front'){
        const mask = safeHint ? `[${safeHint}]` : `[...]`;
        return `<span class="cloze"><span class="cloze-mask">${mask}</span><span class="cloze-answer" style="display:none">${safeInner}</span></span>`;
      }else{
        return `<span class="cloze-reveal">${safeInner}</span>`;
      }
    }
    return safeInner;
  });
}

function applyConditionals(tpl, fields, fieldNames){
  tpl = tpl.replace(/\{\{#([^}]+)\}\}([\s\S]*?)\{\{\/\1\}\}/g,(m,name,inner)=>{
    const idx=fieldNames.indexOf(name.trim());
    const val=idx>=0 ? fields[idx] : '';
    return String(val).trim() ? inner : '';
  });
  tpl = tpl.replace(/\{\{\^([^}]+)\}\}([\s\S]*?)\{\{\/\1\}\}/g,(m,name,inner)=>{
    const idx=fieldNames.indexOf(name.trim());
    const val=idx>=0 ? fields[idx] : '';
    return String(val).trim() ? '' : inner;
  });
  return tpl;
}

function stripClozeMarkup(s){
  return String(s).replace(/\{\{c\d+::([\s\S]*?)(?:::[^}]*)?\}\}/g,'$1');
}

function collectClozeFieldsFromTemplate(tpl){
  const set=new Set();
  tpl.replace(/\{\{([^}]+)\}\}/g,(_m,token)=>{
    const parts=token.trim().split(':');
    const field=parts.pop().trim();
    const chain=parts.map(p=>p.trim().toLowerCase());
    if(chain.includes('cloze')) set.add(field);
  });
  return set;
}

function substituteTokens(tpl, fields, fieldNames, { side, targetCloze, templateForScan }){
  const clozeFields=collectClozeFieldsFromTemplate(templateForScan||tpl);
  return tpl.replace(/\{\{([^}]+)\}\}/g,(m,raw)=>{
    const token=raw.trim();
    if(token==='FrontSide') return '{{FrontSide}}';
    const parts=token.split(':');
    const fieldName=parts.pop().trim();
    const chain=parts.map(p=>p.trim().toLowerCase());
    const idx=fieldNames.indexOf(fieldName);
    const val=idx>=0 ? (fields[idx]??'') : '';

    const hasCloze=chain.includes('cloze');
    const hasType =chain.includes('type');
    const hasText =chain.includes('text') || chain.includes('hint');

    if(hasCloze) return processClozeForOrd(val, targetCloze, side);
    if(hasType){
      return `<input class="type-answer" aria-label="type your answer" />`;
    }
    if(hasText){
      if(clozeFields.has(fieldName)) return '';
      return stripClozeMarkup(val);
    }
    if(clozeFields.has(fieldName)) return '';
    return val;
  });
}

function collapseExactDuplicate(html){
  const lines=String(html).split(/(?:\r?\n|<br\s*\/?>)+/i)
    .map(s=>s.trim()).filter(Boolean);
  const seen=new Set(), keep=[];
  for(const line of lines){
    const key=line.replace(/\s+/g,' ');
    if(!seen.has(key)){
      seen.add(key);
      keep.push(line);
    }
  }
  return keep.join('<br>');
}

/* ========= Queue building: SAME LOGIC as Lightning Drill ========= */
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=(Math.random()*(i+1))|0;
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
}

function computeToday(nowSec, crt, cutoffSec){
  const DAY = 86400;
  return Math.floor((nowSec - cutoffSec)/DAY) - Math.floor((crt - cutoffSec)/DAY);
}

function buildAnkiLikeQueue(cards, decksById, nowSec, today){
  const learnNow   = cards
    .filter(c => c.queue===1 && c.due <= nowSec)
    .sort((a,b)=>a.due-b.due || a.id-b.id);

  const learnToday = cards
    .filter(c => c.queue===3 && c.due <= today)
    .sort((a,b)=>a.due-b.due || a.id-b.id);

  let reviews = cards.filter(c => c.queue===2 && c.due <= today);
  let news    = cards.filter(c => c.queue===0 || c.type===0);

  if(reviews.length){
    const groups = new Map();
    for(const c of reviews){
      if(!groups.has(c.due)) groups.set(c.due, []);
      groups.get(c.due).push(c);
    }
    reviews = Array.from(groups.keys())
      .sort((a,b)=>a-b)
      .flatMap(k => {
        const g = groups.get(k);
        shuffle(g);
        return g;
      });
  }

  news.sort((a,b)=>{
    const da=(decksById[a.did]||'').localeCompare(decksById[b.did]||'');
    if(da) return da;
    return (a.due - b.due) || (a.id - b.id);
  });

  const newPerDay=20, revPerDay=200;
  news    = news.slice(0,newPerDay);
  reviews = reviews.slice(0,revPerDay);

  const seenNote = new Set();
  const bury = arr => arr.filter(c => {
    if(seenNote.has(c.nid)) return false;
    seenNote.add(c.nid);
    return true;
  });

  const ReviewsQ = bury(reviews);
  const NewsQ    = bury(news);

  return [...learnNow, ...ReviewsQ, ...learnToday, ...NewsQ];
}

/* ========= SQL init ========= */
let SQLReady=false, SQL;

initSqlJs({
  locateFile: f => `https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/${f}`
}).then(db => {
  SQL = db;
  SQLReady = true;
}).catch(e => {
  alert('Failed to load SQLite engine (sql.js). Refresh and try again.\n'+(e?.message||e));
});

/* ========= Main conversion ========= */
async function convertApkgToText(file, statusEl){
  if(!SQLReady) throw new Error('SQLite engine not ready yet.');

  statusEl.textContent='Reading file…';
  const buf = new Uint8Array(await file.arrayBuffer());

  if(!(buf[0]===0x50 && buf[1]===0x4b)){ // 'PK'
    throw new Error('This does not look like a ZIP (.apkg/.colpkg).');
  }

  statusEl.textContent='Unzipping…';
  const entries = await unzipWithWatchdog(buf, 20000);

  const dbEntry = entries['collection.anki21'] || entries['collection.anki21b'] || entries['collection.anki2'];
  if(!dbEntry) throw new Error('Could not find collection.anki21/.anki2 in this package.');

  let mediaMap={};
  if(entries['media']){
    try{ mediaMap = await parseMediaEntry(entries['media']); }
    catch(e){ console.warn('media parse failed', e); }
  }

  const fileTable={};
  for(const [k,v] of Object.entries(entries)) fileTable[k]=v;
  const replaceMedia = buildMediaReplacer(mediaMap, fileTable);

  statusEl.textContent='Opening collection…';
  let db;
  try{
    db = new SQL.Database(dbEntry);
  }catch(e){
    throw new Error('SQLite open failed: '+(e?.message||e));
  }

  let models={}, decks={}, crt=0;
  try{
    const col = db.exec(`SELECT * FROM col LIMIT 1`)[0];
    if(!col) throw new Error('no col rows');
    const row = Object.fromEntries(col.columns.map((c,i)=>[c,col.values[0][i]]));
    models = JSON.parse(row.models);
    decks  = JSON.parse(row.decks);
    crt    = Number(row.crt)||0;
  }catch(e){
    throw new Error('Failed to read collection metadata: '+(e?.message||e));
  }

  const notes=[];
  try{
    const r=db.exec(`SELECT id,guid,mid,flds,sfld,tags FROM notes`)[0];
    if(r){
      for(const v of r.values){
        notes.push(Object.fromEntries(r.columns.map((c,i)=>[c,v[i]])));
      }
    }
  }catch(e){
    throw new Error('Failed to read notes table: '+(e?.message||e));
  }

  const cards=[];
  try{
    const r=db.exec(`SELECT id,nid,did,ord,type,queue,due,ivl FROM cards`)[0];
    if(r){
      for(const v of r.values){
        cards.push(Object.fromEntries(r.columns.map((c,i)=>[c,v[i]])));
      }
    }
  }catch(e){
    throw new Error('Failed to read cards table: '+(e?.message||e));
  }

  // Build decksById for new-card ordering
  const decksById={};
  for(const [id,d] of Object.entries(decks)){
    decksById[id] = d?.name || d?.nm || String(id);
  }

  const nowSec = Math.floor(Date.now()/1000);
  const crtNum = crt || nowSec;
  const dayCutoffSec = 4*3600; // same as Lightning Drill
  const today = computeToday(nowSec, crtNum, dayCutoffSec);

  statusEl.textContent='Building Anki-like queue…';
  const queue = buildAnkiLikeQueue(cards, decksById, nowSec, today);

  const noteById = new Map();
  for(const n of notes) noteById.set(n.id, n);

  let exportedCount=0;
  let out='';

  statusEl.textContent='Rendering cards… (this may take a bit for large decks)';
  queue.forEach((card, idx)=>{
    const note = noteById.get(card.nid);
    if(!note) return;
    const model = models[String(note.mid)];
    if(!model) return;
    const fieldNames = (model.flds || []).map(f => f.name);
    const fields = (note.flds || '').split('\x1f');
    const tmpl = (model.tmpls || [])[card.ord];
    if(!tmpl) return;
    const targetCloze = card.ord + 1;

    let front = tmpl.qfmt || '';
    front = applyConditionals(front, fields, fieldNames);
    front = substituteTokens(front, fields, fieldNames, {
      side:'front',
      targetCloze,
      templateForScan: tmpl.qfmt
    });
    front = sanitize(front);
    front = replaceMedia(front);
    front = collapseExactDuplicate(front);

    let back = tmpl.afmt || '';
    back = back.replace(/\{\{FrontSide\}\}/g, front);
    back = applyConditionals(back, fields, fieldNames);
    back = substituteTokens(back, fields, fieldNames, {
      side:'back',
      targetCloze,
      templateForScan: tmpl.afmt
    });
    back = sanitize(back);
    back = replaceMedia(back);
    back = collapseExactDuplicate(back);

    const frontText = stripHtml(front).trim();
    const backText  = stripHtml(back).trim();

    exportedCount++;
    out += `Card ${idx+1}\nFront:\n${frontText}\n\nBack:\n${backText}\n\n---\n\n`;
  });

  if(!out){
    out = 'No due cards found to export with the current queue logic.';
  }

  statusEl.textContent = `Done. Exported ${exportedCount} cards in Anki-like order.`;
  return out;
}

/* ========= Wire up UI ========= */
const fileInput   = document.getElementById('fileInput');
const statusEl    = document.getElementById('status');
const outputEl    = document.getElementById('output');
const downloadBtn = document.getElementById('downloadBtn');
const copyBtn     = document.getElementById('copyBtn');

let lastText = '';

fileInput.addEventListener('change', async (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;

  outputEl.value = '';
  lastText = '';
  downloadBtn.disabled = true;
  copyBtn.disabled = true;
  statusEl.textContent = 'Preparing…';

  try{
    const text = await convertApkgToText(file, statusEl);
    lastText = text;
    outputEl.value = text;
    downloadBtn.disabled = false;
    copyBtn.disabled = false;
  }catch(err){
    console.error(err);
    statusEl.textContent = 'Error: ' + (err?.message||String(err));
    alert('Error converting deck:\n' + (err?.message||String(err)));
  }
});

downloadBtn.addEventListener('click', ()=>{
  if(!lastText) return;
  const blob = new Blob([lastText], {type:'text/plain;charset=utf-8'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url;
  a.download = 'anki-export.txt';
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
});

copyBtn.addEventListener('click', async ()=>{
  if(!lastText) return;
  try{
    await navigator.clipboard.writeText(lastText);
    statusEl.textContent = 'Copied to clipboard.';
  }catch{
    // Fallback: select + execCommand
    outputEl.focus();
    outputEl.select();
    document.execCommand('copy');
    statusEl.textContent = 'Copied (fallback).';
  }
});
</script>
</body>
</html>