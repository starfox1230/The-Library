<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>APKG → Front/Back TXT Export</title>
<style>
  :root{
    --bg:#020617; --fg:#e8f0ff; --muted:#9bb0d0; --accent:#4ea1ff;
    --panel:#0b1020; --panel2:#050814; --stroke:#243042;
  }
  *{ box-sizing:border-box }
  html,body{height:100%}
  body{
    margin:0; background:#000; color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
  }

  /* background */
  #bgfx, #bgfx2{
    position:fixed; inset:0; z-index:-2; pointer-events:none; filter:blur(40px) saturate(120%);
    background:
      radial-gradient(1200px 600px at 10% 20%, #113a71 0%, transparent 60%),
      radial-gradient(1000px 600px at 90% 80%, #360f5b 0%, transparent 60%),
      linear-gradient(180deg, #020617 0%, #020112 100%);
    animation:bgpan 18s linear infinite alternate;
  }
  #bgfx2{
    mix-blend-mode:screen; opacity:.7; filter:blur(60px) saturate(160%);
    background:
      radial-gradient(700px 500px at 70% 20%, #0064ff 0%, transparent 60%),
      radial-gradient(700px 500px at 30% 80%, #a000ff 0%, transparent 60%);
    animation:bgpan2 22s linear infinite alternate;
  }
  @keyframes bgpan { to{ transform:translate3d(0,6%,0) } }
  @keyframes bgpan2{ to{ transform:translate3d(0,-4%,0) } }

  header{
    width:100%; max-width:980px;
    padding:16px 16px 8px;
    position:sticky; top:0; z-index:10;
    background:linear-gradient(180deg, rgba(1,7,18,.92), rgba(1,6,16,.75));
    backdrop-filter:blur(10px);
    border-bottom:1px solid #0f172a;
  }
  h1{
    margin:0 0 8px; font-size:20px; font-weight:700; letter-spacing:.02em;
  }
  #subtitle{
    margin:0 0 12px; font-size:13px; color:var(--muted);
  }
  main{
    width:100%; max-width:980px;
    padding:8px 16px 32px;
  }

  .row{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px }
  input[type=file]{
    background:#020617; border:1px solid #1f2937; color:var(--fg);
    padding:8px 10px; border-radius:10px; font-size:13px;
  }
  button{
    border:0; padding:9px 14px; border-radius:999px;
    font-weight:600; font-size:14px; cursor:pointer;
    background:var(--accent); color:#fff;
    box-shadow:0 10px 30px rgba(78,161,255,.35);
  }
  button.secondary{
    background:#0b1120; color:var(--fg); border:1px solid #1f2937;
    box-shadow:none;
  }
  button:disabled{
    opacity:.45; cursor:default; box-shadow:none;
  }

  #options{ display:flex; flex-wrap:wrap; gap:10px; margin-top:4px; font-size:13px; color:var(--muted) }
  #options label{ display:flex; align-items:center; gap:6px; cursor:pointer }
  #options input[type=checkbox]{ accent-color:var(--accent) }

  #panel{
    margin-top:14px;
    background:linear-gradient(180deg, var(--panel), var(--panel2));
    border-radius:18px;
    border:1px solid var(--stroke);
    box-shadow:0 30px 80px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,.03);
    padding:16px 16px 18px;
    font-size:13px;
  }
  #deckInfo strong{ font-weight:600 }
  #status{ margin-top:6px; color:var(--muted); min-height:1.2em; }
  #preview{
    margin-top:12px; padding:10px; border-radius:12px;
    background:#020617; border:1px solid #111827;
    max-height:220px; overflow:auto; white-space:pre-wrap; font-family:system-ui, -apple-system, Segoe UI, sans-serif;
    font-size:12px; line-height:1.4;
  }
  #previewTitle{ font-weight:600; margin-bottom:4px; color:#cbd5f5; }

  @media (max-width:640px){
    header, main{ padding-left:10px; padding-right:10px }
    h1{ font-size:18px }
  }
</style>
</head>
<body>
<div id="bgfx"></div><div id="bgfx2"></div>

<header>
  <h1>APKG → Front/Back TXT Export</h1>
  <p id="subtitle">Load an Anki <code>.apkg</code> / <code>.colpkg</code>, then export a text file listing the rendered front and back of every card.</p>
  <div class="row">
    <input id="file" type="file" accept=".apkg,.colpkg" />
    <button id="exportBtn" disabled>Export TXT</button>
  </div>
  <div id="options">
    <label><input id="stripHtml" type="checkbox" checked /> Strip all HTML to plain text</label>
    <label><input id="includeIds" type="checkbox" checked /> Include card and note IDs</label>
  </div>
</header>

<main>
  <div id="panel">
    <div id="deckInfo">No deck loaded.</div>
    <div id="status"></div>
    <div id="preview" style="display:none">
      <div id="previewTitle">Preview (first card):</div>
      <div id="previewBody"></div>
    </div>
  </div>
</main>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/sql-wasm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/protobufjs@7.3.0/dist/protobuf.min.js"></script>

<script>
/* ===== shorthand & helpers ===== */
const $ = s => document.querySelector(s);
const els = {
  file: $('#file'),
  exportBtn: $('#exportBtn'),
  stripHtml: $('#stripHtml'),
  includeIds: $('#includeIds'),
  deckInfo: $('#deckInfo'),
  status: $('#status'),
  preview: $('#preview'),
  previewBody: $('#previewBody')
};

function setStatus(msg){
  els.status.textContent = msg || '';
}

/* Remove any <script> tags but otherwise leave HTML intact */
function sanitize(html){
  return String(html).replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
}

/* Collapse exact duplicate lines (like duplicated FrontSide) */
function collapseExactDuplicate(html){
  const lines = String(html).split(/(?:\r?\n|<br\s*\/?>)+/i)
    .map(s => s.trim())
    .filter(Boolean);
  const seen = new Set(); const out = [];
  for(const line of lines){
    const key = line.replace(/\s+/g, ' ');
    if(!seen.has(key)){ seen.add(key); out.push(line); }
  }
  return out.join('\n');
}

/* Convert HTML fragment to plain text, preserving basic line breaks */
function htmlToPlainText(html){
  const div = document.createElement('div');
  div.innerHTML = html;
  let text = div.textContent || div.innerText || '';
  text = text.replace(/\r?\n[ \t]*/g, '\n');  // trim spaces at line starts
  text = text.replace(/\n{3,}/g, '\n\n');    // collapse excessive blank lines
  return text.trim();
}

/* ===== sql.js ===== */
let SQLReady = false, SQL;
initSqlJs({
  locateFile: f => `https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/${f}`
}).then(db => {
  SQL = db;
  SQLReady = true;
  setStatus('SQLite engine ready. Load a deck.');
}).catch(e => {
  alert('Failed to load sql.js.\n' + (e && e.message || e));
});

/* ===== unzip & media parsing (same logic as your Lightning Drill app, trimmed) ===== */

function unzipWithWatchdog(buf, timeoutMs=20000){
  return new Promise((resolve, reject) => {
    let done = false;
    const to = setTimeout(()=>{
      if(!done){ done=true; reject(new Error('Unzip timeout')); }
    }, timeoutMs);
    try{
      fflate.unzip(buf, { consume:true }, (err, obj)=>{
        if(done) return;
        clearTimeout(to);
        if(err){ done=true; reject(err); }
        else { done=true; resolve(obj); }
      });
    }catch(e){
      clearTimeout(to);
      reject(e);
    }
  });
}

function looksGzip(b){ return b.length>2 && b[0]===0x1F && b[1]===0x8B; }
function looksZstd(b){
  return b.length>4 && (
    (b[0]===0xFD && b[1]===0x2F && b[2]===0xB5 && b[3]===0x28) ||
    (b[0]===0x28 && b[1]===0xB5 && b[2]===0x2F && b[3]===0xFD)
  );
}

function loadScript(url){
  return new Promise((res, rej)=>{
    const s = document.createElement('script');
    s.src = url;
    s.onload = res;
    s.onerror = ()=>rej(new Error('Failed to load ' + url));
    document.head.appendChild(s);
  });
}

async function maybeDecompress(bytes){
  // Plain JSON
  if(bytes[0] === 0x7B) return bytes;
  // gzip
  if(looksGzip(bytes)) return fflate.gunzipSync(bytes);
  // zstd
  if(looksZstd(bytes)){
    if(!window.ZstdCodec){
      await loadScript('https://cdn.jsdelivr.net/npm/zstd-codec@0.1.4/dist/zstd-codec.min.js');
    }
    return await new Promise((resolve, reject)=>{
      window.ZstdCodec.run(zstd=>{
        try{
          const out = new zstd.Simple().decompress(bytes);
          resolve(out);
        }catch(e){ reject(e); }
      });
    });
  }
  return bytes;
}

function parseMediaJSON(txt){
  if (txt.charCodeAt(0)===0xFEFF) txt = txt.slice(1); // strip BOM
  const first = txt.indexOf('{');
  const last  = txt.lastIndexOf('}');
  if(first<0 || last<0 || last<=first) throw new Error('No JSON object in media file');
  // Clean trailing commas, control chars, and unquoted numeric keys
  txt = txt.slice(first, last+1)
           .replace(/,\s*([}\]])/g, '$1')
           .replace(/[\u0000-\u0008\u000B-\u000C\u000E-\u001F]/g, '')
           .replace(/([{,]\s*)(\d+)(\s*:)/g, '$1"$2"$3');
  return JSON.parse(txt);
}

async function decodeProtoMedia(bytes){
  const urls = [
    "https://cdn.jsdelivr.net/gh/ankitects/anki@stable/proto/anki/import_export.proto",
    "https://cdn.jsdelivr.net/gh/ankitects/anki@main/proto/anki/import_export.proto"
  ];
  let root=null;
  for(const u of urls){
    try{
      const r = await fetch(u, { cache:'force-cache' });
      if(!r.ok) continue;
      root = protobuf.parse(await r.text()).root;
      break;
    }catch(_){}
  }
  if(!root) throw new Error('Failed to load Anki proto definitions');

  function toMap(obj){
    for(const v of Object.values(obj||{})){
      if(Array.isArray(v) && v.length && typeof v[0]==='object'){
        const hasIdx = ('index' in v[0]) || ('id' in v[0]);
        const hasNm  = ('filename' in v[0]) || ('name' in v[0]);
        if(hasIdx && hasNm){
          const m={};
          for(const it of v){
            const k = (it.index ?? it.id);
            const nm = (it.filename ?? it.name);
            if(k!=null && typeof nm==='string') m[String(k)] = nm;
          }
          return m;
        }
      }
    }
    return null;
  }

  const all=[];
  (function walk(ns){
    for(const k of Object.keys(ns.nested||{})){
      const v=ns.nested[k];
      if(v.fields) all.push(v);
      if(v.nested) walk(v);
    }
  })(root);

  for(const T of all){
    try{
      const msg = T.decode(bytes);
      const map = toMap(msg);
      if(map) return map;
    }catch(_){}
  }
  throw new Error('Unknown media proto format');
}

async function parseMediaEntry(entryBytes){
  const td = new TextDecoder('utf-8', { fatal:false });
  let bytes = await maybeDecompress(entryBytes);
  if(bytes[0] === 0x7B){ // JSON
    return parseMediaJSON(td.decode(bytes));
  }
  try{
    return await decodeProtoMedia(bytes);
  }catch(e){
    console.warn('media map parse failed', e);
    return {};
  }
}

function mediaURLForKey(key, files){
  const bytes = files[key];
  if(!bytes) return null;
  return URL.createObjectURL(new Blob([bytes], { type:'application/octet-stream' }));
}

function buildMediaReplacer(mediaMap, files){
  const reverse = {};
  for(const [k,v] of Object.entries(mediaMap)){
    reverse[v] = k;
  }
  const imgRE   = /<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
  const audioRE = /\[sound:([^\]]+)\]/gi;

  function resolve(src){
    // numeric key
    if(/^\d+$/.test(src)){
      const u = mediaURLForKey(src, files);
      if(u) return u;
    }
    let u = mediaURLForKey(src, files);
    if(u) return u;
    const idx = reverse[src];
    if(idx !== undefined){
      u = mediaURLForKey(idx, files);
      if(u) return u;
    }
    return null;
  }

  return function replaceAll(html){
    html = html.replace(imgRE, (m, src)=>{
      const u = resolve(src);
      return u ? m.replace(src, u) : m;
    });
    html = html.replace(audioRE, (m, name)=>{
      const u = resolve(name);
      return u ? `<audio controls preload="metadata" src="${u}"></audio>` : m;
    });
    return html;
  };
}

/* ===== Anki template / cloze helpers (trimmed from your drill app) ===== */

function processClozeForOrd(text, targetIndex, side){
  return String(text).replace(/\{\{c(\d+)::([\s\S]*?)(?:::(.*?))?\}\}/g,
    (m, n, inner, hint)=>{
      const idx = parseInt(n,10);
      const safeInner = (inner||'').replace(/</g,'&lt;');
      const safeHint  = (hint ||'').replace(/</g,'&lt;');
      if(idx === targetIndex){
        if(side === 'front'){
          const mask = safeHint ? `[${safeHint}]` : `[...]`;
          return `<span class="cloze"><span class="cloze-mask">${mask}</span><span class="cloze-answer" style="display:none">${safeInner}</span></span>`;
        }else{
          return `<span class="cloze-reveal">${safeInner}</span>`;
        }
      }
      return safeInner;
    });
}

function applyConditionals(tpl, fields, fieldNames){
  // {{#Field}}content{{/Field}}: show if field non-empty
  tpl = tpl.replace(/\{\{#([^}]+)\}\}([\s\S]*?)\{\{\/\1\}\}/g,
    (m, name, inner)=>{
      const idx = fieldNames.indexOf(name.trim());
      const val = idx >= 0 ? fields[idx] : '';
      return String(val).trim() ? inner : '';
    });
  // {{^Field}}content{{/Field}}: show if field empty
  tpl = tpl.replace(/\{\{\^([^}]+)\}\}([\s\S]*?)\{\{\/\1\}\}/g,
    (m, name, inner)=>{
      const idx = fieldNames.indexOf(name.trim());
      const val = idx >= 0 ? fields[idx] : '';
      return String(val).trim() ? '' : inner;
    });
  return tpl;
}

function stripClozeMarkup(s){
  return String(s).replace(/\{\{c\d+::([\s\S]*?)(?:::[^}]*)?\}\}/g, '$1');
}

function collectClozeFieldsFromTemplate(tpl){
  const set = new Set();
  tpl.replace(/\{\{([^}]+)\}\}/g, (m, token)=>{
    const parts = token.trim().split(':');
    const field = parts.pop().trim();
    const chain = parts.map(p=>p.trim().toLowerCase());
    if(chain.includes('cloze')) set.add(field);
  });
  return set;
}

function substituteTokens(tpl, fields, fieldNames, { side, targetCloze, templateForScan }){
  const clozeFields = collectClozeFieldsFromTemplate(templateForScan || tpl);
  return tpl.replace(/\{\{([^}]+)\}\}/g, (m, raw)=>{
    const token = raw.trim();
    if(token === 'FrontSide') return '{{FrontSide}}';

    const parts = token.split(':');
    const fieldName = parts.pop().trim();
    const chain = parts.map(p=>p.trim().toLowerCase());

    const idx = fieldNames.indexOf(fieldName);
    const val = idx >= 0 ? (fields[idx] ?? '') : '';

    const hasCloze = chain.includes('cloze');
    const hasType  = chain.includes('type');
    const hasText  = chain.includes('text') || chain.includes('hint');

    if(hasCloze){
      return processClozeForOrd(val, targetCloze, side);
    }
    if(hasType){
      // type-in-the-answer field → simple input (ignored when stripping HTML)
      return `<input class="type-answer" aria-label="type your answer" />`;
    }
    if(hasText){
      // text: and hint: should strip cloze markup
      if(clozeFields.has(fieldName)) return '';
      return stripClozeMarkup(val);
    }
    if(clozeFields.has(fieldName)){
      // hide raw cloze field if template uses it via cloze:
      return '';
    }
    return val;
  });
}

/* ===== global Anki state ===== */
const G = {
  entries: null,
  fileTable: {},
  mediaMap: {},
  replaceMedia: html => html,
  decks: {},
  models: {},
  notes: [],
  cards: [],
  notesById: {}
};

/* Build a rendered front/back for a card using the Anki templates */
function renderCardFrontBack(card){
  const note = G.notesById[card.nid];
  if(!note) return null;
  const model = G.models[String(note.mid)];
  if(!model) return null;

  const fieldNames = (model.flds || []).map(f => f.name);
  const fields = (note.flds || '').split('\x1f');

  const tmpl = (model.tmpls || [])[card.ord];
  if(!tmpl) return null;

  const target = card.ord + 1; // cloze index is 1-based

  // FRONT
  let front = tmpl.qfmt || '';
  front = applyConditionals(front, fields, fieldNames);
  front = substituteTokens(front, fields, fieldNames, {
    side:'front',
    targetCloze:target,
    templateForScan:tmpl.qfmt
  });
  front = sanitize(front);
  front = G.replaceMedia(front);
  front = collapseExactDuplicate(front);

  // BACK
  let back = tmpl.afmt || '';
  back = back.replace(/\{\{FrontSide\}\}/g, front);
  back = applyConditionals(back, fields, fieldNames);
  back = substituteTokens(back, fields, fieldNames, {
    side:'back',
    targetCloze:target,
    templateForScan:tmpl.afmt
  });
  back = sanitize(back);
  back = G.replaceMedia(back);
  back = collapseExactDuplicate(back);

  return { front, back };
}

/* ===== file loading ===== */

els.file.addEventListener('change', async (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  if(!SQLReady){
    alert('SQLite engine is not ready yet. Wait a moment and try again.');
    return;
  }

  els.exportBtn.disabled = true;
  els.preview.style.display = 'none';
  setStatus('Reading file...');

  const buf = new Uint8Array(await file.arrayBuffer());
  if(!(buf[0]===0x50 && buf[1]===0x4b)){ // 'PK'
    alert('This does not look like a ZIP (.apkg/.colpkg).');
    setStatus('Not a valid Anki package.');
    return;
  }

  let entries;
  try{
    setStatus('Unzipping deck...');
    entries = await unzipWithWatchdog(buf, 25000);
  }catch(err){
    alert('Unzip failed: ' + (err && err.message || err));
    setStatus('Unzip failed.');
    return;
  }

  const dbEntry = entries['collection.anki21'] ||
                  entries['collection.anki21b'] ||
                  entries['collection.anki2'];
  if(!dbEntry){
    alert('Could not find collection.anki21/anki21b/anki2 in this package.');
    setStatus('No collection DB in package.');
    return;
  }

  let mediaMap = {};
  try{
    if(entries['media']){
      setStatus('Parsing media map...');
      mediaMap = await parseMediaEntry(entries['media']);
    }
  }catch(e){
    console.warn('Media map parse failed', e);
  }

  const fileTable = {};
  for(const [k,v] of Object.entries(entries)) fileTable[k] = v;
  const replaceMedia = buildMediaReplacer(mediaMap, fileTable);

  setStatus('Opening SQLite DB...');
  let db;
  try{
    db = new SQL.Database(dbEntry);
  }catch(e){
    alert('Failed to open SQLite DB: ' + (e && e.message || e));
    setStatus('SQLite open failed.');
    return;
  }

  let models={}, decks={};
  let notes=[], cards=[];
  try{
    const colRes = db.exec(`SELECT * FROM col LIMIT 1`)[0];
    if(!colRes) throw new Error('No row in col');
    const colRow = Object.fromEntries(colRes.columns.map((c,i)=>[c,colRes.values[0][i]]));
    models = JSON.parse(colRow.models);
    decks  = JSON.parse(colRow.decks);
  }catch(e){
    alert('Failed to read collection metadata: ' + (e && e.message || e));
    setStatus('Collection metadata read failed.');
    return;
  }

  try{
    const nRes = db.exec(`SELECT id,guid,mid,flds,sfld,tags FROM notes`)[0];
    if(nRes){
      for(const v of nRes.values){
        const obj = {};
        nRes.columns.forEach((c,i)=>obj[c]=v[i]);
        notes.push(obj);
      }
    }
  }catch(e){
    alert('Failed to read notes table: ' + (e && e.message || e));
    setStatus('Notes read failed.');
    return;
  }

  try{
    const cRes = db.exec(`SELECT id,nid,did,ord,type,queue,due,ivl FROM cards`)[0];
    if(cRes){
      for(const v of cRes.values){
        const obj = {};
        cRes.columns.forEach((c,i)=>obj[c]=v[i]);
        cards.push(obj);
      }
    }
  }catch(e){
    alert('Failed to read cards table: ' + (e && e.message || e));
    setStatus('Cards read failed.');
    return;
  }

  // populate global
  G.entries = entries;
  G.fileTable = fileTable;
  G.mediaMap = mediaMap;
  G.replaceMedia = replaceMedia;
  G.decks = decks;
  G.models = models;
  G.notes = notes;
  G.cards = cards;
  G.notesById = {};
  for(const n of notes) G.notesById[n.id] = n;

  const deckCount = Object.keys(decks).length;
  els.deckInfo.innerHTML =
    `<strong>Loaded deck:</strong> ${file.name} · ` +
    `${deckCount} deck${deckCount===1?'':'s'} · ` +
    `${cards.length} cards · ${notes.length} notes`;
  setStatus('Ready. Click “Export TXT” to generate a text file.');
  els.exportBtn.disabled = cards.length === 0;
});

/* ===== export logic ===== */

els.exportBtn.addEventListener('click', async ()=>{
  if(!G.cards.length){
    alert('No cards found in this deck.');
    return;
  }

  els.exportBtn.disabled = true;
  setStatus('Rendering cards (this may take a moment for large decks)...');

  // Give the UI a chance to repaint
  await new Promise(r => setTimeout(r, 20));

  const cardsSorted = G.cards.slice().sort((a,b)=> (a.id || 0) - (b.id || 0));
  const lines = [];
  const strip = els.stripHtml.checked;
  const includeIds = els.includeIds.checked;

  let firstPreview = null;

  let idx = 0;
  for(const card of cardsSorted){
    idx++;
    const rendered = renderCardFrontBack(card);
    if(!rendered) continue;

    let front = rendered.front;
    let back  = rendered.back;

    if(strip){
      front = htmlToPlainText(front);
      back  = htmlToPlainText(back);
    }

    const cardLines = [];
    if(includeIds){
      cardLines.push(
        `Card ${idx} (card_id: ${card.id}, note_id: ${card.nid})`
      );
    }else{
      cardLines.push(`Card ${idx}`);
    }
    cardLines.push('');
    cardLines.push('FRONT:');
    cardLines.push(front || '(empty)');
    cardLines.push('');
    cardLines.push('BACK:');
    cardLines.push(back || '(empty)');

    lines.push(cardLines.join('\n'));

    if(!firstPreview){
      firstPreview = cardLines.join('\n');
    }

    if(idx % 250 === 0){
      setStatus(`Rendering cards... (${idx}/${cardsSorted.length})`);
      await new Promise(r => setTimeout(r, 0));
    }
  }

  const out = lines.join('\n\n-----\n\n');
  const blob = new Blob([out], { type:'text/plain;charset=utf-8' });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url;
  a.download = 'anki-front-back.txt';
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 2000);

  // Preview first card
  if(firstPreview){
    els.previewBody.textContent = firstPreview;
    els.preview.style.display = 'block';
  }

  setStatus(`Exported ${cardsSorted.length} cards to text.`);
  els.exportBtn.disabled = false;
});
</script>
</body>
</html>