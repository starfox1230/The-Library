<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Epic Space Invaders (Phaser 3)</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    body { margin:0; background:#000; }
    #game { width:100vw; height:100vh; }
  </style>
</head>
<body>
  <div id="game"></div>
  <script>
  const CONFIG = {
    type: Phaser.AUTO,
    parent: 'game',
    backgroundColor: '#000',
    scale: {
      mode: Phaser.Scale.FIT,
      autoCenter: Phaser.Scale.CENTER_BOTH,
      width: 960,
      height: 540,
    },
    physics: {
      default: 'arcade',
      arcade: { debug: false }
    },
    scene: {
      preload, create, update
    }
  };

  const game = new Phaser.Game(CONFIG);

  let player, cursors, fireKey, startKey;
  let bullets, invaders, scoreText, levelText;
  let score = 0, level = 1, canShoot = true;
  let gameState = 'start';

  function preload() {
    // nothing to load—textures will be generated
  }

  function create() {
    const { width, height } = this.scale;

    // generate simple textures
    this.add.graphics()
      .fillStyle(0x00ffff).fillRect(0,0,40,20)
      .generateTexture('player',40,20).clear();
    this.add.graphics()
      .fillStyle(0x44ff44).fillRect(0,0,40,20)
      .generateTexture('invader',40,20).clear();

    // stars background via tileSprite
    this.add.tileSprite(0,0,width,height, null)
      .setOrigin(0)
      .setFillStyle(0)
      .setPipeline('Light2D');

    // player sprite + physics
    player = this.physics.add.sprite(width/2, height-40, 'player')
      .setCollideWorldBounds(true);
    player.body.setSize(40,20);

    // groups
    bullets = this.physics.add.group();
    invaders = this.physics.add.group();
    spawnInvaders.call(this);

    // HUD
    scoreText = this.add.text(10,10,'Score: 0',{ font:'18px monospace', fill:'#0f0' });
    levelText = this.add.text(width-120,10,'Level: 1',{ font:'18px monospace', fill:'#0f0' });

    // keyboard
    cursors = this.input.keyboard.createCursorKeys();
    fireKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.RIGHT);
    startKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

    // gamepad
    this.input.gamepad.once('connected', pad => {
      console.log('Gamepad connected:', pad.id);
    });

    // collisions
    this.physics.add.overlap(bullets, invaders, (b, inv) => {
      inv.disableBody(true,true);
      b.destroy();
      score += 10; scoreText.setText('Score: '+score);
      if (invaders.countActive()===0) {
        gameState = 'levelcleared';
      }
    });

    this.physics.world.on('worldbounds', body => {
      if (body.gameObject === player) {
        // nothing
      }
    });

    // disable auto-restart of bullet offscreen
    this.physics.world.on('worldbounds', (body) => {
      if (body.gameObject.texture.key === 'bullet') body.gameObject.destroy();
    });
  }

  function spawnInvaders() {
    invaders.clear(true,true);
    for (let row=0; row<4; row++) {
      for (let col=0; col<8; col++) {
        let x = 60 + col*55;
        let y = 60 + row*35;
        invaders.create(x,y,'invader').setOrigin(0).setImmovable(true);
      }
    }
    // invader motion tween
    this.tweens.timeline({
      targets: invaders.getChildren(),
      loop: -1,
      ease: 'Linear',
      tweens: [
        { x: '+=200', duration: 2000 - (level-1)*200 },
        { y: '+=10', duration: 200 },
        { x: '-=200', duration: 2000 - (level-1)*200 },
        { y: '+=10', duration: 200 }
      ]
    });
  }

  function update() {
    const pad = this.input.gamepad.getPad(0);

    // handle start / restart / next level
    if (gameState!=='playing') {
      if ((pad && pad.buttons[9].pressed) || Phaser.Input.Keyboard.JustDown(startKey)) {
        if (gameState==='gameover' || gameState==='start') {
          score = 0; level = 1;
        }
        if (gameState==='levelcleared') {
          level++;
        }
        scoreText.setText('Score: '+score);
        levelText.setText('Level: '+level);
        spawnInvaders.call(this);
        player.setPosition(this.scale.width/2, this.scale.height-40);
        bullets.clear(true,true);
        gameState='playing';
      }
      // draw overlay text
      drawOverlay.call(this);
      return;
    }

    // movement (left/right only)
    const left  = (pad && (pad.axes[0]<-0.5 || pad.buttons[14].pressed)) || cursors.left.isDown;
    const right = (pad && (pad.axes[0]>0.5  || pad.buttons[15].pressed)) || cursors.right.isDown;
    if (left)  player.x -= 200 * this.game.loop.delta/1000;
    if (right) player.x += 200 * this.game.loop.delta/1000;

    // fire
    const firing = (pad && pad.buttons[3].pressed) || fireKey.isDown;
    if (firing && canShoot) {
      let b = bullets.create(player.x, player.y-10, null)
        .setDisplaySize(4,10)
        .setTint(0xffffff);
      b.body.setVelocityY(-400);
      canShoot=false;
    }
    if (!firing) canShoot=true;

    // check game over: invader too low
    invaders.getChildren().forEach(inv => {
      if (inv.active && inv.y + inv.height > player.y) {
        gameState = 'gameover';
      }
    });

    levelText.setText('Level: '+level);
  }

  function drawOverlay() {
    const { width, height } = this.scale;
    const lines = {
      start: ['SPACE INVADERS','Press START or SPACE to Play'],
      levelcleared: [`LEVEL ${level} CLEARED!`,'Press START to Continue'],
      gameover: ['GAME OVER', `Score: ${score}`, 'Press START to Restart']
    }[gameState];
    this.add.rectangle(width/2,height/2,600,300,0x000000,0.6).setDepth(10);
    lines.forEach((l,i)=>{
      this.add.text(width/2, height/2 + i*50 - 50, l, {
        font:'36px monospace', fill: gameState==='gameover'? '#f00':'#fff'
      }).setOrigin(0.5).setDepth(11);
    });
  }
  </script>
</body>
</html>