<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>APKG → Lightning Drill (Mirror Mode)</title>
<style>
  :root{
    --bg:#0b0f14; --fg:#e8f0ff; --muted:#9bb0d0; --accent:#4ea1ff;
    --purple:#6c5ce7; --good:#25d366; --bad:#ff4d6d; --panel:#121826; --panel2:#0f1522; --stroke:#243042;
    --header-h:64px; /* will be measured in JS */
  }
  *{ box-sizing:border-box }
  html,body{height:100%}
  body{
    margin:0; background:#000; color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    overflow:hidden; /* page doesn't scroll; card panes do */
  }

  /* Animated background */
  #bgfx, #bgfx2{
    position:fixed; inset:0; z-index:-2; pointer-events:none; filter:blur(40px) saturate(120%);
    background:
      radial-gradient(1200px 600px at 10% 20%, #113a71 0%, transparent 60%),
      radial-gradient(1000px 600px at 90% 80%, #360f5b 0%, transparent 60%),
      linear-gradient(180deg, #070b12 0%, #0a1020 100%);
    animation:bgpan 18s linear infinite alternate;
  }
  #bgfx2{
    mix-blend-mode:screen; opacity:.7; filter:blur(60px) saturate(160%);
    background:
      radial-gradient(700px 500px at 70% 20%, #0064ff 0%, transparent 60%),
      radial-gradient(700px 500px at 30% 80%, #a000ff 0%, transparent 60%);
    animation:bgpan2 22s linear infinite alternate;
  }
  @keyframes bgpan { to{ transform:translate3d(0,8%,0) } }
  @keyframes bgpan2{ to{ transform:translate3d(0,-6%,0) } }

  /* Fixed header so we can measure and offset main dynamically */
  header{
    position:fixed; top:0; left:0; right:0; z-index:10;
    display:flex; gap:12px; align-items:center; flex-wrap:wrap;
    padding:12px 14px; border-bottom:1px solid #0f1a2a;
    background:linear-gradient(180deg, rgba(10,16,28,.7), rgba(10,16,28,.25));
    backdrop-filter:blur(8px);
  }
  input[type=file]{ background:#0e1522; border:1px solid #1c2a3f; color:var(--fg); padding:8px; border-radius:10px }
  button, .btn{
    border:0; padding:10px 14px; border-radius:12px; background:var(--accent); color:#fff; font-weight:700; cursor:pointer;
    box-shadow:0 6px 18px rgba(78,161,255,.25);
  }
  button.small{ padding:8px 10px; font-size:12px; background:#2b6cb0 }
  button.ghost{ background:#0f1522; color:var(--fg); border:1px solid #263246; box-shadow:none }
  button.good{ background:var(--good) } button.bad{ background:var(--bad) }
  button:active{ transform:translateY(1px) }
  .tag{ font-size:12px; opacity:.85; color:var(--muted) }
  .sep{ width:1px; height:28px; background:#1b283d; margin:0 6px }

  #hud{ margin-left:auto; display:flex; gap:10px; align-items:center; flex-wrap:wrap; min-width:0 }
  /* Timer label never wraps; JS will shrink font to fit if needed */
  #timerLabel{
    padding:6px 10px; border-radius:10px; background:#0f1522; border:1px solid #1f2b40; font-weight:700;
    white-space:nowrap; overflow:hidden; text-overflow:clip; flex:0 1 auto; max-width:40vw;
  }
  #stats{ padding:6px 10px; border-radius:10px; background:#0f1522; border:1px solid #1f2b40; font-weight:700 }
  #stats small{ font-weight:600; color:var(--muted) }

  main{
    position:fixed; top:var(--header-h); left:0; right:0; bottom:0;
    display:grid; place-items:center;
    padding:18px max(12px, env(safe-area-inset-right)) 18px max(12px, env(safe-area-inset-left));
  }

  #cardWrap{ width:100%; display:flex; justify-content:center; }

  #card{
    width: min(900px, calc(100vw - 24px)); /* tighter for mobile */
    min-height:48vh;
    background:linear-gradient(180deg, var(--panel), var(--panel2));
    border:1px solid var(--stroke); border-radius:18px; padding:22px;
    box-shadow:0 30px 80px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.02);
    display:flex; flex-direction:column; gap:16px;
    position:relative; overflow:hidden; /* lock box shape; content panes scroll */
    touch-action:manipulation;
  }

  /* Per-side timer bar (shrinks + changes color) */
  #timerBarWrap{ height:8px; background:#102035; border-radius:999px; overflow:hidden; border:1px solid #22324d; margin-left:8px }
  #timerBar{ height:100%; width:100%; background:#27d3ff; }

  #flash{ position:absolute; inset:0; border-radius:18px; pointer-events:none; opacity:0; }
  .flash-anim{ animation:flash .35s ease }
  @keyframes flash{ 0%{opacity:0} 25%{opacity:.45} 100%{opacity:0} }

  #subhud{ display:flex; justify-content:space-between; align-items:center; gap:10px }
  #title{ font-weight:700; color:#cfe2ff; opacity:.9; letter-spacing:.3px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }

  /* Content areas scroll to preserve card box; iOS-friendly */
  #front, #back{
    flex:1 1 auto; min-height:0;
    overflow:auto; font-size:22px; line-height:1.45;
    -webkit-overflow-scrolling:touch; overscroll-behavior:contain; touch-action:pan-y;
  }
  #back{ display:none }

  #front img, #back img,
  #front video, #back video,
  #front iframe, #back iframe,
  #front audio, #back audio {
    max-width:100%; height:auto; display:block;
    max-height:60vh; /* hard cap so media never expands the box */
    object-fit:contain;
  }
  #front table, #back table{ max-width:100%; overflow:auto; display:block }

  /* Cloze styling (purple & bold before AND after reveal) */
  .cloze, .cloze-reveal, .cloze .cloze-mask, .cloze .cloze-answer{
    color:var(--purple); font-weight:700;
  }
  .cloze{ cursor:pointer; border-bottom:1px dashed var(--purple) }

  #controls{ display:flex; gap:12px; flex-wrap:wrap; justify-content:center }
  #reveal{ background:var(--purple) }

  /* Drawer (Missed/Correct) — silently pauses; no overlay */
  #drawer{
    position:fixed; top:var(--header-h); right:0; width:min(560px, 94vw); height:calc(100% - var(--header-h));
    background:linear-gradient(180deg, #0f1522, #0c1220); border-left:1px solid #22324d;
    transform:translateX(100%); transition:transform .25s ease; z-index:9; display:flex; flex-direction:column;
  }
  #drawer.open{ transform:none }
  #drawer header{ border-bottom:1px solid #22324d; display:flex; gap:10px; align-items:center; justify-content:space-between }
  #drawer .tabs{ display:flex; gap:6px; padding-left:6px }
  #drawer .tabs button{ background:#172037 }
  #drawer .tabs button.sel{ outline:2px solid #4ea1ff }
  #list{ padding:12px; overflow:auto; display:grid; gap:10px }
  .listItem{
    background:#0f1627; border:1px solid #22324d; border-radius:12px; padding:12px; font-size:14px; line-height:1.35
  }
  .listItem .front{ font-weight:700; color:#d7e7ff; margin-bottom:6px }
  .listItem .back{ color:#b9c9e4 }

  /* Start modal + Summary */
  .overlay{
    position:fixed; inset:0; backdrop-filter:blur(10px); display:flex; align-items:center; justify-content:center;
    background:rgba(5,10,18,.6); z-index:11;
  }
  .sheet{
    width:min(760px, 94vw); background:linear-gradient(180deg, #10182a, #0b1324);
    border:1px solid #22324d; border-radius:16px; padding:18px; box-shadow:0 30px 80px rgba(0,0,0,.45);
  }
  .optRow{ display:flex; gap:10px; flex-wrap:wrap; margin:10px 0 6px }
  .field{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .field input{ width:86px; background:#0e1522; border:1px solid #22324d; color:var(--fg); padding:8px; border-radius:10px }
  .sheet h2{ margin:0 0 8px 0 }
  .sheet p{ margin:6px 0 10px 0; color:#b9c9e4 }

  #pausedBanner{ /* only shown when the user hits Pause button, not for drawer */
    position:fixed; inset:0; z-index:12; display:none; align-items:center; justify-content:center; color:#fff;
    background:rgba(10,14,24,.6); backdrop-filter:blur(6px);
  }
  #pausedBanner .tag{ font-size:18px }
  #pausedBanner .big{ font-size:42px; font-weight:900; margin-top:4px }

  #debug{ display:none; position:fixed; left:12px; bottom:38px; font-size:12px; white-space:pre-wrap; background:#0d1626; border:1px solid #1e2c44; color:#cae8ff; padding:10px; border-radius:10px; max-width:min(70ch,92vw); z-index:12 }
  #log{ position:fixed; left:12px; bottom:10px; font-size:12px; opacity:.8; z-index:12 }

  @media (max-width:700px){
    #front,#back{ font-size:18px }
    #card{ min-height:50vh }
    #timerLabel{ max-width:50vw }
  }
</style>
</head>
<body>
<div id="bgfx"></div><div id="bgfx2"></div>

<header>
  <input id="file" type="file" accept=".apkg,.colpkg" />
  <button id="showStart" class="ghost" disabled>Configure & Start</button>
  <button id="toggleMiss" class="ghost">Missed (0)</button>
  <button id="toggleGot" class="ghost">Correct (0)</button>
  <div class="sep"></div>
  <button id="pauseBtn" class="ghost" disabled>Pause</button>
  <div id="hud">
    <div id="timerLabel" aria-live="polite">⏱️ —</div>
    <div id="stats"><small>Seen</small> <b id="seen">0</b> · <small>Got</small> <b id="got">0</b> · <small>Missed</small> <b id="miss">0</b></div>
  </div>
</header>

<main>
  <div id="cardWrap">
    <div id="card" aria-live="polite" aria-atomic="true">
      <div id="flash"></div>
      <div id="subhud">
        <div id="title">Load a deck to begin</div>
        <div id="timerBarWrap" style="flex:1"><div id="timerBar"></div></div>
      </div>
      <div id="front">(front)</div>
      <div id="back">(back)</div>
      <div id="controls">
        <button id="reveal" class="btn">Reveal (Space)</button>
        <button id="badBtn" class="btn bad">Missed (←)</button>
        <button id="goodBtn" class="btn good">Got it (→)</button>
      </div>
    </div>
  </div>
</main>

<!-- Drawer (Missed / Correct) — silently pauses in background; no overlay -->
<aside id="drawer" aria-label="Items list">
  <header>
    <div style="display:flex;align-items:center;gap:10px;padding-left:8px">
      <div class="tabs">
        <button id="tabMiss" class="small sel">Missed</button>
        <button id="tabGot" class="small">Correct</button>
      </div>
      <span class="tag" id="listCount">0 items</span>
    </div>
    <div style="display:flex;gap:8px;align-items:center;padding-right:8px">
      <button id="exportList" class="ghost small">Export CSV</button>
      <button id="studyList" class="small">Study This Only</button>
      <button id="closeDrawer" class="ghost small">Close</button>
    </div>
  </header>
  <div id="list"></div>
</aside>

<!-- Start Modal -->
<div id="startOverlay" class="overlay" style="display:none">
  <div class="sheet">
    <h2>Lightning Drill — Per-Card Timers</h2>
    <p>Front auto-reveals at 0; Back auto-advances (as Missed) at 0. “Mirror Anki order” builds an Anki-like daily queue (only due + limits + new order + bury siblings).</p>
    <div class="field">
      <label for="frontSec"><b>Front time</b></label>
      <input id="frontSec" type="number" min="1" value="12" /> <span class="tag">seconds</span>
    </div>
    <div class="field">
      <label for="backSec"><b>Back time</b></label>
      <input id="backSec" type="number" min="1" value="8" /> <span class="tag">seconds</span>
    </div>
    <div class="field">
      <input id="mirrorToggle" type="checkbox" checked />
      <label for="mirrorToggle"><b>Mirror Anki order (recommended)</b></label>
    </div>
    <div class="optRow" style="margin-top:12px">
      <button id="startBtn">Start</button>
      <button id="cancelStart" class="ghost">Cancel</button>
    </div>
    <div class="tag" id="deckInfo">No deck loaded</div>
  </div>
</div>

<!-- Paused Overlay (only when user explicitly clicks Pause) -->
<div id="pausedBanner" class="overlay">
  <div style="text-align:center">
    <div class="tag">Session paused</div>
    <div class="big">⏸️</div>
    <div class="optRow" style="justify-content:center;margin-top:12px">
      <button id="resumeBtn">Resume (P)</button>
    </div>
  </div>
</div>

<!-- Summary -->
<div id="summary" class="overlay" style="display:none">
  <div class="sheet">
    <h2>All Cards Complete</h2>
    <p><b><span id="sumSeen">0</span></b> seen · <b><span id="sumGot">0</span></b> got · <b><span id="sumMiss">0</span></b> missed</p>
    <div class="optRow">
      <button id="restartBtn">Restart</button>
      <button id="missOnlyBtn" class="ghost">Study Missed Only</button>
      <button id="closeSummary" class="ghost">Close</button>
    </div>
  </div>
</div>

<!-- Logs -->
<div id="debug"></div>
<div id="log"></div>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/sql-wasm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/protobufjs@7.3.0/dist/protobuf.min.js"></script>
<script>
/* ========== Helpers / UI ========== */
const $ = sel => document.querySelector(sel);
const logEl=$('#log'), dbgEl=$('#debug');
function log(s){ logEl.textContent=s }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)) }
function stripHtml(s){ const d=document.createElement('div'); d.innerHTML=s; return d.textContent||d.innerText||'' }
function sanitize(html){ return String(html).replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi,'') }
function colorFor(p){ // 1 -> teal/green, 0 -> red
  const start=170, end=0; const h = end + (start - end) * p;
  return `hsl(${h}, 95%, 55%)`;
}

/* ========== Header sizing & timer fit ========== */
function measureHeader(){
  const h = Math.ceil(document.querySelector('header').getBoundingClientRect().height);
  document.documentElement.style.setProperty('--header-h', h+'px');
}
let lastTimerText = '';
function fitTimer(){
  const el = els.timerLabel;
  const maxPx = 16, minPx = 10;
  el.style.fontSize = maxPx + 'px'; // Reset to max
  let loops=0;
  while(el.scrollWidth > el.clientWidth && parseFloat(el.style.fontSize) > minPx && loops < 16){
    el.style.fontSize = (parseFloat(el.style.fontSize) - 0.5) + 'px'; // shrink
    loops++;
  }
}

/* ========== Global state ========== */
let SQLReady=false, SQL;
let G = {
  entries:null, fileTable:{}, mediaMap:{}, replaceMedia:(h)=>h,
  decks:{}, models:{}, notes:[], cards:[],
  queue:[], idx:0, seen:0, got:0, missed:[], correct:[],
  frontMs:12000, backMs:8000, side:'front', sideMsLeft:0, running:false, paused:false,
  lastTick:0, rafId:0, isClozeByMid:{}, useMirror:true,
  nowSec:0, crt:0, today:0, dayCutoffSec:4*3600
};

/* elements */
const els={
  file:$('#file'), showStart:$('#showStart'), startOverlay:$('#startOverlay'),
  frontSec:$('#frontSec'), backSec:$('#backSec'), mirrorToggle:$('#mirrorToggle'),
  startBtn:$('#startBtn'), cancelStart:$('#cancelStart'), deckInfo:$('#deckInfo'),
  card:$('#card'), flash:$('#flash'),
  front:$('#front'), back:$('#back'),
  reveal:$('#reveal'), goodBtn:$('#goodBtn'), badBtn:$('#badBtn'),
  title:$('#title'), timerLabel:$('#timerLabel'), timerBar:$('#timerBar'),
  seen:$('#seen'), got:$('#got'), miss:$('#miss'),
  pauseBtn:$('#pauseBtn'), pausedBanner:$('#pausedBanner'), resumeBtn:$('#resumeBtn'),
  drawer:$('#drawer'), tabMiss:$('#tabMiss'), tabGot:$('#tabGot'),
  toggleMiss:$('#toggleMiss'), toggleGot:$('#toggleGot'),
  list:$('#list'), listCount:$('#listCount'), exportList:$('#exportList'), studyList:$('#studyList'), closeDrawer:$('#closeDrawer'),
  summary:$('#summary'), sumSeen:$('#sumSeen'), sumGot:$('#sumGot'), sumMiss:$('#sumMiss'),
  restartBtn:$('#restartBtn'), missOnlyBtn:$('#missOnlyBtn'), closeSummary:$('#closeSummary')
};
let drawerMode='miss';

/* ========== sql.js ========== */
initSqlJs({ locateFile: f => `https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/${f}` })
.then(db => { SQL=db; SQLReady=true })
.catch(e => alert('Failed to load SQLite (sql.js). Refresh and try again.\n'+e?.message));

/* ========== Unzip + media parsing ========== */
function unzipWithWatchdog(buf, timeoutMs=20000){
  return new Promise((resolve, reject) => {
    let done=false; const to=setTimeout(()=>{ if(!done){done=true; reject(new Error('Unzip timeout'))}}, timeoutMs);
    try{
      fflate.unzip(buf, {consume:true}, (err,obj)=>{
        if(done) return; clearTimeout(to);
        if(err){ done=true; reject(err) } else { done=true; resolve(obj) }
      });
    }catch(e){ clearTimeout(to); reject(e) }
  });
}
function looksGzip(b){ return b.length>2 && b[0]===0x1F && b[1]===0x8B }
function looksZstd(b){ return b.length>4 && ((b[0]===0xFD&&b[1]===0x2F&&b[2]===0xB5&&b[3]===0x28)||(b[0]===0x28&&b[1]===0xB5&&b[2]===0x2F&&b[3]===0xFD)) }
function loadScript(url){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=url; s.onload=res; s.onerror=()=>rej(new Error('Failed '+url)); document.head.appendChild(s) }) }
async function maybeDecompress(bytes){
  if(bytes[0]===0x7B) return bytes;
  if(looksGzip(bytes)) return fflate.gunzipSync(bytes);
  if(looksZstd(bytes)){
    if(!window.ZstdCodec) await loadScript('https://cdn.jsdelivr.net/npm/zstd-codec@0.1.4/dist/zstd-codec.min.js');
    return await new Promise((resolve,reject)=>{
      window.ZstdCodec.run(zstd=>{
        try{ const out = new zstd.Simple().decompress(bytes); resolve(out) }catch(e){ reject(e) }
      })
    })
  }
  return bytes;
}
function parseMediaJSON(txt){
  if (txt.charCodeAt(0)===0xFEFF) txt=txt.slice(1);
  const first=txt.indexOf('{'), last=txt.lastIndexOf('}');
  if(first<0||last<0||last<=first) throw new Error('No JSON object in media file');
  txt=txt.slice(first,last+1).replace(/,\s*([}\]])/g,'$1').replace(/[\u0000-\u0008\u000B-\u000C\u000E-\u001F]/g,'')
                             .replace(/([{,]\s*)(\d+)(\s*:)/g,'$1"$2"$3');
  return JSON.parse(txt);
}
async function decodeProtoMedia(bytes){
  const urls=[ "https://cdn.jsdelivr.net/gh/ankitects/anki@stable/proto/anki/import_export.proto", "https://cdn.jsdelivr.net/gh/ankitects/anki@main/proto/anki/import_export.proto" ];
  let root=null; for(const u of urls){ try{ const r=await fetch(u,{cache:'force-cache'}); if(!r.ok) continue; root=protobuf.parse(await r.text()).root; break }catch{} }
  if(!root) throw new Error('proto load failed');
  function toMap(obj){
    for(const v of Object.values(obj||{})){
      if(Array.isArray(v)&&v.length&&typeof v[0]==='object'){
        const hasIdx=('index'in v[0])||('id'in v[0]); const hasNm=('filename'in v[0])||('name'in v[0]);
        if(hasIdx&&hasNm){ const m={}; for(const it of v){ const k=(it.index??it.id); const nm=(it.filename??it.name); if(k!=null&&typeof nm==='string') m[String(k)]=nm } return m }
      }
    }
    return null;
  }
  const all=[];(function walk(ns){ for(const k of Object.keys(ns.nested||{})){ const v=ns.nested[k]; if(v.fields) all.push(v); if(v.nested) walk(v) } })(root);
  for(const T of all){ try{ const msg=T.decode(bytes); const map=toMap(msg); if(map) return map }catch{} }
  throw new Error('unknown media map');
}
async function parseMediaEntry(entryBytes){
  const td=new TextDecoder('utf-8',{fatal:false});
  let bytes=await maybeDecompress(entryBytes);
  if(bytes[0]===0x7B){ return parseMediaJSON(td.decode(bytes)) }
  try{ return await decodeProtoMedia(bytes) }catch(e){ console.warn('media map parse failed',e); return {} }
}
function mediaURLForKey(key, files){ const bytes=files[key]; if(!bytes) return null; return URL.createObjectURL(new Blob([bytes],{type:'application/octet-stream'})) }
function buildMediaReplacer(mediaMap, files){
  const reverse={}; for(const [k,v] of Object.entries(mediaMap)) reverse[v]=k;
  const imgRE=/<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
  const audioRE=/\[sound:([^\]]+)\]/gi;
  function resolve(src){
    if(/^\d+$/.test(src)){ const u=mediaURLForKey(src,files); if(u) return u }
    let u=mediaURLForKey(src,files); if(u) return u;
    const idx=reverse[src]; if(idx!==undefined){ u=mediaURLForKey(idx,files); if(u) return u }
    return null;
  }
  return function replaceAll(html){
    html=html.replace(imgRE,(m,src)=>{ const u=resolve(src); return u? m.replace(src,u):m });
    html=html.replace(audioRE,(m,name)=>{ const u=resolve(name); return u? `<audio controls preload="metadata" src="${u}"></audio>`:m });
    return html;
  }
}

/* ========== Cloze templating ========== */
function processClozeForOrd(text, targetIndex, side){
  return String(text).replace(/\{\{c(\d+)::([\s\S]*?)(?:::(.*?))?\}\}/g,(m,n,inner,hint)=>{
    const idx=parseInt(n,10);
    const safeInner = (inner||'').replace(/</g,'&lt;');
    const safeHint  = (hint||'').replace(/</g,'&lt;');
    if(idx===targetIndex){
      if(side==='front'){
        const mask = safeHint ? `[${safeHint}]` : `[...]`;
        return `<span class="cloze"><span class="cloze-mask">${mask}</span><span class="cloze-answer" style="display:none">${safeInner}</span></span>`;
      }else{
        return `<span class="cloze-reveal">${safeInner}</span>`;
      }
    }
    return safeInner;
  });
}
function applyConditionals(tpl, fields, fieldNames){
  tpl=tpl.replace(/\{\{#([^}]+)\}\}([\s\S]*?)\{\{\/\1\}\}/g,(m,name,inner)=>{
    const idx=fieldNames.indexOf(name.trim()); const val=idx>=0?fields[idx]:''; return String(val).trim()? inner : '';
  });
  tpl=tpl.replace(/\{\{\^([^}]+)\}\}([\s\S]*?)\{\{\/\1\}\}/g,(m,name,inner)=>{
    const idx=fieldNames.indexOf(name.trim()); const val=idx>=0?fields[idx]:''; return String(val).trim()? '' : inner;
  });
  return tpl;
}
function stripClozeMarkup(s){ return String(s).replace(/\{\{c\d+::([\s\S]*?)(?:::[^}]*)?\}\}/g,'$1') }
function collectClozeFieldsFromTemplate(tpl){
  const set=new Set(); tpl.replace(/\{\{([^}]+)\}\}/g,(_m,token)=>{
    const parts=token.trim().split(':'); const field=parts.pop().trim();
    const chain=parts.map(p=>p.trim().toLowerCase());
    if(chain.includes('cloze')) set.add(field);
  }); return set;
}
function substituteTokens(tpl, fields, fieldNames, { side, targetCloze, templateForScan }){
  const clozeFields=collectClozeFieldsFromTemplate(templateForScan||tpl);
  return tpl.replace(/\{\{([^}]+)\}\}/g,(m,raw)=>{
    const token=raw.trim(); if(token==='FrontSide') return '{{FrontSide}}';
    const parts=token.split(':'); const fieldName=parts.pop().trim();
    const chain=parts.map(p=>p.trim().toLowerCase());
    const idx=fieldNames.indexOf(fieldName); const val=idx>=0?(fields[idx]??''):'';
    const hasCloze=chain.includes('cloze'); const hasType=chain.includes('type');
    const hasText=chain.includes('text') || chain.includes('hint');
    if(hasCloze) return processClozeForOrd(val, targetCloze, side);
    if(hasType)  return `<input class="type-answer" aria-label="type your answer" style="padding:6px 8px;border:1px solid #334;border-radius:6px;background:#0e1522;color:#eee" />`;
    if(hasText){ if(clozeFields.has(fieldName)) return ''; return stripClozeMarkup(val) }
    if(clozeFields.has(fieldName)) return '';
    return val;
  });
}
function collapseExactDuplicate(html){
  const lines=String(html).split(/(?:\r?\n|<br\s*\/?>)+/i).map(s=>s.trim()).filter(Boolean);
  const seen=new Set(), keep=[];
  for(const line of lines){ const key=line.replace(/\s+/g,' '); if(!seen.has(key)){ seen.add(key); keep.push(line) } }
  return keep.join('<br>');
}

/* ========== Game engine ========== */
function updateCounts(){
  els.seen.textContent=G.seen; els.got.textContent=G.got; els.miss.textContent=G.missed.length;
  els.toggleMiss.textContent = `Missed (${G.missed.length})`;
  els.toggleGot.textContent  = `Correct (${G.correct.length})`;
  measureHeader(); // header height can change as counts grow
}
function setTimerBarFrac(frac){
  const p = clamp(frac, 0, 1);
  els.timerBar.style.width = (p*100).toFixed(2)+'%';
  const c = colorFor(p);
  els.timerBar.style.background = c;
}
function setSideLabel(){
  const secLeft = Math.ceil(G.sideMsLeft/1000);
  const text = `⏱️ ${G.side==='front' ? 'Front' : 'Back'} ${String(secLeft).padStart(2,'0')}s`;
  if(text !== lastTimerText){
    els.timerLabel.textContent = text;
    lastTimerText = text;
    fitTimer();
  }
}
function flash(color){
  els.flash.style.background = color;
  els.flash.classList.remove('flash-anim'); void els.flash.offsetWidth;
  els.flash.classList.add('flash-anim');
}
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]] } }

/* ===== Mirror Mode: approximate Anki queue building ===== */
function computeToday(nowSec, crt, cutoffSec){
  const DAY=86400;
  return Math.floor((nowSec - cutoffSec)/DAY) - Math.floor((crt - cutoffSec)/DAY);
}
function buildAnkiLikeQueue(cards, decksById){
  const nowSec = G.nowSec, today = G.today;
  const learnNow   = cards.filter(c => c.queue===1 && c.due <= nowSec).sort((a,b)=>a.due-b.due || a.id-b.id);
  const learnToday = cards.filter(c => c.queue===3 && c.due <= today).sort((a,b)=>a.due-b.due || a.id-b.id);
  let reviews      = cards.filter(c => c.queue===2 && c.due <= today);
  let news         = cards.filter(c => c.queue===0 || c.type===0);
  if (reviews.length){
    const groups = new Map();
    for (const c of reviews){ (groups.get(c.due)||groups.set(c.due,[]).get(c.due)).push(c); }
    reviews = Array.from([...groups.keys()].sort((a,b)=>a-b))
      .flatMap(k => { const g=groups.get(k); shuffle(g); return g });
  }
  news.sort((a,b)=>{
    const da=(decksById[a.did]||'').localeCompare(decksById[b.did]||''); if(da) return da;
    return (a.due - b.due) || (a.id - b.id);
  });
  const newPerDay=20, revPerDay=200;
  news = news.slice(0,newPerDay);
  reviews = reviews.slice(0,revPerDay);
  const seenNote=new Set();
  const bury = arr => arr.filter(c => seenNote.has(c.nid)? false : (seenNote.add(c.nid), true));
  const ReviewsQ = bury(reviews);
  const NewsQ    = bury(news);
  return [...learnNow, ...ReviewsQ, ...learnToday, ...NewsQ];
}

/* ===== Render current card ===== */
function renderCurrent(){
  if(!G.queue.length){ finishSession(); return }
  const card = G.queue[G.idx];
  const note = G.notes.find(n=>n.id===card.nid); if(!note){ nextCard(false); return }
  const model = G.models[String(note.mid)]; if(!model){ nextCard(false); return }
  const fieldNames=(model?.flds||[]).map(f=>f.name);
  const fields=(note.flds||'').split('\x1f');
  const tmpl=model?.tmpls?.[card.ord]; if(!tmpl){ nextCard(false); return }
  const target=card.ord+1;

  let front=tmpl.qfmt||'';
  front=applyConditionals(front,fields,fieldNames);
  front=substituteTokens(front,fields,fieldNames,{side:'front',targetCloze:target,templateForScan:tmpl.qfmt});
  front=sanitize(front); front=G.replaceMedia(front); front=collapseExactDuplicate(front);

  let back=tmpl.afmt||'';
  back=back.replace(/\{\{FrontSide\}\}/g, front);
  back=applyConditionals(back,fields,fieldNames);
  back=substituteTokens(back,fields,fieldNames,{side:'back',targetCloze:target,templateForScan:tmpl.afmt});
  back=sanitize(back); back=G.replaceMedia(back); back=collapseExactDuplicate(back);

  els.front.innerHTML=front || '<span class="tag">(empty front)</span>';
  els.back.innerHTML =back  || '<span class="tag">(empty back)</span>';
  els.front.style.display='block'; els.back.style.display='none';

  els.title.textContent=`${G.idx+1} / ${G.queue.length}`;
  G.side='front'; G.sideMsLeft=G.frontMs; setSideLabel(); setTimerBarFrac(1);
}

/* ===== Transitions & timing ===== */
function reveal(){
  if(els.back.style.display==='block' || !G.running) return;
  els.front.style.display='none';
  els.back.style.display='block';
  G.side='back'; G.sideMsLeft=G.backMs; setSideLabel(); setTimerBarFrac(1);
}
function nextCard(incrementSeen=true){
  if(incrementSeen) G.seen++;
  updateCounts();
  G.idx++;
  if(G.idx>=G.queue.length){ finishSession(); return }
  renderCurrent();
}
function handleAnswer(ok){
  if(G.side !== 'back' || !G.running) return;
  if(ok){
    G.got++;
    G.correct.push({ id:G.queue[G.idx].id, front:stripHtml(els.front.innerHTML), back:stripHtml(els.back.innerHTML) });
    flash('rgba(37,211,102,.35)');
  }else{
    G.missed.push({ id:G.queue[G.idx].id, front:stripHtml(els.front.innerHTML), back:stripHtml(els.back.innerHTML) });
    flash('rgba(255,77,109,.35)');
  }
  updateCounts();
  nextCard(true);
}
function handleTimeout(){
  if(G.side==='front'){ reveal() } else { handleAnswer(false) }
}
function loop(ts){
  if(!G.running) return;
  if(!G.paused){
    if(!G.lastTick) G.lastTick = ts;
    const dt = ts - G.lastTick; G.lastTick = ts;
    G.sideMsLeft -= dt; setSideLabel();
    setTimerBarFrac(G.sideMsLeft / (G.side==='front' ? G.frontMs : G.backMs));
    if(G.sideMsLeft <= 0){ handleTimeout(); G.lastTick = ts; }
  }
  G.rafId = requestAnimationFrame(loop);
}
function pause(showOverlay=true){
  if(!G.running || G.paused) return;
  G.paused=true;
  if(showOverlay) els.pausedBanner.style.display='flex';
}
function resume(){
  if(!G.running || !G.paused) return;
  G.paused=false; els.pausedBanner.style.display='none'; G.lastTick=0;
}
function openDrawer(mode){
  drawerMode=mode;
  els.tabMiss.classList.toggle('sel', mode==='miss');
  els.tabGot.classList.toggle('sel',  mode==='got');
  renderDrawer();
  els.drawer.classList.add('open');
  pause(false);
}
function closeDrawer(){ els.drawer.classList.remove('open'); resume() }
function renderDrawer(){
  const items = (drawerMode==='miss') ? G.missed : G.correct;
  els.list.innerHTML='';
  for(const m of items){
    const div=document.createElement('div'); div.className='listItem';
    div.innerHTML=`<div class="front">${m.front}</div><div class="back">${m.back}</div>`;
    els.list.appendChild(div);
  }
  els.listCount.textContent = `${items.length} item${items.length===1?'':'s'}`;
  els.studyList.textContent = `Study ${drawerMode==='miss'?'Missed':'Correct'} Only`;
}
function exportActiveListCSV(){
  const items = (drawerMode==='miss') ? G.missed : G.correct;
  const rows = [['card_id','front_text','back_text']];
  for(const m of items){
    rows.push([m.id, m.front.replace(/\s+/g,' ').trim(), m.back.replace(/\s+/g,' ').trim()]);
  }
  const csv = rows.map(r => r.map(v=>{
    const s=String(v??''); if(s.includes('"')||s.includes(',')||s.includes('\n')) return `"${s.replace(/"/g,'""')}"`; return s;
  }).join(',')).join('\n');
  const url=URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
  const a=document.createElement('a'); a.href=url; a.download=`${drawerMode}-cards.csv`; document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}
function buildQueueFromSettings(baseCards){
  if(!G.useMirror){
    const arr=baseCards.slice(); shuffle(arr); return arr;
  }
  const decksById={}; for(const [id,d] of Object.entries(G.decks)){ decksById[id] = d?.name || d?.nm || String(id) }
  return buildAnkiLikeQueue(baseCards, decksById);
}
function startSession(cardsSubset=null){
  G.running=true; G.paused=false; G.lastTick=0;
  const base = cardsSubset || G.cards;
  G.queue = buildQueueFromSettings(base);
  G.idx=0; renderCurrent();
  cancelAnimationFrame(G.rafId); G.rafId = requestAnimationFrame(loop);
  els.pauseBtn.disabled=false;
}
function finishSession(){
  G.running=false;
  cancelAnimationFrame(G.rafId);
  els.sumSeen.textContent=G.seen; els.sumGot.textContent=G.got; els.sumMiss.textContent=G.missed.length;
  els.summary.style.display='flex';
}

/* ========== File handling ========== */
els.file.addEventListener('change', async (e)=>{
  const file = e.target.files?.[0]; if(!file) return;
  if(!SQLReady){ alert('SQLite engine not ready yet.'); return }
  log('Reading file…');
  const buf = new Uint8Array(await file.arrayBuffer());
  if(!(buf[0]===0x50 && buf[1]===0x4b)){ alert('This does not look like a ZIP (.apkg/.colpkg).'); return }
  log('Unzipping…');
  let entries; try{ entries=await unzipWithWatchdog(buf, 20000) }catch(err){ alert('Unzip failed: '+err?.message); return }

  const dbEntry = entries['collection.anki21'] || entries['collection.anki21b'] || entries['collection.anki2'];
  if(!dbEntry){ alert('Could not find collection.anki21/.anki2 in this package. Re-export the deck.'); return }

  let mediaMap={}; if(entries['media']){ try{ mediaMap = await parseMediaEntry(entries['media']) }catch(e){ console.warn('media parse failed', e) } }
  const fileTable={}; for(const [k,v] of Object.entries(entries)) fileTable[k]=v;
  const replaceMedia = buildMediaReplacer(mediaMap, fileTable);
  log('Opening SQLite…');
  let db; try{ db = new SQL.Database(dbEntry) }catch(e){ alert('SQLite open failed: '+e?.message); return }

  let models={}, decks={}, crt=0;
  try{
    const col = db.exec(`SELECT * FROM col LIMIT 1`)[0];
    if(!col) throw new Error('no col rows');
    const row = Object.fromEntries(col.columns.map((c,i)=>[c,col.values[0][i]]));
    models = JSON.parse(row.models); decks = JSON.parse(row.decks); crt = Number(row.crt)||0;
  }catch(e){ alert('Failed to read collection metadata.'); return }

  const notes=[]; try{
    const r=db.exec(`SELECT id,guid,mid,flds,sfld,tags FROM notes`)[0];
    if(r){ for(const v of r.values){ notes.push(Object.fromEntries(r.columns.map((c,i)=>[c,v[i]]))) } }
  }catch(e){ alert('Failed to read notes table.'); return }
  const cards=[]; try{
    const r=db.exec(`SELECT id,nid,did,ord,type,queue,due,ivl FROM cards`)[0];
    if(r){ for(const v of r.values){ cards.push(Object.fromEntries(r.columns.map((c,i)=>[c,v[i]]))) } }
  }catch(e){ alert('Failed to read cards table.'); return }

  G.entries=entries; G.fileTable=fileTable; G.mediaMap=mediaMap; G.replaceMedia=replaceMedia;
  G.decks=decks; G.models=models; G.notes=notes; G.cards=cards; G.crt=crt;
  G.isClozeByMid={}; for(const [mid, m] of Object.entries(models)){ G.isClozeByMid[mid] = (m?.type===1) }
  G.nowSec = Math.floor(Date.now()/1000);
  G.today  = computeToday(G.nowSec, G.crt || G.nowSec, G.dayCutoffSec);
  G.seen=0; G.got=0; G.missed.length=0; G.correct.length=0; updateCounts();
  els.showStart.disabled=false;
  els.deckInfo.textContent=`Decks: ${Object.values(decks).length} · Cards: ${cards.length} · Notes: ${notes.length}`;
  els.title.textContent='Ready! Open “Configure & Start”.';
  log('Ready');
});

/* ========== Event Listeners ========== */
$('#showStart').addEventListener('click', ()=>{ els.startOverlay.style.display='flex' });
els.cancelStart.addEventListener('click', ()=>{ els.startOverlay.style.display='none' });
els.startBtn.addEventListener('click', ()=>{
  G.frontMs = Math.max(1, parseInt(els.frontSec.value||'12',10)) * 1000;
  G.backMs  = Math.max(1, parseInt(els.backSec.value||'8',10))  * 1000;
  G.useMirror = !!els.mirrorToggle.checked;
  els.startOverlay.style.display='none';
  startSession();
});
els.pauseBtn.addEventListener('click', ()=>{ G.paused? resume() : pause(true) });
els.resumeBtn.addEventListener('click', ()=>{ resume() });
els.toggleMiss.addEventListener('click', ()=>{ openDrawer('miss') });
els.toggleGot.addEventListener('click',  ()=>{ openDrawer('got')  });
els.tabMiss.addEventListener('click', ()=>{ openDrawer('miss') });
els.tabGot.addEventListener('click',  ()=>{ openDrawer('got')  });
els.exportList.addEventListener('click', exportActiveListCSV);
els.studyList.addEventListener('click', ()=>{
  const items = (drawerMode==='miss') ? G.missed : G.correct;
  const ids = new Set(items.map(m=>m.id));
  if(!ids.size){ alert('Nothing to study here.'); return }
  const subset = G.cards.filter(c=>ids.has(c.id));
  closeDrawer();
  G.seen=0; G.got=0; G.missed.length=0; G.correct.length=0; updateCounts();
  startSession(subset);
});
els.closeDrawer.addEventListener('click', closeDrawer);
els.restartBtn.addEventListener('click', ()=>{
  els.summary.style.display='none';
  G.seen=0; G.got=0; G.missed.length=0; G.correct.length=0; updateCounts();
  startSession();
});
els.missOnlyBtn.addEventListener('click', ()=>{
  els.summary.style.display='none';
  const ids = new Set(G.missed.map(m=>m.id));
  const subset = G.cards.filter(c=>ids.has(c.id));
  if(!subset.length){ alert('No missed items.'); return }
  G.seen=0; G.got=0; G.missed.length=0; G.correct.length=0; updateCounts();
  startSession(subset);
});
els.closeSummary.addEventListener('click', ()=>{ els.summary.style.display='none' });
els.reveal.addEventListener('click', ()=>reveal());
els.goodBtn.addEventListener('click', ()=>{ if(G.side==='front') reveal(); else handleAnswer(true) });
els.badBtn.addEventListener('click',  ()=>{ if(G.side==='front') reveal(); else handleAnswer(false) });
els.card.addEventListener('click', (e)=>{
  if(e.target.closest('button,a,audio,video,input')) return;
  if(G.side==='front'){ reveal() }
  else{
    const r = els.card.getBoundingClientRect();
    if(e.clientX < r.left + r.width/2){ handleAnswer(false) } else { handleAnswer(true) }
  }
});
$('#card').addEventListener('click', (ev)=>{
  const c = ev.target.closest('.cloze'); if(!c) return;
  if(G.side!=='front') return;
  const mask = c.querySelector('.cloze-mask'), ans = c.querySelector('.cloze-answer');
  if(!mask || !ans) return;
  const hidden = ans.style.display==='none';
  ans.style.display = hidden ? 'inline' : 'none';
  mask.style.display = hidden ? 'none' : 'inline';
});
window.addEventListener('keydown', (e)=>{
  if(e.target.closest('input,textarea')) return;
  if(e.key===' '){ e.preventDefault(); reveal(); return }
  if(e.key==='ArrowLeft'){ e.preventDefault(); if(G.side==='front') reveal(); else handleAnswer(false); return }
  if(e.key==='ArrowRight'){ e.preventDefault(); if(G.side==='front') reveal(); else handleAnswer(true);  return }
  if(e.key==='p' || e.key==='P'){ e.preventDefault(); G.paused? resume() : pause(true); return }
  if(e.key==='m' || e.key==='M'){ e.preventDefault(); openDrawer('miss'); return }
  if(e.key==='g' || e.key==='G'){ e.preventDefault(); openDrawer('got');  return }
});

/* ========== Init ========== */
function init(){
  measureHeader();
  els.reveal.disabled=false; els.goodBtn.disabled=false; els.badBtn.disabled=false;
}
if(window.ResizeObserver){
  const ro = new ResizeObserver(measureHeader);
  ro.observe(document.querySelector('header'));
} else {
  window.addEventListener('resize', measureHeader);
}
init();
</script>
</body>
</html>
